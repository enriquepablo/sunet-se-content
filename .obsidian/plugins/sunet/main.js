/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self = debug2;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/@kwsites/file-exists/dist/src/index.js
var require_src = __commonJS({
  "node_modules/@kwsites/file-exists/dist/src/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs_1 = require("fs");
    var debug_1 = __importDefault(require_browser());
    var log = debug_1.default("@kwsites/file-exists");
    function check(path, isFile, isDirectory) {
      log(`checking %s`, path);
      try {
        const stat = fs_1.statSync(path);
        if (stat.isFile() && isFile) {
          log(`[OK] path represents a file`);
          return true;
        }
        if (stat.isDirectory() && isDirectory) {
          log(`[OK] path represents a directory`);
          return true;
        }
        log(`[FAIL] path represents something other than a file or directory`);
        return false;
      } catch (e) {
        if (e.code === "ENOENT") {
          log(`[FAIL] path is not accessible: %o`, e);
          return false;
        }
        log(`[FATAL] %o`, e);
        throw e;
      }
    }
    function exists2(path, type = exports.READABLE) {
      return check(path, (type & exports.FILE) > 0, (type & exports.FOLDER) > 0);
    }
    exports.exists = exists2;
    exports.FILE = 1;
    exports.FOLDER = 2;
    exports.READABLE = exports.FILE + exports.FOLDER;
  }
});

// node_modules/@kwsites/file-exists/dist/index.js
var require_dist = __commonJS({
  "node_modules/@kwsites/file-exists/dist/index.js"(exports) {
    "use strict";
    function __export3(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export3(require_src());
  }
});

// node_modules/@kwsites/promise-deferred/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@kwsites/promise-deferred/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDeferred = exports.deferred = void 0;
    function deferred2() {
      let done;
      let fail;
      let status = "pending";
      const promise = new Promise((_done, _fail) => {
        done = _done;
        fail = _fail;
      });
      return {
        promise,
        done(result) {
          if (status === "pending") {
            status = "resolved";
            done(result);
          }
        },
        fail(error) {
          if (status === "pending") {
            status = "rejected";
            fail(error);
          }
        },
        get fulfilled() {
          return status !== "pending";
        },
        get status() {
          return status;
        }
      };
    }
    exports.deferred = deferred2;
    exports.createDeferred = deferred2;
    exports.default = deferred2;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SunetPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// node_modules/simple-git/dist/esm/index.js
var import_file_exists = __toESM(require_dist(), 1);
var import_debug = __toESM(require_browser(), 1);
var import_child_process = require("child_process");
var import_promise_deferred = __toESM(require_dist2(), 1);
var import_promise_deferred2 = __toESM(require_dist2(), 1);
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;
};
var __commonJS2 = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames2(module2))
      if (!__hasOwnProp2.call(target, key) && (copyDefault || key !== "default"))
        __defProp2(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc2(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toCommonJS2 = /* @__PURE__ */ ((cache2) => {
  return (module2, temp) => {
    return cache2 && cache2.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache2 && cache2.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function pathspec(...paths) {
  const key = new String(paths);
  cache.set(key, paths);
  return key;
}
function isPathSpec(path) {
  return path instanceof String && cache.has(path);
}
function toPaths(pathSpec) {
  return cache.get(pathSpec) || [];
}
var cache;
var init_pathspec = __esm({
  "src/lib/args/pathspec.ts"() {
    cache = /* @__PURE__ */ new WeakMap();
  }
});
var GitError;
var init_git_error = __esm({
  "src/lib/errors/git-error.ts"() {
    GitError = class extends Error {
      constructor(task, message) {
        super(message);
        this.task = task;
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
  }
});
var GitResponseError;
var init_git_response_error = __esm({
  "src/lib/errors/git-response-error.ts"() {
    init_git_error();
    GitResponseError = class extends GitError {
      constructor(git, message) {
        super(void 0, message || String(git));
        this.git = git;
      }
    };
  }
});
var TaskConfigurationError;
var init_task_configuration_error = __esm({
  "src/lib/errors/task-configuration-error.ts"() {
    init_git_error();
    TaskConfigurationError = class extends GitError {
      constructor(message) {
        super(void 0, message);
      }
    };
  }
});
function asFunction(source) {
  return typeof source === "function" ? source : NOOP;
}
function isUserFunction(source) {
  return typeof source === "function" && source !== NOOP;
}
function splitOn(input, char) {
  const index = input.indexOf(char);
  if (index <= 0) {
    return [input, ""];
  }
  return [input.substr(0, index), input.substr(index + 1)];
}
function first(input, offset = 0) {
  return isArrayLike(input) && input.length > offset ? input[offset] : void 0;
}
function last(input, offset = 0) {
  if (isArrayLike(input) && input.length > offset) {
    return input[input.length - 1 - offset];
  }
}
function isArrayLike(input) {
  return !!(input && typeof input.length === "number");
}
function toLinesWithContent(input = "", trimmed2 = true, separator = "\n") {
  return input.split(separator).reduce((output, line) => {
    const lineContent = trimmed2 ? line.trim() : line;
    if (lineContent) {
      output.push(lineContent);
    }
    return output;
  }, []);
}
function forEachLineWithContent(input, callback) {
  return toLinesWithContent(input, true).map((line) => callback(line));
}
function folderExists(path) {
  return (0, import_file_exists.exists)(path, import_file_exists.FOLDER);
}
function append(target, item) {
  if (Array.isArray(target)) {
    if (!target.includes(item)) {
      target.push(item);
    }
  } else {
    target.add(item);
  }
  return item;
}
function including(target, item) {
  if (Array.isArray(target) && !target.includes(item)) {
    target.push(item);
  }
  return target;
}
function remove(target, item) {
  if (Array.isArray(target)) {
    const index = target.indexOf(item);
    if (index >= 0) {
      target.splice(index, 1);
    }
  } else {
    target.delete(item);
  }
  return item;
}
function asArray(source) {
  return Array.isArray(source) ? source : [source];
}
function asStringArray(source) {
  return asArray(source).map(String);
}
function asNumber(source, onNaN = 0) {
  if (source == null) {
    return onNaN;
  }
  const num = parseInt(source, 10);
  return isNaN(num) ? onNaN : num;
}
function prefixedArray(input, prefix) {
  const output = [];
  for (let i = 0, max = input.length; i < max; i++) {
    output.push(prefix, input[i]);
  }
  return output;
}
function bufferToString(input) {
  return (Array.isArray(input) ? Buffer.concat(input) : input).toString("utf-8");
}
function pick(source, properties) {
  return Object.assign({}, ...properties.map((property) => property in source ? { [property]: source[property] } : {}));
}
function delay(duration = 0) {
  return new Promise((done) => setTimeout(done, duration));
}
function orVoid(input) {
  if (input === false) {
    return void 0;
  }
  return input;
}
var NULL;
var NOOP;
var objectToString;
var init_util = __esm({
  "src/lib/utils/util.ts"() {
    NULL = "\0";
    NOOP = () => {
    };
    objectToString = Object.prototype.toString.call.bind(Object.prototype.toString);
  }
});
function filterType(input, filter, def) {
  if (filter(input)) {
    return input;
  }
  return arguments.length > 2 ? def : void 0;
}
function filterPrimitives(input, omit) {
  const type = isPathSpec(input) ? "string" : typeof input;
  return /number|string|boolean/.test(type) && (!omit || !omit.includes(type));
}
function filterPlainObject(input) {
  return !!input && objectToString(input) === "[object Object]";
}
function filterFunction(input) {
  return typeof input === "function";
}
var filterArray;
var filterString;
var filterStringArray;
var filterStringOrStringArray;
var filterHasLength;
var init_argument_filters = __esm({
  "src/lib/utils/argument-filters.ts"() {
    init_util();
    init_pathspec();
    filterArray = (input) => {
      return Array.isArray(input);
    };
    filterString = (input) => {
      return typeof input === "string";
    };
    filterStringArray = (input) => {
      return Array.isArray(input) && input.every(filterString);
    };
    filterStringOrStringArray = (input) => {
      return filterString(input) || Array.isArray(input) && input.every(filterString);
    };
    filterHasLength = (input) => {
      if (input == null || "number|boolean|function".includes(typeof input)) {
        return false;
      }
      return Array.isArray(input) || typeof input === "string" || typeof input.length === "number";
    };
  }
});
var ExitCodes;
var init_exit_codes = __esm({
  "src/lib/utils/exit-codes.ts"() {
    ExitCodes = /* @__PURE__ */ ((ExitCodes2) => {
      ExitCodes2[ExitCodes2["SUCCESS"] = 0] = "SUCCESS";
      ExitCodes2[ExitCodes2["ERROR"] = 1] = "ERROR";
      ExitCodes2[ExitCodes2["NOT_FOUND"] = -2] = "NOT_FOUND";
      ExitCodes2[ExitCodes2["UNCLEAN"] = 128] = "UNCLEAN";
      return ExitCodes2;
    })(ExitCodes || {});
  }
});
var GitOutputStreams;
var init_git_output_streams = __esm({
  "src/lib/utils/git-output-streams.ts"() {
    GitOutputStreams = class {
      constructor(stdOut, stdErr) {
        this.stdOut = stdOut;
        this.stdErr = stdErr;
      }
      asStrings() {
        return new GitOutputStreams(this.stdOut.toString("utf8"), this.stdErr.toString("utf8"));
      }
    };
  }
});
var LineParser;
var RemoteLineParser;
var init_line_parser = __esm({
  "src/lib/utils/line-parser.ts"() {
    LineParser = class {
      constructor(regExp, useMatches) {
        this.matches = [];
        this.parse = (line, target) => {
          this.resetMatches();
          if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {
            return false;
          }
          return this.useMatches(target, this.prepareMatches()) !== false;
        };
        this._regExp = Array.isArray(regExp) ? regExp : [regExp];
        if (useMatches) {
          this.useMatches = useMatches;
        }
      }
      useMatches(target, match) {
        throw new Error(`LineParser:useMatches not implemented`);
      }
      resetMatches() {
        this.matches.length = 0;
      }
      prepareMatches() {
        return this.matches;
      }
      addMatch(reg, index, line) {
        const matched = line && reg.exec(line);
        if (matched) {
          this.pushMatch(index, matched);
        }
        return !!matched;
      }
      pushMatch(_index, matched) {
        this.matches.push(...matched.slice(1));
      }
    };
    RemoteLineParser = class extends LineParser {
      addMatch(reg, index, line) {
        return /^remote:\s/.test(String(line)) && super.addMatch(reg, index, line);
      }
      pushMatch(index, matched) {
        if (index > 0 || matched.length > 1) {
          super.pushMatch(index, matched);
        }
      }
    };
  }
});
function createInstanceConfig(...options) {
  const baseDir = process.cwd();
  const config = Object.assign(__spreadValues({ baseDir }, defaultOptions), ...options.filter((o) => typeof o === "object" && o));
  config.baseDir = config.baseDir || baseDir;
  config.trimmed = config.trimmed === true;
  return config;
}
var defaultOptions;
var init_simple_git_options = __esm({
  "src/lib/utils/simple-git-options.ts"() {
    defaultOptions = {
      binary: "git",
      maxConcurrentProcesses: 5,
      config: [],
      trimmed: false
    };
  }
});
function appendTaskOptions(options, commands = []) {
  if (!filterPlainObject(options)) {
    return commands;
  }
  return Object.keys(options).reduce((commands2, key) => {
    const value = options[key];
    if (isPathSpec(value)) {
      commands2.push(value);
    } else if (filterPrimitives(value, ["boolean"])) {
      commands2.push(key + "=" + value);
    } else {
      commands2.push(key);
    }
    return commands2;
  }, commands);
}
function getTrailingOptions(args, initialPrimitive = 0, objectOnly = false) {
  const command = [];
  for (let i = 0, max = initialPrimitive < 0 ? args.length : initialPrimitive; i < max; i++) {
    if ("string|number".includes(typeof args[i])) {
      command.push(String(args[i]));
    }
  }
  appendTaskOptions(trailingOptionsArgument(args), command);
  if (!objectOnly) {
    command.push(...trailingArrayArgument(args));
  }
  return command;
}
function trailingArrayArgument(args) {
  const hasTrailingCallback = typeof last(args) === "function";
  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterArray, []);
}
function trailingOptionsArgument(args) {
  const hasTrailingCallback = filterFunction(last(args));
  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterPlainObject);
}
function trailingFunctionArgument(args, includeNoop = true) {
  const callback = asFunction(last(args));
  return includeNoop || isUserFunction(callback) ? callback : void 0;
}
var init_task_options = __esm({
  "src/lib/utils/task-options.ts"() {
    init_argument_filters();
    init_util();
    init_pathspec();
  }
});
function callTaskParser(parser3, streams) {
  return parser3(streams.stdOut, streams.stdErr);
}
function parseStringResponse(result, parsers12, texts, trim = true) {
  asArray(texts).forEach((text) => {
    for (let lines = toLinesWithContent(text, trim), i = 0, max = lines.length; i < max; i++) {
      const line = (offset = 0) => {
        if (i + offset >= max) {
          return;
        }
        return lines[i + offset];
      };
      parsers12.some(({ parse }) => parse(line, result));
    }
  });
  return result;
}
var init_task_parser = __esm({
  "src/lib/utils/task-parser.ts"() {
    init_util();
  }
});
var utils_exports = {};
__export2(utils_exports, {
  ExitCodes: () => ExitCodes,
  GitOutputStreams: () => GitOutputStreams,
  LineParser: () => LineParser,
  NOOP: () => NOOP,
  NULL: () => NULL,
  RemoteLineParser: () => RemoteLineParser,
  append: () => append,
  appendTaskOptions: () => appendTaskOptions,
  asArray: () => asArray,
  asFunction: () => asFunction,
  asNumber: () => asNumber,
  asStringArray: () => asStringArray,
  bufferToString: () => bufferToString,
  callTaskParser: () => callTaskParser,
  createInstanceConfig: () => createInstanceConfig,
  delay: () => delay,
  filterArray: () => filterArray,
  filterFunction: () => filterFunction,
  filterHasLength: () => filterHasLength,
  filterPlainObject: () => filterPlainObject,
  filterPrimitives: () => filterPrimitives,
  filterString: () => filterString,
  filterStringArray: () => filterStringArray,
  filterStringOrStringArray: () => filterStringOrStringArray,
  filterType: () => filterType,
  first: () => first,
  folderExists: () => folderExists,
  forEachLineWithContent: () => forEachLineWithContent,
  getTrailingOptions: () => getTrailingOptions,
  including: () => including,
  isUserFunction: () => isUserFunction,
  last: () => last,
  objectToString: () => objectToString,
  orVoid: () => orVoid,
  parseStringResponse: () => parseStringResponse,
  pick: () => pick,
  prefixedArray: () => prefixedArray,
  remove: () => remove,
  splitOn: () => splitOn,
  toLinesWithContent: () => toLinesWithContent,
  trailingFunctionArgument: () => trailingFunctionArgument,
  trailingOptionsArgument: () => trailingOptionsArgument
});
var init_utils = __esm({
  "src/lib/utils/index.ts"() {
    init_argument_filters();
    init_exit_codes();
    init_git_output_streams();
    init_line_parser();
    init_simple_git_options();
    init_task_options();
    init_task_parser();
    init_util();
  }
});
var check_is_repo_exports = {};
__export2(check_is_repo_exports, {
  CheckRepoActions: () => CheckRepoActions,
  checkIsBareRepoTask: () => checkIsBareRepoTask,
  checkIsRepoRootTask: () => checkIsRepoRootTask,
  checkIsRepoTask: () => checkIsRepoTask
});
function checkIsRepoTask(action) {
  switch (action) {
    case "bare":
      return checkIsBareRepoTask();
    case "root":
      return checkIsRepoRootTask();
  }
  const commands = ["rev-parse", "--is-inside-work-tree"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser
  };
}
function checkIsRepoRootTask() {
  const commands = ["rev-parse", "--git-dir"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser(path) {
      return /^\.(git)?$/.test(path.trim());
    }
  };
}
function checkIsBareRepoTask() {
  const commands = ["rev-parse", "--is-bare-repository"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser
  };
}
function isNotRepoMessage(error) {
  return /(Not a git repository|Kein Git-Repository)/i.test(String(error));
}
var CheckRepoActions;
var onError;
var parser;
var init_check_is_repo = __esm({
  "src/lib/tasks/check-is-repo.ts"() {
    init_utils();
    CheckRepoActions = /* @__PURE__ */ ((CheckRepoActions2) => {
      CheckRepoActions2["BARE"] = "bare";
      CheckRepoActions2["IN_TREE"] = "tree";
      CheckRepoActions2["IS_REPO_ROOT"] = "root";
      return CheckRepoActions2;
    })(CheckRepoActions || {});
    onError = ({ exitCode }, error, done, fail) => {
      if (exitCode === 128 && isNotRepoMessage(error)) {
        return done(Buffer.from("false"));
      }
      fail(error);
    };
    parser = (text) => {
      return text.trim() === "true";
    };
  }
});
function cleanSummaryParser(dryRun, text) {
  const summary = new CleanResponse(dryRun);
  const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;
  toLinesWithContent(text).forEach((line) => {
    const removed = line.replace(regexp, "");
    summary.paths.push(removed);
    (isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);
  });
  return summary;
}
var CleanResponse;
var removalRegexp;
var dryRunRemovalRegexp;
var isFolderRegexp;
var init_CleanSummary = __esm({
  "src/lib/responses/CleanSummary.ts"() {
    init_utils();
    CleanResponse = class {
      constructor(dryRun) {
        this.dryRun = dryRun;
        this.paths = [];
        this.files = [];
        this.folders = [];
      }
    };
    removalRegexp = /^[a-z]+\s*/i;
    dryRunRemovalRegexp = /^[a-z]+\s+[a-z]+\s*/i;
    isFolderRegexp = /\/$/;
  }
});
var task_exports = {};
__export2(task_exports, {
  EMPTY_COMMANDS: () => EMPTY_COMMANDS,
  adhocExecTask: () => adhocExecTask,
  configurationErrorTask: () => configurationErrorTask,
  isBufferTask: () => isBufferTask,
  isEmptyTask: () => isEmptyTask,
  straightThroughBufferTask: () => straightThroughBufferTask,
  straightThroughStringTask: () => straightThroughStringTask
});
function adhocExecTask(parser3) {
  return {
    commands: EMPTY_COMMANDS,
    format: "empty",
    parser: parser3
  };
}
function configurationErrorTask(error) {
  return {
    commands: EMPTY_COMMANDS,
    format: "empty",
    parser() {
      throw typeof error === "string" ? new TaskConfigurationError(error) : error;
    }
  };
}
function straightThroughStringTask(commands, trimmed2 = false) {
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return trimmed2 ? String(text).trim() : text;
    }
  };
}
function straightThroughBufferTask(commands) {
  return {
    commands,
    format: "buffer",
    parser(buffer) {
      return buffer;
    }
  };
}
function isBufferTask(task) {
  return task.format === "buffer";
}
function isEmptyTask(task) {
  return task.format === "empty" || !task.commands.length;
}
var EMPTY_COMMANDS;
var init_task = __esm({
  "src/lib/tasks/task.ts"() {
    init_task_configuration_error();
    EMPTY_COMMANDS = [];
  }
});
var clean_exports = {};
__export2(clean_exports, {
  CONFIG_ERROR_INTERACTIVE_MODE: () => CONFIG_ERROR_INTERACTIVE_MODE,
  CONFIG_ERROR_MODE_REQUIRED: () => CONFIG_ERROR_MODE_REQUIRED,
  CONFIG_ERROR_UNKNOWN_OPTION: () => CONFIG_ERROR_UNKNOWN_OPTION,
  CleanOptions: () => CleanOptions,
  cleanTask: () => cleanTask,
  cleanWithOptionsTask: () => cleanWithOptionsTask,
  isCleanOptionsArray: () => isCleanOptionsArray
});
function cleanWithOptionsTask(mode, customArgs) {
  const { cleanMode, options, valid } = getCleanOptions(mode);
  if (!cleanMode) {
    return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);
  }
  if (!valid.options) {
    return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));
  }
  options.push(...customArgs);
  if (options.some(isInteractiveMode)) {
    return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);
  }
  return cleanTask(cleanMode, options);
}
function cleanTask(mode, customArgs) {
  const commands = ["clean", `-${mode}`, ...customArgs];
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return cleanSummaryParser(mode === "n", text);
    }
  };
}
function isCleanOptionsArray(input) {
  return Array.isArray(input) && input.every((test) => CleanOptionValues.has(test));
}
function getCleanOptions(input) {
  let cleanMode;
  let options = [];
  let valid = { cleanMode: false, options: true };
  input.replace(/[^a-z]i/g, "").split("").forEach((char) => {
    if (isCleanMode(char)) {
      cleanMode = char;
      valid.cleanMode = true;
    } else {
      valid.options = valid.options && isKnownOption(options[options.length] = `-${char}`);
    }
  });
  return {
    cleanMode,
    options,
    valid
  };
}
function isCleanMode(cleanMode) {
  return cleanMode === "f" || cleanMode === "n";
}
function isKnownOption(option) {
  return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt(1));
}
function isInteractiveMode(option) {
  if (/^-[^\-]/.test(option)) {
    return option.indexOf("i") > 0;
  }
  return option === "--interactive";
}
var CONFIG_ERROR_INTERACTIVE_MODE;
var CONFIG_ERROR_MODE_REQUIRED;
var CONFIG_ERROR_UNKNOWN_OPTION;
var CleanOptions;
var CleanOptionValues;
var init_clean = __esm({
  "src/lib/tasks/clean.ts"() {
    init_CleanSummary();
    init_utils();
    init_task();
    CONFIG_ERROR_INTERACTIVE_MODE = "Git clean interactive mode is not supported";
    CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter ("n" or "f") is required';
    CONFIG_ERROR_UNKNOWN_OPTION = "Git clean unknown option found in: ";
    CleanOptions = /* @__PURE__ */ ((CleanOptions22) => {
      CleanOptions22["DRY_RUN"] = "n";
      CleanOptions22["FORCE"] = "f";
      CleanOptions22["IGNORED_INCLUDED"] = "x";
      CleanOptions22["IGNORED_ONLY"] = "X";
      CleanOptions22["EXCLUDING"] = "e";
      CleanOptions22["QUIET"] = "q";
      CleanOptions22["RECURSIVE"] = "d";
      return CleanOptions22;
    })(CleanOptions || {});
    CleanOptionValues = /* @__PURE__ */ new Set([
      "i",
      ...asStringArray(Object.values(CleanOptions))
    ]);
  }
});
function configListParser(text) {
  const config = new ConfigList();
  for (const item of configParser(text)) {
    config.addValue(item.file, String(item.key), item.value);
  }
  return config;
}
function configGetParser(text, key) {
  let value = null;
  const values = [];
  const scopes = /* @__PURE__ */ new Map();
  for (const item of configParser(text, key)) {
    if (item.key !== key) {
      continue;
    }
    values.push(value = item.value);
    if (!scopes.has(item.file)) {
      scopes.set(item.file, []);
    }
    scopes.get(item.file).push(value);
  }
  return {
    key,
    paths: Array.from(scopes.keys()),
    scopes,
    value,
    values
  };
}
function configFilePath(filePath) {
  return filePath.replace(/^(file):/, "");
}
function* configParser(text, requestedKey = null) {
  const lines = text.split("\0");
  for (let i = 0, max = lines.length - 1; i < max; ) {
    const file = configFilePath(lines[i++]);
    let value = lines[i++];
    let key = requestedKey;
    if (value.includes("\n")) {
      const line = splitOn(value, "\n");
      key = line[0];
      value = line[1];
    }
    yield { file, key, value };
  }
}
var ConfigList;
var init_ConfigList = __esm({
  "src/lib/responses/ConfigList.ts"() {
    init_utils();
    ConfigList = class {
      constructor() {
        this.files = [];
        this.values = /* @__PURE__ */ Object.create(null);
      }
      get all() {
        if (!this._all) {
          this._all = this.files.reduce((all, file) => {
            return Object.assign(all, this.values[file]);
          }, {});
        }
        return this._all;
      }
      addFile(file) {
        if (!(file in this.values)) {
          const latest = last(this.files);
          this.values[file] = latest ? Object.create(this.values[latest]) : {};
          this.files.push(file);
        }
        return this.values[file];
      }
      addValue(file, key, value) {
        const values = this.addFile(file);
        if (!values.hasOwnProperty(key)) {
          values[key] = value;
        } else if (Array.isArray(values[key])) {
          values[key].push(value);
        } else {
          values[key] = [values[key], value];
        }
        this._all = void 0;
      }
    };
  }
});
function asConfigScope(scope, fallback) {
  if (typeof scope === "string" && GitConfigScope.hasOwnProperty(scope)) {
    return scope;
  }
  return fallback;
}
function addConfigTask(key, value, append2, scope) {
  const commands = ["config", `--${scope}`];
  if (append2) {
    commands.push("--add");
  }
  commands.push(key, value);
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return text;
    }
  };
}
function getConfigTask(key, scope) {
  const commands = ["config", "--null", "--show-origin", "--get-all", key];
  if (scope) {
    commands.splice(1, 0, `--${scope}`);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return configGetParser(text, key);
    }
  };
}
function listConfigTask(scope) {
  const commands = ["config", "--list", "--show-origin", "--null"];
  if (scope) {
    commands.push(`--${scope}`);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return configListParser(text);
    }
  };
}
function config_default() {
  return {
    addConfig(key, value, ...rest) {
      return this._runTask(addConfigTask(key, value, rest[0] === true, asConfigScope(
        rest[1],
        "local"
        /* local */
      )), trailingFunctionArgument(arguments));
    },
    getConfig(key, scope) {
      return this._runTask(getConfigTask(key, asConfigScope(scope, void 0)), trailingFunctionArgument(arguments));
    },
    listConfig(...rest) {
      return this._runTask(listConfigTask(asConfigScope(rest[0], void 0)), trailingFunctionArgument(arguments));
    }
  };
}
var GitConfigScope;
var init_config = __esm({
  "src/lib/tasks/config.ts"() {
    init_ConfigList();
    init_utils();
    GitConfigScope = /* @__PURE__ */ ((GitConfigScope2) => {
      GitConfigScope2["system"] = "system";
      GitConfigScope2["global"] = "global";
      GitConfigScope2["local"] = "local";
      GitConfigScope2["worktree"] = "worktree";
      return GitConfigScope2;
    })(GitConfigScope || {});
  }
});
function isDiffNameStatus(input) {
  return diffNameStatus.has(input);
}
var DiffNameStatus;
var diffNameStatus;
var init_diff_name_status = __esm({
  "src/lib/tasks/diff-name-status.ts"() {
    DiffNameStatus = /* @__PURE__ */ ((DiffNameStatus2) => {
      DiffNameStatus2["ADDED"] = "A";
      DiffNameStatus2["COPIED"] = "C";
      DiffNameStatus2["DELETED"] = "D";
      DiffNameStatus2["MODIFIED"] = "M";
      DiffNameStatus2["RENAMED"] = "R";
      DiffNameStatus2["CHANGED"] = "T";
      DiffNameStatus2["UNMERGED"] = "U";
      DiffNameStatus2["UNKNOWN"] = "X";
      DiffNameStatus2["BROKEN"] = "B";
      return DiffNameStatus2;
    })(DiffNameStatus || {});
    diffNameStatus = new Set(Object.values(DiffNameStatus));
  }
});
function grepQueryBuilder(...params) {
  return new GrepQuery().param(...params);
}
function parseGrep(grep) {
  const paths = /* @__PURE__ */ new Set();
  const results = {};
  forEachLineWithContent(grep, (input) => {
    const [path, line, preview] = input.split(NULL);
    paths.add(path);
    (results[path] = results[path] || []).push({
      line: asNumber(line),
      path,
      preview
    });
  });
  return {
    paths,
    results
  };
}
function grep_default() {
  return {
    grep(searchTerm) {
      const then = trailingFunctionArgument(arguments);
      const options = getTrailingOptions(arguments);
      for (const option of disallowedOptions) {
        if (options.includes(option)) {
          return this._runTask(configurationErrorTask(`git.grep: use of "${option}" is not supported.`), then);
        }
      }
      if (typeof searchTerm === "string") {
        searchTerm = grepQueryBuilder().param(searchTerm);
      }
      const commands = ["grep", "--null", "-n", "--full-name", ...options, ...searchTerm];
      return this._runTask({
        commands,
        format: "utf-8",
        parser(stdOut) {
          return parseGrep(stdOut);
        }
      }, then);
    }
  };
}
var disallowedOptions;
var Query;
var _a;
var GrepQuery;
var init_grep = __esm({
  "src/lib/tasks/grep.ts"() {
    init_utils();
    init_task();
    disallowedOptions = ["-h"];
    Query = Symbol("grepQuery");
    GrepQuery = class {
      constructor() {
        this[_a] = [];
      }
      *[(_a = Query, Symbol.iterator)]() {
        for (const query of this[Query]) {
          yield query;
        }
      }
      and(...and) {
        and.length && this[Query].push("--and", "(", ...prefixedArray(and, "-e"), ")");
        return this;
      }
      param(...param) {
        this[Query].push(...prefixedArray(param, "-e"));
        return this;
      }
    };
  }
});
var reset_exports = {};
__export2(reset_exports, {
  ResetMode: () => ResetMode,
  getResetMode: () => getResetMode,
  resetTask: () => resetTask
});
function resetTask(mode, customArgs) {
  const commands = ["reset"];
  if (isValidResetMode(mode)) {
    commands.push(`--${mode}`);
  }
  commands.push(...customArgs);
  return straightThroughStringTask(commands);
}
function getResetMode(mode) {
  if (isValidResetMode(mode)) {
    return mode;
  }
  switch (typeof mode) {
    case "string":
    case "undefined":
      return "soft";
  }
  return;
}
function isValidResetMode(mode) {
  return ResetModes.includes(mode);
}
var ResetMode;
var ResetModes;
var init_reset = __esm({
  "src/lib/tasks/reset.ts"() {
    init_task();
    ResetMode = /* @__PURE__ */ ((ResetMode2) => {
      ResetMode2["MIXED"] = "mixed";
      ResetMode2["SOFT"] = "soft";
      ResetMode2["HARD"] = "hard";
      ResetMode2["MERGE"] = "merge";
      ResetMode2["KEEP"] = "keep";
      return ResetMode2;
    })(ResetMode || {});
    ResetModes = Array.from(Object.values(ResetMode));
  }
});
function createLog() {
  return (0, import_debug.default)("simple-git");
}
function prefixedLogger(to, prefix, forward) {
  if (!prefix || !String(prefix).replace(/\s*/, "")) {
    return !forward ? to : (message, ...args) => {
      to(message, ...args);
      forward(message, ...args);
    };
  }
  return (message, ...args) => {
    to(`%s ${message}`, prefix, ...args);
    if (forward) {
      forward(message, ...args);
    }
  };
}
function childLoggerName(name, childDebugger, { namespace: parentNamespace }) {
  if (typeof name === "string") {
    return name;
  }
  const childNamespace = childDebugger && childDebugger.namespace || "";
  if (childNamespace.startsWith(parentNamespace)) {
    return childNamespace.substr(parentNamespace.length + 1);
  }
  return childNamespace || parentNamespace;
}
function createLogger(label, verbose, initialStep, infoDebugger = createLog()) {
  const labelPrefix = label && `[${label}]` || "";
  const spawned = [];
  const debugDebugger = typeof verbose === "string" ? infoDebugger.extend(verbose) : verbose;
  const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);
  return step(initialStep);
  function sibling(name, initial) {
    return append(spawned, createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger));
  }
  function step(phase) {
    const stepPrefix = phase && `[${phase}]` || "";
    const debug2 = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || NOOP;
    const info = prefixedLogger(infoDebugger, `${labelPrefix} ${stepPrefix}`, debug2);
    return Object.assign(debugDebugger ? debug2 : info, {
      label,
      sibling,
      info,
      step
    });
  }
}
var init_git_logger = __esm({
  "src/lib/git-logger.ts"() {
    init_utils();
    import_debug.default.formatters.L = (value) => String(filterHasLength(value) ? value.length : "-");
    import_debug.default.formatters.B = (value) => {
      if (Buffer.isBuffer(value)) {
        return value.toString("utf8");
      }
      return objectToString(value);
    };
  }
});
var _TasksPendingQueue;
var TasksPendingQueue;
var init_tasks_pending_queue = __esm({
  "src/lib/runners/tasks-pending-queue.ts"() {
    init_git_error();
    init_git_logger();
    _TasksPendingQueue = class {
      constructor(logLabel = "GitExecutor") {
        this.logLabel = logLabel;
        this._queue = /* @__PURE__ */ new Map();
      }
      withProgress(task) {
        return this._queue.get(task);
      }
      createProgress(task) {
        const name = _TasksPendingQueue.getName(task.commands[0]);
        const logger = createLogger(this.logLabel, name);
        return {
          task,
          logger,
          name
        };
      }
      push(task) {
        const progress = this.createProgress(task);
        progress.logger("Adding task to the queue, commands = %o", task.commands);
        this._queue.set(task, progress);
        return progress;
      }
      fatal(err) {
        for (const [task, { logger }] of Array.from(this._queue.entries())) {
          if (task === err.task) {
            logger.info(`Failed %o`, err);
            logger(`Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`);
          } else {
            logger.info(`A fatal exception occurred in a previous task, the queue has been purged: %o`, err.message);
          }
          this.complete(task);
        }
        if (this._queue.size !== 0) {
          throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);
        }
      }
      complete(task) {
        const progress = this.withProgress(task);
        if (progress) {
          this._queue.delete(task);
        }
      }
      attempt(task) {
        const progress = this.withProgress(task);
        if (!progress) {
          throw new GitError(void 0, "TasksPendingQueue: attempt called for an unknown task");
        }
        progress.logger("Starting task");
        return progress;
      }
      static getName(name = "empty") {
        return `task:${name}:${++_TasksPendingQueue.counter}`;
      }
    };
    TasksPendingQueue = _TasksPendingQueue;
    TasksPendingQueue.counter = 0;
  }
});
function pluginContext(task, commands) {
  return {
    method: first(task.commands) || "",
    commands
  };
}
function onErrorReceived(target, logger) {
  return (err) => {
    logger(`[ERROR] child process exception %o`, err);
    target.push(Buffer.from(String(err.stack), "ascii"));
  };
}
function onDataReceived(target, name, logger, output) {
  return (buffer) => {
    logger(`%s received %L bytes`, name, buffer);
    output(`%B`, buffer);
    target.push(buffer);
  };
}
var GitExecutorChain;
var init_git_executor_chain = __esm({
  "src/lib/runners/git-executor-chain.ts"() {
    init_git_error();
    init_task();
    init_utils();
    init_tasks_pending_queue();
    GitExecutorChain = class {
      constructor(_executor, _scheduler, _plugins) {
        this._executor = _executor;
        this._scheduler = _scheduler;
        this._plugins = _plugins;
        this._chain = Promise.resolve();
        this._queue = new TasksPendingQueue();
      }
      get binary() {
        return this._executor.binary;
      }
      get cwd() {
        return this._cwd || this._executor.cwd;
      }
      set cwd(cwd) {
        this._cwd = cwd;
      }
      get env() {
        return this._executor.env;
      }
      get outputHandler() {
        return this._executor.outputHandler;
      }
      chain() {
        return this;
      }
      push(task) {
        this._queue.push(task);
        return this._chain = this._chain.then(() => this.attemptTask(task));
      }
      attemptTask(task) {
        return __async(this, null, function* () {
          const onScheduleComplete = yield this._scheduler.next();
          const onQueueComplete = () => this._queue.complete(task);
          try {
            const { logger } = this._queue.attempt(task);
            return yield isEmptyTask(task) ? this.attemptEmptyTask(task, logger) : this.attemptRemoteTask(task, logger);
          } catch (e) {
            throw this.onFatalException(task, e);
          } finally {
            onQueueComplete();
            onScheduleComplete();
          }
        });
      }
      onFatalException(task, e) {
        const gitError = e instanceof GitError ? Object.assign(e, { task }) : new GitError(task, e && String(e));
        this._chain = Promise.resolve();
        this._queue.fatal(gitError);
        return gitError;
      }
      attemptRemoteTask(task, logger) {
        return __async(this, null, function* () {
          const args = this._plugins.exec("spawn.args", [...task.commands], pluginContext(task, task.commands));
          const raw = yield this.gitResponse(task, this.binary, args, this.outputHandler, logger.step("SPAWN"));
          const outputStreams = yield this.handleTaskData(task, args, raw, logger.step("HANDLE"));
          logger(`passing response to task's parser as a %s`, task.format);
          if (isBufferTask(task)) {
            return callTaskParser(task.parser, outputStreams);
          }
          return callTaskParser(task.parser, outputStreams.asStrings());
        });
      }
      attemptEmptyTask(task, logger) {
        return __async(this, null, function* () {
          logger(`empty task bypassing child process to call to task's parser`);
          return task.parser(this);
        });
      }
      handleTaskData(task, args, result, logger) {
        const { exitCode, rejection, stdOut, stdErr } = result;
        return new Promise((done, fail) => {
          logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);
          const { error } = this._plugins.exec("task.error", { error: rejection }, __spreadValues(__spreadValues({}, pluginContext(task, args)), result));
          if (error && task.onError) {
            logger.info(`exitCode=%s handling with custom error handler`);
            return task.onError(result, error, (newStdOut) => {
              logger.info(`custom error handler treated as success`);
              logger(`custom error returned a %s`, objectToString(newStdOut));
              done(new GitOutputStreams(Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut, Buffer.concat(stdErr)));
            }, fail);
          }
          if (error) {
            logger.info(`handling as error: exitCode=%s stdErr=%s rejection=%o`, exitCode, stdErr.length, rejection);
            return fail(error);
          }
          logger.info(`retrieving task output complete`);
          done(new GitOutputStreams(Buffer.concat(stdOut), Buffer.concat(stdErr)));
        });
      }
      gitResponse(task, command, args, outputHandler, logger) {
        return __async(this, null, function* () {
          const outputLogger = logger.sibling("output");
          const spawnOptions = this._plugins.exec("spawn.options", {
            cwd: this.cwd,
            env: this.env,
            windowsHide: true
          }, pluginContext(task, task.commands));
          return new Promise((done) => {
            const stdOut = [];
            const stdErr = [];
            logger.info(`%s %o`, command, args);
            logger("%O", spawnOptions);
            let rejection = this._beforeSpawn(task, args);
            if (rejection) {
              return done({
                stdOut,
                stdErr,
                exitCode: 9901,
                rejection
              });
            }
            this._plugins.exec("spawn.before", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {
              kill(reason) {
                rejection = reason || rejection;
              }
            }));
            const spawned = (0, import_child_process.spawn)(command, args, spawnOptions);
            spawned.stdout.on("data", onDataReceived(stdOut, "stdOut", logger, outputLogger.step("stdOut")));
            spawned.stderr.on("data", onDataReceived(stdErr, "stdErr", logger, outputLogger.step("stdErr")));
            spawned.on("error", onErrorReceived(stdErr, logger));
            if (outputHandler) {
              logger(`Passing child process stdOut/stdErr to custom outputHandler`);
              outputHandler(command, spawned.stdout, spawned.stderr, [...args]);
            }
            this._plugins.exec("spawn.after", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {
              spawned,
              close(exitCode, reason) {
                done({
                  stdOut,
                  stdErr,
                  exitCode,
                  rejection: rejection || reason
                });
              },
              kill(reason) {
                if (spawned.killed) {
                  return;
                }
                rejection = reason;
                spawned.kill("SIGINT");
              }
            }));
          });
        });
      }
      _beforeSpawn(task, args) {
        let rejection;
        this._plugins.exec("spawn.before", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {
          kill(reason) {
            rejection = reason || rejection;
          }
        }));
        return rejection;
      }
    };
  }
});
var git_executor_exports = {};
__export2(git_executor_exports, {
  GitExecutor: () => GitExecutor
});
var GitExecutor;
var init_git_executor = __esm({
  "src/lib/runners/git-executor.ts"() {
    init_git_executor_chain();
    GitExecutor = class {
      constructor(binary = "git", cwd, _scheduler, _plugins) {
        this.binary = binary;
        this.cwd = cwd;
        this._scheduler = _scheduler;
        this._plugins = _plugins;
        this._chain = new GitExecutorChain(this, this._scheduler, this._plugins);
      }
      chain() {
        return new GitExecutorChain(this, this._scheduler, this._plugins);
      }
      push(task) {
        return this._chain.push(task);
      }
    };
  }
});
function taskCallback(task, response, callback = NOOP) {
  const onSuccess = (data) => {
    callback(null, data);
  };
  const onError2 = (err) => {
    if ((err == null ? void 0 : err.task) === task) {
      callback(err instanceof GitResponseError ? addDeprecationNoticeToError(err) : err, void 0);
    }
  };
  response.then(onSuccess, onError2);
}
function addDeprecationNoticeToError(err) {
  let log = (name) => {
    console.warn(`simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`);
    log = NOOP;
  };
  return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));
  function descriptorReducer(all, name) {
    if (name in err) {
      return all;
    }
    all[name] = {
      enumerable: false,
      configurable: false,
      get() {
        log(name);
        return err.git[name];
      }
    };
    return all;
  }
}
var init_task_callback = __esm({
  "src/lib/task-callback.ts"() {
    init_git_response_error();
    init_utils();
  }
});
function changeWorkingDirectoryTask(directory, root) {
  return adhocExecTask((instance) => {
    if (!folderExists(directory)) {
      throw new Error(`Git.cwd: cannot change to non-directory "${directory}"`);
    }
    return (root || instance).cwd = directory;
  });
}
var init_change_working_directory = __esm({
  "src/lib/tasks/change-working-directory.ts"() {
    init_utils();
    init_task();
  }
});
function checkoutTask(args) {
  const commands = ["checkout", ...args];
  if (commands[1] === "-b" && commands.includes("-B")) {
    commands[1] = remove(commands, "-B");
  }
  return straightThroughStringTask(commands);
}
function checkout_default() {
  return {
    checkout() {
      return this._runTask(checkoutTask(getTrailingOptions(arguments, 1)), trailingFunctionArgument(arguments));
    },
    checkoutBranch(branchName, startPoint) {
      return this._runTask(checkoutTask(["-b", branchName, startPoint, ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments));
    },
    checkoutLocalBranch(branchName) {
      return this._runTask(checkoutTask(["-b", branchName, ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments));
    }
  };
}
var init_checkout = __esm({
  "src/lib/tasks/checkout.ts"() {
    init_utils();
    init_task();
  }
});
function parseCommitResult(stdOut) {
  const result = {
    author: null,
    branch: "",
    commit: "",
    root: false,
    summary: {
      changes: 0,
      insertions: 0,
      deletions: 0
    }
  };
  return parseStringResponse(result, parsers, stdOut);
}
var parsers;
var init_parse_commit = __esm({
  "src/lib/parsers/parse-commit.ts"() {
    init_utils();
    parsers = [
      new LineParser(/^\[([^\s]+)( \([^)]+\))? ([^\]]+)/, (result, [branch, root, commit]) => {
        result.branch = branch;
        result.commit = commit;
        result.root = !!root;
      }),
      new LineParser(/\s*Author:\s(.+)/i, (result, [author]) => {
        const parts = author.split("<");
        const email = parts.pop();
        if (!email || !email.includes("@")) {
          return;
        }
        result.author = {
          email: email.substr(0, email.length - 1),
          name: parts.join("<").trim()
        };
      }),
      new LineParser(/(\d+)[^,]*(?:,\s*(\d+)[^,]*)(?:,\s*(\d+))/g, (result, [changes, insertions, deletions]) => {
        result.summary.changes = parseInt(changes, 10) || 0;
        result.summary.insertions = parseInt(insertions, 10) || 0;
        result.summary.deletions = parseInt(deletions, 10) || 0;
      }),
      new LineParser(/^(\d+)[^,]*(?:,\s*(\d+)[^(]+\(([+-]))?/, (result, [changes, lines, direction]) => {
        result.summary.changes = parseInt(changes, 10) || 0;
        const count = parseInt(lines, 10) || 0;
        if (direction === "-") {
          result.summary.deletions = count;
        } else if (direction === "+") {
          result.summary.insertions = count;
        }
      })
    ];
  }
});
function commitTask(message, files, customArgs) {
  const commands = [
    "-c",
    "core.abbrev=40",
    "commit",
    ...prefixedArray(message, "-m"),
    ...files,
    ...customArgs
  ];
  return {
    commands,
    format: "utf-8",
    parser: parseCommitResult
  };
}
function commit_default() {
  return {
    commit(message, ...rest) {
      const next = trailingFunctionArgument(arguments);
      const task = rejectDeprecatedSignatures(message) || commitTask(asArray(message), asArray(filterType(rest[0], filterStringOrStringArray, [])), [...filterType(rest[1], filterArray, []), ...getTrailingOptions(arguments, 0, true)]);
      return this._runTask(task, next);
    }
  };
  function rejectDeprecatedSignatures(message) {
    return !filterStringOrStringArray(message) && configurationErrorTask(`git.commit: requires the commit message to be supplied as a string/string[]`);
  }
}
var init_commit = __esm({
  "src/lib/tasks/commit.ts"() {
    init_parse_commit();
    init_utils();
    init_task();
  }
});
function first_commit_default() {
  return {
    firstCommit() {
      return this._runTask(straightThroughStringTask(["rev-list", "--max-parents=0", "HEAD"], true), trailingFunctionArgument(arguments));
    }
  };
}
var init_first_commit = __esm({
  "src/lib/tasks/first-commit.ts"() {
    init_utils();
    init_task();
  }
});
function hashObjectTask(filePath, write) {
  const commands = ["hash-object", filePath];
  if (write) {
    commands.push("-w");
  }
  return straightThroughStringTask(commands, true);
}
var init_hash_object = __esm({
  "src/lib/tasks/hash-object.ts"() {
    init_task();
  }
});
function parseInit(bare, path, text) {
  const response = String(text).trim();
  let result;
  if (result = initResponseRegex.exec(response)) {
    return new InitSummary(bare, path, false, result[1]);
  }
  if (result = reInitResponseRegex.exec(response)) {
    return new InitSummary(bare, path, true, result[1]);
  }
  let gitDir = "";
  const tokens = response.split(" ");
  while (tokens.length) {
    const token = tokens.shift();
    if (token === "in") {
      gitDir = tokens.join(" ");
      break;
    }
  }
  return new InitSummary(bare, path, /^re/i.test(response), gitDir);
}
var InitSummary;
var initResponseRegex;
var reInitResponseRegex;
var init_InitSummary = __esm({
  "src/lib/responses/InitSummary.ts"() {
    InitSummary = class {
      constructor(bare, path, existing, gitDir) {
        this.bare = bare;
        this.path = path;
        this.existing = existing;
        this.gitDir = gitDir;
      }
    };
    initResponseRegex = /^Init.+ repository in (.+)$/;
    reInitResponseRegex = /^Rein.+ in (.+)$/;
  }
});
function hasBareCommand(command) {
  return command.includes(bareCommand);
}
function initTask(bare = false, path, customArgs) {
  const commands = ["init", ...customArgs];
  if (bare && !hasBareCommand(commands)) {
    commands.splice(1, 0, bareCommand);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return parseInit(commands.includes("--bare"), path, text);
    }
  };
}
var bareCommand;
var init_init = __esm({
  "src/lib/tasks/init.ts"() {
    init_InitSummary();
    bareCommand = "--bare";
  }
});
function logFormatFromCommand(customArgs) {
  for (let i = 0; i < customArgs.length; i++) {
    const format = logFormatRegex.exec(customArgs[i]);
    if (format) {
      return `--${format[1]}`;
    }
  }
  return "";
}
function isLogFormat(customArg) {
  return logFormatRegex.test(customArg);
}
var logFormatRegex;
var init_log_format = __esm({
  "src/lib/args/log-format.ts"() {
    logFormatRegex = /^--(stat|numstat|name-only|name-status)(=|$)/;
  }
});
var DiffSummary;
var init_DiffSummary = __esm({
  "src/lib/responses/DiffSummary.ts"() {
    DiffSummary = class {
      constructor() {
        this.changed = 0;
        this.deletions = 0;
        this.insertions = 0;
        this.files = [];
      }
    };
  }
});
function getDiffParser(format = "") {
  const parser3 = diffSummaryParsers[format];
  return (stdOut) => parseStringResponse(new DiffSummary(), parser3, stdOut, false);
}
var statParser;
var numStatParser;
var nameOnlyParser;
var nameStatusParser;
var diffSummaryParsers;
var init_parse_diff_summary = __esm({
  "src/lib/parsers/parse-diff-summary.ts"() {
    init_log_format();
    init_DiffSummary();
    init_diff_name_status();
    init_utils();
    statParser = [
      new LineParser(/(.+)\s+\|\s+(\d+)(\s+[+\-]+)?$/, (result, [file, changes, alterations = ""]) => {
        result.files.push({
          file: file.trim(),
          changes: asNumber(changes),
          insertions: alterations.replace(/[^+]/g, "").length,
          deletions: alterations.replace(/[^-]/g, "").length,
          binary: false
        });
      }),
      new LineParser(/(.+) \|\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/, (result, [file, before, after]) => {
        result.files.push({
          file: file.trim(),
          before: asNumber(before),
          after: asNumber(after),
          binary: true
        });
      }),
      new LineParser(/(\d+) files? changed\s*((?:, \d+ [^,]+){0,2})/, (result, [changed, summary]) => {
        const inserted = /(\d+) i/.exec(summary);
        const deleted = /(\d+) d/.exec(summary);
        result.changed = asNumber(changed);
        result.insertions = asNumber(inserted == null ? void 0 : inserted[1]);
        result.deletions = asNumber(deleted == null ? void 0 : deleted[1]);
      })
    ];
    numStatParser = [
      new LineParser(/(\d+)\t(\d+)\t(.+)$/, (result, [changesInsert, changesDelete, file]) => {
        const insertions = asNumber(changesInsert);
        const deletions = asNumber(changesDelete);
        result.changed++;
        result.insertions += insertions;
        result.deletions += deletions;
        result.files.push({
          file,
          changes: insertions + deletions,
          insertions,
          deletions,
          binary: false
        });
      }),
      new LineParser(/-\t-\t(.+)$/, (result, [file]) => {
        result.changed++;
        result.files.push({
          file,
          after: 0,
          before: 0,
          binary: true
        });
      })
    ];
    nameOnlyParser = [
      new LineParser(/(.+)$/, (result, [file]) => {
        result.changed++;
        result.files.push({
          file,
          changes: 0,
          insertions: 0,
          deletions: 0,
          binary: false
        });
      })
    ];
    nameStatusParser = [
      new LineParser(/([ACDMRTUXB])([0-9]{0,3})\t(.[^\t]*)(\t(.[^\t]*))?$/, (result, [status, _similarity, from, _to, to]) => {
        result.changed++;
        result.files.push({
          file: to != null ? to : from,
          changes: 0,
          status: orVoid(isDiffNameStatus(status) && status),
          insertions: 0,
          deletions: 0,
          binary: false
        });
      })
    ];
    diffSummaryParsers = {
      [
        ""
        /* NONE */
      ]: statParser,
      [
        "--stat"
        /* STAT */
      ]: statParser,
      [
        "--numstat"
        /* NUM_STAT */
      ]: numStatParser,
      [
        "--name-status"
        /* NAME_STATUS */
      ]: nameStatusParser,
      [
        "--name-only"
        /* NAME_ONLY */
      ]: nameOnlyParser
    };
  }
});
function lineBuilder(tokens, fields) {
  return fields.reduce((line, field, index) => {
    line[field] = tokens[index] || "";
    return line;
  }, /* @__PURE__ */ Object.create({ diff: null }));
}
function createListLogSummaryParser(splitter = SPLITTER, fields = defaultFieldNames, logFormat = "") {
  const parseDiffResult = getDiffParser(logFormat);
  return function(stdOut) {
    const all = toLinesWithContent(stdOut, true, START_BOUNDARY).map(function(item) {
      const lineDetail = item.trim().split(COMMIT_BOUNDARY);
      const listLogLine = lineBuilder(lineDetail[0].trim().split(splitter), fields);
      if (lineDetail.length > 1 && !!lineDetail[1].trim()) {
        listLogLine.diff = parseDiffResult(lineDetail[1]);
      }
      return listLogLine;
    });
    return {
      all,
      latest: all.length && all[0] || null,
      total: all.length
    };
  };
}
var START_BOUNDARY;
var COMMIT_BOUNDARY;
var SPLITTER;
var defaultFieldNames;
var init_parse_list_log_summary = __esm({
  "src/lib/parsers/parse-list-log-summary.ts"() {
    init_utils();
    init_parse_diff_summary();
    init_log_format();
    START_BOUNDARY = "\xF2\xF2\xF2\xF2\xF2\xF2 ";
    COMMIT_BOUNDARY = " \xF2\xF2";
    SPLITTER = " \xF2 ";
    defaultFieldNames = ["hash", "date", "message", "refs", "author_name", "author_email"];
  }
});
var diff_exports = {};
__export2(diff_exports, {
  diffSummaryTask: () => diffSummaryTask,
  validateLogFormatConfig: () => validateLogFormatConfig
});
function diffSummaryTask(customArgs) {
  let logFormat = logFormatFromCommand(customArgs);
  const commands = ["diff"];
  if (logFormat === "") {
    logFormat = "--stat";
    commands.push("--stat=4096");
  }
  commands.push(...customArgs);
  return validateLogFormatConfig(commands) || {
    commands,
    format: "utf-8",
    parser: getDiffParser(logFormat)
  };
}
function validateLogFormatConfig(customArgs) {
  const flags = customArgs.filter(isLogFormat);
  if (flags.length > 1) {
    return configurationErrorTask(`Summary flags are mutually exclusive - pick one of ${flags.join(",")}`);
  }
  if (flags.length && customArgs.includes("-z")) {
    return configurationErrorTask(`Summary flag ${flags} parsing is not compatible with null termination option '-z'`);
  }
}
var init_diff = __esm({
  "src/lib/tasks/diff.ts"() {
    init_log_format();
    init_parse_diff_summary();
    init_task();
  }
});
function prettyFormat(format, splitter) {
  const fields = [];
  const formatStr = [];
  Object.keys(format).forEach((field) => {
    fields.push(field);
    formatStr.push(String(format[field]));
  });
  return [fields, formatStr.join(splitter)];
}
function userOptions(input) {
  return Object.keys(input).reduce((out, key) => {
    if (!(key in excludeOptions)) {
      out[key] = input[key];
    }
    return out;
  }, {});
}
function parseLogOptions(opt = {}, customArgs = []) {
  const splitter = filterType(opt.splitter, filterString, SPLITTER);
  const format = !filterPrimitives(opt.format) && opt.format ? opt.format : {
    hash: "%H",
    date: opt.strictDate === false ? "%ai" : "%aI",
    message: "%s",
    refs: "%D",
    body: opt.multiLine ? "%B" : "%b",
    author_name: opt.mailMap !== false ? "%aN" : "%an",
    author_email: opt.mailMap !== false ? "%aE" : "%ae"
  };
  const [fields, formatStr] = prettyFormat(format, splitter);
  const suffix = [];
  const command = [
    `--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`,
    ...customArgs
  ];
  const maxCount = opt.n || opt["max-count"] || opt.maxCount;
  if (maxCount) {
    command.push(`--max-count=${maxCount}`);
  }
  if (opt.from || opt.to) {
    const rangeOperator = opt.symmetric !== false ? "..." : "..";
    suffix.push(`${opt.from || ""}${rangeOperator}${opt.to || ""}`);
  }
  if (filterString(opt.file)) {
    command.push("--follow", pathspec(opt.file));
  }
  appendTaskOptions(userOptions(opt), command);
  return {
    fields,
    splitter,
    commands: [...command, ...suffix]
  };
}
function logTask(splitter, fields, customArgs) {
  const parser3 = createListLogSummaryParser(splitter, fields, logFormatFromCommand(customArgs));
  return {
    commands: ["log", ...customArgs],
    format: "utf-8",
    parser: parser3
  };
}
function log_default() {
  return {
    log(...rest) {
      const next = trailingFunctionArgument(arguments);
      const options = parseLogOptions(trailingOptionsArgument(arguments), filterType(arguments[0], filterArray));
      const task = rejectDeprecatedSignatures(...rest) || validateLogFormatConfig(options.commands) || createLogTask(options);
      return this._runTask(task, next);
    }
  };
  function createLogTask(options) {
    return logTask(options.splitter, options.fields, options.commands);
  }
  function rejectDeprecatedSignatures(from, to) {
    return filterString(from) && filterString(to) && configurationErrorTask(`git.log(string, string) should be replaced with git.log({ from: string, to: string })`);
  }
}
var excludeOptions;
var init_log = __esm({
  "src/lib/tasks/log.ts"() {
    init_log_format();
    init_pathspec();
    init_parse_list_log_summary();
    init_utils();
    init_task();
    init_diff();
    excludeOptions = /* @__PURE__ */ ((excludeOptions2) => {
      excludeOptions2[excludeOptions2["--pretty"] = 0] = "--pretty";
      excludeOptions2[excludeOptions2["max-count"] = 1] = "max-count";
      excludeOptions2[excludeOptions2["maxCount"] = 2] = "maxCount";
      excludeOptions2[excludeOptions2["n"] = 3] = "n";
      excludeOptions2[excludeOptions2["file"] = 4] = "file";
      excludeOptions2[excludeOptions2["format"] = 5] = "format";
      excludeOptions2[excludeOptions2["from"] = 6] = "from";
      excludeOptions2[excludeOptions2["to"] = 7] = "to";
      excludeOptions2[excludeOptions2["splitter"] = 8] = "splitter";
      excludeOptions2[excludeOptions2["symmetric"] = 9] = "symmetric";
      excludeOptions2[excludeOptions2["mailMap"] = 10] = "mailMap";
      excludeOptions2[excludeOptions2["multiLine"] = 11] = "multiLine";
      excludeOptions2[excludeOptions2["strictDate"] = 12] = "strictDate";
      return excludeOptions2;
    })(excludeOptions || {});
  }
});
var MergeSummaryConflict;
var MergeSummaryDetail;
var init_MergeSummary = __esm({
  "src/lib/responses/MergeSummary.ts"() {
    MergeSummaryConflict = class {
      constructor(reason, file = null, meta) {
        this.reason = reason;
        this.file = file;
        this.meta = meta;
      }
      toString() {
        return `${this.file}:${this.reason}`;
      }
    };
    MergeSummaryDetail = class {
      constructor() {
        this.conflicts = [];
        this.merges = [];
        this.result = "success";
      }
      get failed() {
        return this.conflicts.length > 0;
      }
      get reason() {
        return this.result;
      }
      toString() {
        if (this.conflicts.length) {
          return `CONFLICTS: ${this.conflicts.join(", ")}`;
        }
        return "OK";
      }
    };
  }
});
var PullSummary;
var PullFailedSummary;
var init_PullSummary = __esm({
  "src/lib/responses/PullSummary.ts"() {
    PullSummary = class {
      constructor() {
        this.remoteMessages = {
          all: []
        };
        this.created = [];
        this.deleted = [];
        this.files = [];
        this.deletions = {};
        this.insertions = {};
        this.summary = {
          changes: 0,
          deletions: 0,
          insertions: 0
        };
      }
    };
    PullFailedSummary = class {
      constructor() {
        this.remote = "";
        this.hash = {
          local: "",
          remote: ""
        };
        this.branch = {
          local: "",
          remote: ""
        };
        this.message = "";
      }
      toString() {
        return this.message;
      }
    };
  }
});
function objectEnumerationResult(remoteMessages) {
  return remoteMessages.objects = remoteMessages.objects || {
    compressing: 0,
    counting: 0,
    enumerating: 0,
    packReused: 0,
    reused: { count: 0, delta: 0 },
    total: { count: 0, delta: 0 }
  };
}
function asObjectCount(source) {
  const count = /^\s*(\d+)/.exec(source);
  const delta = /delta (\d+)/i.exec(source);
  return {
    count: asNumber(count && count[1] || "0"),
    delta: asNumber(delta && delta[1] || "0")
  };
}
var remoteMessagesObjectParsers;
var init_parse_remote_objects = __esm({
  "src/lib/parsers/parse-remote-objects.ts"() {
    init_utils();
    remoteMessagesObjectParsers = [
      new RemoteLineParser(/^remote:\s*(enumerating|counting|compressing) objects: (\d+),/i, (result, [action, count]) => {
        const key = action.toLowerCase();
        const enumeration = objectEnumerationResult(result.remoteMessages);
        Object.assign(enumeration, { [key]: asNumber(count) });
      }),
      new RemoteLineParser(/^remote:\s*(enumerating|counting|compressing) objects: \d+% \(\d+\/(\d+)\),/i, (result, [action, count]) => {
        const key = action.toLowerCase();
        const enumeration = objectEnumerationResult(result.remoteMessages);
        Object.assign(enumeration, { [key]: asNumber(count) });
      }),
      new RemoteLineParser(/total ([^,]+), reused ([^,]+), pack-reused (\d+)/i, (result, [total, reused, packReused]) => {
        const objects = objectEnumerationResult(result.remoteMessages);
        objects.total = asObjectCount(total);
        objects.reused = asObjectCount(reused);
        objects.packReused = asNumber(packReused);
      })
    ];
  }
});
function parseRemoteMessages(_stdOut, stdErr) {
  return parseStringResponse({ remoteMessages: new RemoteMessageSummary() }, parsers2, stdErr);
}
var parsers2;
var RemoteMessageSummary;
var init_parse_remote_messages = __esm({
  "src/lib/parsers/parse-remote-messages.ts"() {
    init_utils();
    init_parse_remote_objects();
    parsers2 = [
      new RemoteLineParser(/^remote:\s*(.+)$/, (result, [text]) => {
        result.remoteMessages.all.push(text.trim());
        return false;
      }),
      ...remoteMessagesObjectParsers,
      new RemoteLineParser([/create a (?:pull|merge) request/i, /\s(https?:\/\/\S+)$/], (result, [pullRequestUrl]) => {
        result.remoteMessages.pullRequestUrl = pullRequestUrl;
      }),
      new RemoteLineParser([/found (\d+) vulnerabilities.+\(([^)]+)\)/i, /\s(https?:\/\/\S+)$/], (result, [count, summary, url]) => {
        result.remoteMessages.vulnerabilities = {
          count: asNumber(count),
          summary,
          url
        };
      })
    ];
    RemoteMessageSummary = class {
      constructor() {
        this.all = [];
      }
    };
  }
});
function parsePullErrorResult(stdOut, stdErr) {
  const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, [stdOut, stdErr]);
  return pullError.message && pullError;
}
var FILE_UPDATE_REGEX;
var SUMMARY_REGEX;
var ACTION_REGEX;
var parsers3;
var errorParsers;
var parsePullDetail;
var parsePullResult;
var init_parse_pull = __esm({
  "src/lib/parsers/parse-pull.ts"() {
    init_PullSummary();
    init_utils();
    init_parse_remote_messages();
    FILE_UPDATE_REGEX = /^\s*(.+?)\s+\|\s+\d+\s*(\+*)(-*)/;
    SUMMARY_REGEX = /(\d+)\D+((\d+)\D+\(\+\))?(\D+(\d+)\D+\(-\))?/;
    ACTION_REGEX = /^(create|delete) mode \d+ (.+)/;
    parsers3 = [
      new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {
        result.files.push(file);
        if (insertions) {
          result.insertions[file] = insertions.length;
        }
        if (deletions) {
          result.deletions[file] = deletions.length;
        }
      }),
      new LineParser(SUMMARY_REGEX, (result, [changes, , insertions, , deletions]) => {
        if (insertions !== void 0 || deletions !== void 0) {
          result.summary.changes = +changes || 0;
          result.summary.insertions = +insertions || 0;
          result.summary.deletions = +deletions || 0;
          return true;
        }
        return false;
      }),
      new LineParser(ACTION_REGEX, (result, [action, file]) => {
        append(result.files, file);
        append(action === "create" ? result.created : result.deleted, file);
      })
    ];
    errorParsers = [
      new LineParser(/^from\s(.+)$/i, (result, [remote]) => void (result.remote = remote)),
      new LineParser(/^fatal:\s(.+)$/, (result, [message]) => void (result.message = message)),
      new LineParser(/([a-z0-9]+)\.\.([a-z0-9]+)\s+(\S+)\s+->\s+(\S+)$/, (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {
        result.branch.local = branchLocal;
        result.hash.local = hashLocal;
        result.branch.remote = branchRemote;
        result.hash.remote = hashRemote;
      })
    ];
    parsePullDetail = (stdOut, stdErr) => {
      return parseStringResponse(new PullSummary(), parsers3, [stdOut, stdErr]);
    };
    parsePullResult = (stdOut, stdErr) => {
      return Object.assign(new PullSummary(), parsePullDetail(stdOut, stdErr), parseRemoteMessages(stdOut, stdErr));
    };
  }
});
var parsers4;
var parseMergeResult;
var parseMergeDetail;
var init_parse_merge = __esm({
  "src/lib/parsers/parse-merge.ts"() {
    init_MergeSummary();
    init_utils();
    init_parse_pull();
    parsers4 = [
      new LineParser(/^Auto-merging\s+(.+)$/, (summary, [autoMerge]) => {
        summary.merges.push(autoMerge);
      }),
      new LineParser(/^CONFLICT\s+\((.+)\): Merge conflict in (.+)$/, (summary, [reason, file]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, file));
      }),
      new LineParser(/^CONFLICT\s+\((.+\/delete)\): (.+) deleted in (.+) and/, (summary, [reason, file, deleteRef]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, file, { deleteRef }));
      }),
      new LineParser(/^CONFLICT\s+\((.+)\):/, (summary, [reason]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, null));
      }),
      new LineParser(/^Automatic merge failed;\s+(.+)$/, (summary, [result]) => {
        summary.result = result;
      })
    ];
    parseMergeResult = (stdOut, stdErr) => {
      return Object.assign(parseMergeDetail(stdOut, stdErr), parsePullResult(stdOut, stdErr));
    };
    parseMergeDetail = (stdOut) => {
      return parseStringResponse(new MergeSummaryDetail(), parsers4, stdOut);
    };
  }
});
function mergeTask(customArgs) {
  if (!customArgs.length) {
    return configurationErrorTask("Git.merge requires at least one option");
  }
  return {
    commands: ["merge", ...customArgs],
    format: "utf-8",
    parser(stdOut, stdErr) {
      const merge = parseMergeResult(stdOut, stdErr);
      if (merge.failed) {
        throw new GitResponseError(merge);
      }
      return merge;
    }
  };
}
var init_merge = __esm({
  "src/lib/tasks/merge.ts"() {
    init_git_response_error();
    init_parse_merge();
    init_task();
  }
});
function pushResultPushedItem(local, remote, status) {
  const deleted = status.includes("deleted");
  const tag = status.includes("tag") || /^refs\/tags/.test(local);
  const alreadyUpdated = !status.includes("new");
  return {
    deleted,
    tag,
    branch: !tag,
    new: !alreadyUpdated,
    alreadyUpdated,
    local,
    remote
  };
}
var parsers5;
var parsePushResult;
var parsePushDetail;
var init_parse_push = __esm({
  "src/lib/parsers/parse-push.ts"() {
    init_utils();
    init_parse_remote_messages();
    parsers5 = [
      new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {
        result.repo = repo;
      }),
      new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {
        result.ref = __spreadProps(__spreadValues({}, result.ref || {}), {
          local
        });
      }),
      new LineParser(/^[=*-]\s+([^:]+):(\S+)\s+\[(.+)]$/, (result, [local, remote, type]) => {
        result.pushed.push(pushResultPushedItem(local, remote, type));
      }),
      new LineParser(/^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/, (result, [local, remote, remoteName]) => {
        result.branch = __spreadProps(__spreadValues({}, result.branch || {}), {
          local,
          remote,
          remoteName
        });
      }),
      new LineParser(/^([^:]+):(\S+)\s+([a-z0-9]+)\.\.([a-z0-9]+)$/, (result, [local, remote, from, to]) => {
        result.update = {
          head: {
            local,
            remote
          },
          hash: {
            from,
            to
          }
        };
      })
    ];
    parsePushResult = (stdOut, stdErr) => {
      const pushDetail = parsePushDetail(stdOut, stdErr);
      const responseDetail = parseRemoteMessages(stdOut, stdErr);
      return __spreadValues(__spreadValues({}, pushDetail), responseDetail);
    };
    parsePushDetail = (stdOut, stdErr) => {
      return parseStringResponse({ pushed: [] }, parsers5, [stdOut, stdErr]);
    };
  }
});
var push_exports = {};
__export2(push_exports, {
  pushTagsTask: () => pushTagsTask,
  pushTask: () => pushTask
});
function pushTagsTask(ref = {}, customArgs) {
  append(customArgs, "--tags");
  return pushTask(ref, customArgs);
}
function pushTask(ref = {}, customArgs) {
  const commands = ["push", ...customArgs];
  if (ref.branch) {
    commands.splice(1, 0, ref.branch);
  }
  if (ref.remote) {
    commands.splice(1, 0, ref.remote);
  }
  remove(commands, "-v");
  append(commands, "--verbose");
  append(commands, "--porcelain");
  return {
    commands,
    format: "utf-8",
    parser: parsePushResult
  };
}
var init_push = __esm({
  "src/lib/tasks/push.ts"() {
    init_parse_push();
    init_utils();
  }
});
function show_default() {
  return {
    showBuffer() {
      const commands = ["show", ...getTrailingOptions(arguments, 1)];
      if (!commands.includes("--binary")) {
        commands.splice(1, 0, "--binary");
      }
      return this._runTask(straightThroughBufferTask(commands), trailingFunctionArgument(arguments));
    },
    show() {
      const commands = ["show", ...getTrailingOptions(arguments, 1)];
      return this._runTask(straightThroughStringTask(commands), trailingFunctionArgument(arguments));
    }
  };
}
var init_show = __esm({
  "src/lib/tasks/show.ts"() {
    init_utils();
    init_task();
  }
});
var fromPathRegex;
var FileStatusSummary;
var init_FileStatusSummary = __esm({
  "src/lib/responses/FileStatusSummary.ts"() {
    fromPathRegex = /^(.+) -> (.+)$/;
    FileStatusSummary = class {
      constructor(path, index, working_dir) {
        this.path = path;
        this.index = index;
        this.working_dir = working_dir;
        if (index + working_dir === "R") {
          const detail = fromPathRegex.exec(path) || [null, path, path];
          this.from = detail[1] || "";
          this.path = detail[2] || "";
        }
      }
    };
  }
});
function renamedFile(line) {
  const [to, from] = line.split(NULL);
  return {
    from: from || to,
    to
  };
}
function parser2(indexX, indexY, handler) {
  return [`${indexX}${indexY}`, handler];
}
function conflicts(indexX, ...indexY) {
  return indexY.map((y) => parser2(indexX, y, (result, file) => append(result.conflicted, file)));
}
function splitLine(result, lineStr) {
  const trimmed2 = lineStr.trim();
  switch (" ") {
    case trimmed2.charAt(2):
      return data(trimmed2.charAt(0), trimmed2.charAt(1), trimmed2.substr(3));
    case trimmed2.charAt(1):
      return data(" ", trimmed2.charAt(0), trimmed2.substr(2));
    default:
      return;
  }
  function data(index, workingDir, path) {
    const raw = `${index}${workingDir}`;
    const handler = parsers6.get(raw);
    if (handler) {
      handler(result, path);
    }
    if (raw !== "##" && raw !== "!!") {
      result.files.push(new FileStatusSummary(path.replace(/\0.+$/, ""), index, workingDir));
    }
  }
}
var StatusSummary;
var parsers6;
var parseStatusSummary;
var init_StatusSummary = __esm({
  "src/lib/responses/StatusSummary.ts"() {
    init_utils();
    init_FileStatusSummary();
    StatusSummary = class {
      constructor() {
        this.not_added = [];
        this.conflicted = [];
        this.created = [];
        this.deleted = [];
        this.ignored = void 0;
        this.modified = [];
        this.renamed = [];
        this.files = [];
        this.staged = [];
        this.ahead = 0;
        this.behind = 0;
        this.current = null;
        this.tracking = null;
        this.detached = false;
        this.isClean = () => {
          return !this.files.length;
        };
      }
    };
    parsers6 = new Map([
      parser2(" ", "A", (result, file) => append(result.created, file)),
      parser2(" ", "D", (result, file) => append(result.deleted, file)),
      parser2(" ", "M", (result, file) => append(result.modified, file)),
      parser2("A", " ", (result, file) => append(result.created, file) && append(result.staged, file)),
      parser2("A", "M", (result, file) => append(result.created, file) && append(result.staged, file) && append(result.modified, file)),
      parser2("D", " ", (result, file) => append(result.deleted, file) && append(result.staged, file)),
      parser2("M", " ", (result, file) => append(result.modified, file) && append(result.staged, file)),
      parser2("M", "M", (result, file) => append(result.modified, file) && append(result.staged, file)),
      parser2("R", " ", (result, file) => {
        append(result.renamed, renamedFile(file));
      }),
      parser2("R", "M", (result, file) => {
        const renamed = renamedFile(file);
        append(result.renamed, renamed);
        append(result.modified, renamed.to);
      }),
      parser2("!", "!", (_result, _file) => {
        append(_result.ignored = _result.ignored || [], _file);
      }),
      parser2("?", "?", (result, file) => append(result.not_added, file)),
      ...conflicts(
        "A",
        "A",
        "U"
        /* UNMERGED */
      ),
      ...conflicts(
        "D",
        "D",
        "U"
        /* UNMERGED */
      ),
      ...conflicts(
        "U",
        "A",
        "D",
        "U"
        /* UNMERGED */
      ),
      [
        "##",
        (result, line) => {
          const aheadReg = /ahead (\d+)/;
          const behindReg = /behind (\d+)/;
          const currentReg = /^(.+?(?=(?:\.{3}|\s|$)))/;
          const trackingReg = /\.{3}(\S*)/;
          const onEmptyBranchReg = /\son\s([\S]+)$/;
          let regexResult;
          regexResult = aheadReg.exec(line);
          result.ahead = regexResult && +regexResult[1] || 0;
          regexResult = behindReg.exec(line);
          result.behind = regexResult && +regexResult[1] || 0;
          regexResult = currentReg.exec(line);
          result.current = regexResult && regexResult[1];
          regexResult = trackingReg.exec(line);
          result.tracking = regexResult && regexResult[1];
          regexResult = onEmptyBranchReg.exec(line);
          result.current = regexResult && regexResult[1] || result.current;
          result.detached = /\(no branch\)/.test(line);
        }
      ]
    ]);
    parseStatusSummary = function(text) {
      const lines = text.split(NULL);
      const status = new StatusSummary();
      for (let i = 0, l = lines.length; i < l; ) {
        let line = lines[i++].trim();
        if (!line) {
          continue;
        }
        if (line.charAt(0) === "R") {
          line += NULL + (lines[i++] || "");
        }
        splitLine(status, line);
      }
      return status;
    };
  }
});
function statusTask(customArgs) {
  const commands = [
    "status",
    "--porcelain",
    "-b",
    "-u",
    "--null",
    ...customArgs.filter((arg) => !ignoredOptions.includes(arg))
  ];
  return {
    format: "utf-8",
    commands,
    parser(text) {
      return parseStatusSummary(text);
    }
  };
}
var ignoredOptions;
var init_status = __esm({
  "src/lib/tasks/status.ts"() {
    init_StatusSummary();
    ignoredOptions = ["--null", "-z"];
  }
});
function versionResponse(major = 0, minor = 0, patch = 0, agent = "", installed = true) {
  return Object.defineProperty({
    major,
    minor,
    patch,
    agent,
    installed
  }, "toString", {
    value() {
      return `${this.major}.${this.minor}.${this.patch}`;
    },
    configurable: false,
    enumerable: false
  });
}
function notInstalledResponse() {
  return versionResponse(0, 0, 0, "", false);
}
function version_default() {
  return {
    version() {
      return this._runTask({
        commands: ["--version"],
        format: "utf-8",
        parser: versionParser,
        onError(result, error, done, fail) {
          if (result.exitCode === -2) {
            return done(Buffer.from(NOT_INSTALLED));
          }
          fail(error);
        }
      });
    }
  };
}
function versionParser(stdOut) {
  if (stdOut === NOT_INSTALLED) {
    return notInstalledResponse();
  }
  return parseStringResponse(versionResponse(0, 0, 0, stdOut), parsers7, stdOut);
}
var NOT_INSTALLED;
var parsers7;
var init_version = __esm({
  "src/lib/tasks/version.ts"() {
    init_utils();
    NOT_INSTALLED = "installed=false";
    parsers7 = [
      new LineParser(/version (\d+)\.(\d+)\.(\d+)(?:\s*\((.+)\))?/, (result, [major, minor, patch, agent = ""]) => {
        Object.assign(result, versionResponse(asNumber(major), asNumber(minor), asNumber(patch), agent));
      }),
      new LineParser(/version (\d+)\.(\d+)\.(\D+)(.+)?$/, (result, [major, minor, patch, agent = ""]) => {
        Object.assign(result, versionResponse(asNumber(major), asNumber(minor), patch, agent));
      })
    ];
  }
});
var simple_git_api_exports = {};
__export2(simple_git_api_exports, {
  SimpleGitApi: () => SimpleGitApi
});
var SimpleGitApi;
var init_simple_git_api = __esm({
  "src/lib/simple-git-api.ts"() {
    init_task_callback();
    init_change_working_directory();
    init_checkout();
    init_commit();
    init_config();
    init_first_commit();
    init_grep();
    init_hash_object();
    init_init();
    init_log();
    init_merge();
    init_push();
    init_show();
    init_status();
    init_task();
    init_version();
    init_utils();
    SimpleGitApi = class {
      constructor(_executor) {
        this._executor = _executor;
      }
      _runTask(task, then) {
        const chain = this._executor.chain();
        const promise = chain.push(task);
        if (then) {
          taskCallback(task, promise, then);
        }
        return Object.create(this, {
          then: { value: promise.then.bind(promise) },
          catch: { value: promise.catch.bind(promise) },
          _executor: { value: chain }
        });
      }
      add(files) {
        return this._runTask(straightThroughStringTask(["add", ...asArray(files)]), trailingFunctionArgument(arguments));
      }
      cwd(directory) {
        const next = trailingFunctionArgument(arguments);
        if (typeof directory === "string") {
          return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next);
        }
        if (typeof (directory == null ? void 0 : directory.path) === "string") {
          return this._runTask(changeWorkingDirectoryTask(directory.path, directory.root && this._executor || void 0), next);
        }
        return this._runTask(configurationErrorTask("Git.cwd: workingDirectory must be supplied as a string"), next);
      }
      hashObject(path, write) {
        return this._runTask(hashObjectTask(path, write === true), trailingFunctionArgument(arguments));
      }
      init(bare) {
        return this._runTask(initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
      }
      merge() {
        return this._runTask(mergeTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
      }
      mergeFromTo(remote, branch) {
        if (!(filterString(remote) && filterString(branch))) {
          return this._runTask(configurationErrorTask(`Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`));
        }
        return this._runTask(mergeTask([remote, branch, ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments, false));
      }
      outputHandler(handler) {
        this._executor.outputHandler = handler;
        return this;
      }
      push() {
        const task = pushTask({
          remote: filterType(arguments[0], filterString),
          branch: filterType(arguments[1], filterString)
        }, getTrailingOptions(arguments));
        return this._runTask(task, trailingFunctionArgument(arguments));
      }
      stash() {
        return this._runTask(straightThroughStringTask(["stash", ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments));
      }
      status() {
        return this._runTask(statusTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
      }
    };
    Object.assign(SimpleGitApi.prototype, checkout_default(), commit_default(), config_default(), first_commit_default(), grep_default(), log_default(), show_default(), version_default());
  }
});
var scheduler_exports = {};
__export2(scheduler_exports, {
  Scheduler: () => Scheduler
});
var createScheduledTask;
var Scheduler;
var init_scheduler = __esm({
  "src/lib/runners/scheduler.ts"() {
    init_utils();
    init_git_logger();
    createScheduledTask = (() => {
      let id = 0;
      return () => {
        id++;
        const { promise, done } = (0, import_promise_deferred.createDeferred)();
        return {
          promise,
          done,
          id
        };
      };
    })();
    Scheduler = class {
      constructor(concurrency = 2) {
        this.concurrency = concurrency;
        this.logger = createLogger("", "scheduler");
        this.pending = [];
        this.running = [];
        this.logger(`Constructed, concurrency=%s`, concurrency);
      }
      schedule() {
        if (!this.pending.length || this.running.length >= this.concurrency) {
          this.logger(`Schedule attempt ignored, pending=%s running=%s concurrency=%s`, this.pending.length, this.running.length, this.concurrency);
          return;
        }
        const task = append(this.running, this.pending.shift());
        this.logger(`Attempting id=%s`, task.id);
        task.done(() => {
          this.logger(`Completing id=`, task.id);
          remove(this.running, task);
          this.schedule();
        });
      }
      next() {
        const { promise, id } = append(this.pending, createScheduledTask());
        this.logger(`Scheduling id=%s`, id);
        this.schedule();
        return promise;
      }
    };
  }
});
var apply_patch_exports = {};
__export2(apply_patch_exports, {
  applyPatchTask: () => applyPatchTask
});
function applyPatchTask(patches, customArgs) {
  return straightThroughStringTask(["apply", ...customArgs, ...patches]);
}
var init_apply_patch = __esm({
  "src/lib/tasks/apply-patch.ts"() {
    init_task();
  }
});
function branchDeletionSuccess(branch, hash) {
  return {
    branch,
    hash,
    success: true
  };
}
function branchDeletionFailure(branch) {
  return {
    branch,
    hash: null,
    success: false
  };
}
var BranchDeletionBatch;
var init_BranchDeleteSummary = __esm({
  "src/lib/responses/BranchDeleteSummary.ts"() {
    BranchDeletionBatch = class {
      constructor() {
        this.all = [];
        this.branches = {};
        this.errors = [];
      }
      get success() {
        return !this.errors.length;
      }
    };
  }
});
function hasBranchDeletionError(data, processExitCode) {
  return processExitCode === 1 && deleteErrorRegex.test(data);
}
var deleteSuccessRegex;
var deleteErrorRegex;
var parsers8;
var parseBranchDeletions;
var init_parse_branch_delete = __esm({
  "src/lib/parsers/parse-branch-delete.ts"() {
    init_BranchDeleteSummary();
    init_utils();
    deleteSuccessRegex = /(\S+)\s+\(\S+\s([^)]+)\)/;
    deleteErrorRegex = /^error[^']+'([^']+)'/m;
    parsers8 = [
      new LineParser(deleteSuccessRegex, (result, [branch, hash]) => {
        const deletion = branchDeletionSuccess(branch, hash);
        result.all.push(deletion);
        result.branches[branch] = deletion;
      }),
      new LineParser(deleteErrorRegex, (result, [branch]) => {
        const deletion = branchDeletionFailure(branch);
        result.errors.push(deletion);
        result.all.push(deletion);
        result.branches[branch] = deletion;
      })
    ];
    parseBranchDeletions = (stdOut, stdErr) => {
      return parseStringResponse(new BranchDeletionBatch(), parsers8, [stdOut, stdErr]);
    };
  }
});
var BranchSummaryResult;
var init_BranchSummary = __esm({
  "src/lib/responses/BranchSummary.ts"() {
    BranchSummaryResult = class {
      constructor() {
        this.all = [];
        this.branches = {};
        this.current = "";
        this.detached = false;
      }
      push(status, detached, name, commit, label) {
        if (status === "*") {
          this.detached = detached;
          this.current = name;
        }
        this.all.push(name);
        this.branches[name] = {
          current: status === "*",
          linkedWorkTree: status === "+",
          name,
          commit,
          label
        };
      }
    };
  }
});
function branchStatus(input) {
  return input ? input.charAt(0) : "";
}
function parseBranchSummary(stdOut) {
  return parseStringResponse(new BranchSummaryResult(), parsers9, stdOut);
}
var parsers9;
var init_parse_branch = __esm({
  "src/lib/parsers/parse-branch.ts"() {
    init_BranchSummary();
    init_utils();
    parsers9 = [
      new LineParser(/^([*+]\s)?\((?:HEAD )?detached (?:from|at) (\S+)\)\s+([a-z0-9]+)\s(.*)$/, (result, [current, name, commit, label]) => {
        result.push(branchStatus(current), true, name, commit, label);
      }),
      new LineParser(/^([*+]\s)?(\S+)\s+([a-z0-9]+)\s?(.*)$/s, (result, [current, name, commit, label]) => {
        result.push(branchStatus(current), false, name, commit, label);
      })
    ];
  }
});
var branch_exports = {};
__export2(branch_exports, {
  branchLocalTask: () => branchLocalTask,
  branchTask: () => branchTask,
  containsDeleteBranchCommand: () => containsDeleteBranchCommand,
  deleteBranchTask: () => deleteBranchTask,
  deleteBranchesTask: () => deleteBranchesTask
});
function containsDeleteBranchCommand(commands) {
  const deleteCommands = ["-d", "-D", "--delete"];
  return commands.some((command) => deleteCommands.includes(command));
}
function branchTask(customArgs) {
  const isDelete = containsDeleteBranchCommand(customArgs);
  const commands = ["branch", ...customArgs];
  if (commands.length === 1) {
    commands.push("-a");
  }
  if (!commands.includes("-v")) {
    commands.splice(1, 0, "-v");
  }
  return {
    format: "utf-8",
    commands,
    parser(stdOut, stdErr) {
      if (isDelete) {
        return parseBranchDeletions(stdOut, stdErr).all[0];
      }
      return parseBranchSummary(stdOut);
    }
  };
}
function branchLocalTask() {
  const parser3 = parseBranchSummary;
  return {
    format: "utf-8",
    commands: ["branch", "-v"],
    parser: parser3
  };
}
function deleteBranchesTask(branches, forceDelete = false) {
  return {
    format: "utf-8",
    commands: ["branch", "-v", forceDelete ? "-D" : "-d", ...branches],
    parser(stdOut, stdErr) {
      return parseBranchDeletions(stdOut, stdErr);
    },
    onError({ exitCode, stdOut }, error, done, fail) {
      if (!hasBranchDeletionError(String(error), exitCode)) {
        return fail(error);
      }
      done(stdOut);
    }
  };
}
function deleteBranchTask(branch, forceDelete = false) {
  const task = {
    format: "utf-8",
    commands: ["branch", "-v", forceDelete ? "-D" : "-d", branch],
    parser(stdOut, stdErr) {
      return parseBranchDeletions(stdOut, stdErr).branches[branch];
    },
    onError({ exitCode, stdErr, stdOut }, error, _, fail) {
      if (!hasBranchDeletionError(String(error), exitCode)) {
        return fail(error);
      }
      throw new GitResponseError(task.parser(bufferToString(stdOut), bufferToString(stdErr)), String(error));
    }
  };
  return task;
}
var init_branch = __esm({
  "src/lib/tasks/branch.ts"() {
    init_git_response_error();
    init_parse_branch_delete();
    init_parse_branch();
    init_utils();
  }
});
var parseCheckIgnore;
var init_CheckIgnore = __esm({
  "src/lib/responses/CheckIgnore.ts"() {
    parseCheckIgnore = (text) => {
      return text.split(/\n/g).map((line) => line.trim()).filter((file) => !!file);
    };
  }
});
var check_ignore_exports = {};
__export2(check_ignore_exports, {
  checkIgnoreTask: () => checkIgnoreTask
});
function checkIgnoreTask(paths) {
  return {
    commands: ["check-ignore", ...paths],
    format: "utf-8",
    parser: parseCheckIgnore
  };
}
var init_check_ignore = __esm({
  "src/lib/tasks/check-ignore.ts"() {
    init_CheckIgnore();
  }
});
var clone_exports = {};
__export2(clone_exports, {
  cloneMirrorTask: () => cloneMirrorTask,
  cloneTask: () => cloneTask
});
function disallowedCommand(command) {
  return /^--upload-pack(=|$)/.test(command);
}
function cloneTask(repo, directory, customArgs) {
  const commands = ["clone", ...customArgs];
  filterString(repo) && commands.push(repo);
  filterString(directory) && commands.push(directory);
  const banned = commands.find(disallowedCommand);
  if (banned) {
    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);
  }
  return straightThroughStringTask(commands);
}
function cloneMirrorTask(repo, directory, customArgs) {
  append(customArgs, "--mirror");
  return cloneTask(repo, directory, customArgs);
}
var init_clone = __esm({
  "src/lib/tasks/clone.ts"() {
    init_task();
    init_utils();
  }
});
function parseFetchResult(stdOut, stdErr) {
  const result = {
    raw: stdOut,
    remote: null,
    branches: [],
    tags: [],
    updated: [],
    deleted: []
  };
  return parseStringResponse(result, parsers10, [stdOut, stdErr]);
}
var parsers10;
var init_parse_fetch = __esm({
  "src/lib/parsers/parse-fetch.ts"() {
    init_utils();
    parsers10 = [
      new LineParser(/From (.+)$/, (result, [remote]) => {
        result.remote = remote;
      }),
      new LineParser(/\* \[new branch]\s+(\S+)\s*-> (.+)$/, (result, [name, tracking]) => {
        result.branches.push({
          name,
          tracking
        });
      }),
      new LineParser(/\* \[new tag]\s+(\S+)\s*-> (.+)$/, (result, [name, tracking]) => {
        result.tags.push({
          name,
          tracking
        });
      }),
      new LineParser(/- \[deleted]\s+\S+\s*-> (.+)$/, (result, [tracking]) => {
        result.deleted.push({
          tracking
        });
      }),
      new LineParser(/\s*([^.]+)\.\.(\S+)\s+(\S+)\s*-> (.+)$/, (result, [from, to, name, tracking]) => {
        result.updated.push({
          name,
          tracking,
          to,
          from
        });
      })
    ];
  }
});
var fetch_exports = {};
__export2(fetch_exports, {
  fetchTask: () => fetchTask
});
function disallowedCommand2(command) {
  return /^--upload-pack(=|$)/.test(command);
}
function fetchTask(remote, branch, customArgs) {
  const commands = ["fetch", ...customArgs];
  if (remote && branch) {
    commands.push(remote, branch);
  }
  const banned = commands.find(disallowedCommand2);
  if (banned) {
    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);
  }
  return {
    commands,
    format: "utf-8",
    parser: parseFetchResult
  };
}
var init_fetch = __esm({
  "src/lib/tasks/fetch.ts"() {
    init_parse_fetch();
    init_task();
  }
});
function parseMoveResult(stdOut) {
  return parseStringResponse({ moves: [] }, parsers11, stdOut);
}
var parsers11;
var init_parse_move = __esm({
  "src/lib/parsers/parse-move.ts"() {
    init_utils();
    parsers11 = [
      new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {
        result.moves.push({ from, to });
      })
    ];
  }
});
var move_exports = {};
__export2(move_exports, {
  moveTask: () => moveTask
});
function moveTask(from, to) {
  return {
    commands: ["mv", "-v", ...asArray(from), to],
    format: "utf-8",
    parser: parseMoveResult
  };
}
var init_move = __esm({
  "src/lib/tasks/move.ts"() {
    init_parse_move();
    init_utils();
  }
});
var pull_exports = {};
__export2(pull_exports, {
  pullTask: () => pullTask
});
function pullTask(remote, branch, customArgs) {
  const commands = ["pull", ...customArgs];
  if (remote && branch) {
    commands.splice(1, 0, remote, branch);
  }
  return {
    commands,
    format: "utf-8",
    parser(stdOut, stdErr) {
      return parsePullResult(stdOut, stdErr);
    },
    onError(result, _error, _done, fail) {
      const pullError = parsePullErrorResult(bufferToString(result.stdOut), bufferToString(result.stdErr));
      if (pullError) {
        return fail(new GitResponseError(pullError));
      }
      fail(_error);
    }
  };
}
var init_pull = __esm({
  "src/lib/tasks/pull.ts"() {
    init_git_response_error();
    init_parse_pull();
    init_utils();
  }
});
function parseGetRemotes(text) {
  const remotes = {};
  forEach(text, ([name]) => remotes[name] = { name });
  return Object.values(remotes);
}
function parseGetRemotesVerbose(text) {
  const remotes = {};
  forEach(text, ([name, url, purpose]) => {
    if (!remotes.hasOwnProperty(name)) {
      remotes[name] = {
        name,
        refs: { fetch: "", push: "" }
      };
    }
    if (purpose && url) {
      remotes[name].refs[purpose.replace(/[^a-z]/g, "")] = url;
    }
  });
  return Object.values(remotes);
}
function forEach(text, handler) {
  forEachLineWithContent(text, (line) => handler(line.split(/\s+/)));
}
var init_GetRemoteSummary = __esm({
  "src/lib/responses/GetRemoteSummary.ts"() {
    init_utils();
  }
});
var remote_exports = {};
__export2(remote_exports, {
  addRemoteTask: () => addRemoteTask,
  getRemotesTask: () => getRemotesTask,
  listRemotesTask: () => listRemotesTask,
  remoteTask: () => remoteTask,
  removeRemoteTask: () => removeRemoteTask
});
function addRemoteTask(remoteName, remoteRepo, customArgs = []) {
  return straightThroughStringTask(["remote", "add", ...customArgs, remoteName, remoteRepo]);
}
function getRemotesTask(verbose) {
  const commands = ["remote"];
  if (verbose) {
    commands.push("-v");
  }
  return {
    commands,
    format: "utf-8",
    parser: verbose ? parseGetRemotesVerbose : parseGetRemotes
  };
}
function listRemotesTask(customArgs = []) {
  const commands = [...customArgs];
  if (commands[0] !== "ls-remote") {
    commands.unshift("ls-remote");
  }
  return straightThroughStringTask(commands);
}
function remoteTask(customArgs = []) {
  const commands = [...customArgs];
  if (commands[0] !== "remote") {
    commands.unshift("remote");
  }
  return straightThroughStringTask(commands);
}
function removeRemoteTask(remoteName) {
  return straightThroughStringTask(["remote", "remove", remoteName]);
}
var init_remote = __esm({
  "src/lib/tasks/remote.ts"() {
    init_GetRemoteSummary();
    init_task();
  }
});
var stash_list_exports = {};
__export2(stash_list_exports, {
  stashListTask: () => stashListTask
});
function stashListTask(opt = {}, customArgs) {
  const options = parseLogOptions(opt);
  const commands = ["stash", "list", ...options.commands, ...customArgs];
  const parser3 = createListLogSummaryParser(options.splitter, options.fields, logFormatFromCommand(commands));
  return validateLogFormatConfig(commands) || {
    commands,
    format: "utf-8",
    parser: parser3
  };
}
var init_stash_list = __esm({
  "src/lib/tasks/stash-list.ts"() {
    init_log_format();
    init_parse_list_log_summary();
    init_diff();
    init_log();
  }
});
var sub_module_exports = {};
__export2(sub_module_exports, {
  addSubModuleTask: () => addSubModuleTask,
  initSubModuleTask: () => initSubModuleTask,
  subModuleTask: () => subModuleTask,
  updateSubModuleTask: () => updateSubModuleTask
});
function addSubModuleTask(repo, path) {
  return subModuleTask(["add", repo, path]);
}
function initSubModuleTask(customArgs) {
  return subModuleTask(["init", ...customArgs]);
}
function subModuleTask(customArgs) {
  const commands = [...customArgs];
  if (commands[0] !== "submodule") {
    commands.unshift("submodule");
  }
  return straightThroughStringTask(commands);
}
function updateSubModuleTask(customArgs) {
  return subModuleTask(["update", ...customArgs]);
}
var init_sub_module = __esm({
  "src/lib/tasks/sub-module.ts"() {
    init_task();
  }
});
function singleSorted(a, b) {
  const aIsNum = isNaN(a);
  const bIsNum = isNaN(b);
  if (aIsNum !== bIsNum) {
    return aIsNum ? 1 : -1;
  }
  return aIsNum ? sorted(a, b) : 0;
}
function sorted(a, b) {
  return a === b ? 0 : a > b ? 1 : -1;
}
function trimmed(input) {
  return input.trim();
}
function toNumber(input) {
  if (typeof input === "string") {
    return parseInt(input.replace(/^\D+/g, ""), 10) || 0;
  }
  return 0;
}
var TagList;
var parseTagList;
var init_TagList = __esm({
  "src/lib/responses/TagList.ts"() {
    TagList = class {
      constructor(all, latest) {
        this.all = all;
        this.latest = latest;
      }
    };
    parseTagList = function(data, customSort = false) {
      const tags = data.split("\n").map(trimmed).filter(Boolean);
      if (!customSort) {
        tags.sort(function(tagA, tagB) {
          const partsA = tagA.split(".");
          const partsB = tagB.split(".");
          if (partsA.length === 1 || partsB.length === 1) {
            return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));
          }
          for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {
            const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));
            if (diff) {
              return diff;
            }
          }
          return 0;
        });
      }
      const latest = customSort ? tags[0] : [...tags].reverse().find((tag) => tag.indexOf(".") >= 0);
      return new TagList(tags, latest);
    };
  }
});
var tag_exports = {};
__export2(tag_exports, {
  addAnnotatedTagTask: () => addAnnotatedTagTask,
  addTagTask: () => addTagTask,
  tagListTask: () => tagListTask
});
function tagListTask(customArgs = []) {
  const hasCustomSort = customArgs.some((option) => /^--sort=/.test(option));
  return {
    format: "utf-8",
    commands: ["tag", "-l", ...customArgs],
    parser(text) {
      return parseTagList(text, hasCustomSort);
    }
  };
}
function addTagTask(name) {
  return {
    format: "utf-8",
    commands: ["tag", name],
    parser() {
      return { name };
    }
  };
}
function addAnnotatedTagTask(name, tagMessage) {
  return {
    format: "utf-8",
    commands: ["tag", "-a", "-m", tagMessage, name],
    parser() {
      return { name };
    }
  };
}
var init_tag = __esm({
  "src/lib/tasks/tag.ts"() {
    init_TagList();
  }
});
var require_git = __commonJS2({
  "src/git.js"(exports, module2) {
    var { GitExecutor: GitExecutor2 } = (init_git_executor(), __toCommonJS2(git_executor_exports));
    var { SimpleGitApi: SimpleGitApi2 } = (init_simple_git_api(), __toCommonJS2(simple_git_api_exports));
    var { Scheduler: Scheduler2 } = (init_scheduler(), __toCommonJS2(scheduler_exports));
    var { configurationErrorTask: configurationErrorTask2 } = (init_task(), __toCommonJS2(task_exports));
    var {
      asArray: asArray2,
      filterArray: filterArray2,
      filterPrimitives: filterPrimitives2,
      filterString: filterString2,
      filterStringOrStringArray: filterStringOrStringArray2,
      filterType: filterType2,
      getTrailingOptions: getTrailingOptions2,
      trailingFunctionArgument: trailingFunctionArgument2,
      trailingOptionsArgument: trailingOptionsArgument2
    } = (init_utils(), __toCommonJS2(utils_exports));
    var { applyPatchTask: applyPatchTask2 } = (init_apply_patch(), __toCommonJS2(apply_patch_exports));
    var {
      branchTask: branchTask2,
      branchLocalTask: branchLocalTask2,
      deleteBranchesTask: deleteBranchesTask2,
      deleteBranchTask: deleteBranchTask2
    } = (init_branch(), __toCommonJS2(branch_exports));
    var { checkIgnoreTask: checkIgnoreTask2 } = (init_check_ignore(), __toCommonJS2(check_ignore_exports));
    var { checkIsRepoTask: checkIsRepoTask2 } = (init_check_is_repo(), __toCommonJS2(check_is_repo_exports));
    var { cloneTask: cloneTask2, cloneMirrorTask: cloneMirrorTask2 } = (init_clone(), __toCommonJS2(clone_exports));
    var { cleanWithOptionsTask: cleanWithOptionsTask2, isCleanOptionsArray: isCleanOptionsArray2 } = (init_clean(), __toCommonJS2(clean_exports));
    var { diffSummaryTask: diffSummaryTask2 } = (init_diff(), __toCommonJS2(diff_exports));
    var { fetchTask: fetchTask2 } = (init_fetch(), __toCommonJS2(fetch_exports));
    var { moveTask: moveTask2 } = (init_move(), __toCommonJS2(move_exports));
    var { pullTask: pullTask2 } = (init_pull(), __toCommonJS2(pull_exports));
    var { pushTagsTask: pushTagsTask2 } = (init_push(), __toCommonJS2(push_exports));
    var {
      addRemoteTask: addRemoteTask2,
      getRemotesTask: getRemotesTask2,
      listRemotesTask: listRemotesTask2,
      remoteTask: remoteTask2,
      removeRemoteTask: removeRemoteTask2
    } = (init_remote(), __toCommonJS2(remote_exports));
    var { getResetMode: getResetMode2, resetTask: resetTask2 } = (init_reset(), __toCommonJS2(reset_exports));
    var { stashListTask: stashListTask2 } = (init_stash_list(), __toCommonJS2(stash_list_exports));
    var {
      addSubModuleTask: addSubModuleTask2,
      initSubModuleTask: initSubModuleTask2,
      subModuleTask: subModuleTask2,
      updateSubModuleTask: updateSubModuleTask2
    } = (init_sub_module(), __toCommonJS2(sub_module_exports));
    var { addAnnotatedTagTask: addAnnotatedTagTask2, addTagTask: addTagTask2, tagListTask: tagListTask2 } = (init_tag(), __toCommonJS2(tag_exports));
    var { straightThroughBufferTask: straightThroughBufferTask2, straightThroughStringTask: straightThroughStringTask2 } = (init_task(), __toCommonJS2(task_exports));
    function Git2(options, plugins) {
      this._executor = new GitExecutor2(options.binary, options.baseDir, new Scheduler2(options.maxConcurrentProcesses), plugins);
      this._trimmed = options.trimmed;
    }
    (Git2.prototype = Object.create(SimpleGitApi2.prototype)).constructor = Git2;
    Git2.prototype.customBinary = function(command) {
      this._executor.binary = command;
      return this;
    };
    Git2.prototype.env = function(name, value) {
      if (arguments.length === 1 && typeof name === "object") {
        this._executor.env = name;
      } else {
        (this._executor.env = this._executor.env || {})[name] = value;
      }
      return this;
    };
    Git2.prototype.stashList = function(options) {
      return this._runTask(stashListTask2(trailingOptionsArgument2(arguments) || {}, filterArray2(options) && options || []), trailingFunctionArgument2(arguments));
    };
    function createCloneTask(api, task, repoPath, localPath) {
      if (typeof repoPath !== "string") {
        return configurationErrorTask2(`git.${api}() requires a string 'repoPath'`);
      }
      return task(repoPath, filterType2(localPath, filterString2), getTrailingOptions2(arguments));
    }
    Git2.prototype.clone = function() {
      return this._runTask(createCloneTask("clone", cloneTask2, ...arguments), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.mirror = function() {
      return this._runTask(createCloneTask("mirror", cloneMirrorTask2, ...arguments), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.mv = function(from, to) {
      return this._runTask(moveTask2(from, to), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.checkoutLatestTag = function(then) {
      var git = this;
      return this.pull(function() {
        git.tags(function(err, tags) {
          git.checkout(tags.latest, then);
        });
      });
    };
    Git2.prototype.pull = function(remote, branch, options, then) {
      return this._runTask(pullTask2(filterType2(remote, filterString2), filterType2(branch, filterString2), getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.fetch = function(remote, branch) {
      return this._runTask(fetchTask2(filterType2(remote, filterString2), filterType2(branch, filterString2), getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.silent = function(silence) {
      console.warn("simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3");
      return this;
    };
    Git2.prototype.tags = function(options, then) {
      return this._runTask(tagListTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.rebase = function() {
      return this._runTask(straightThroughStringTask2(["rebase", ...getTrailingOptions2(arguments)]), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.reset = function(mode) {
      return this._runTask(resetTask2(getResetMode2(mode), getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.revert = function(commit) {
      const next = trailingFunctionArgument2(arguments);
      if (typeof commit !== "string") {
        return this._runTask(configurationErrorTask2("Commit must be a string"), next);
      }
      return this._runTask(straightThroughStringTask2(["revert", ...getTrailingOptions2(arguments, 0, true), commit]), next);
    };
    Git2.prototype.addTag = function(name) {
      const task = typeof name === "string" ? addTagTask2(name) : configurationErrorTask2("Git.addTag requires a tag name");
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.addAnnotatedTag = function(tagName, tagMessage) {
      return this._runTask(addAnnotatedTagTask2(tagName, tagMessage), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.deleteLocalBranch = function(branchName, forceDelete, then) {
      return this._runTask(deleteBranchTask2(branchName, typeof forceDelete === "boolean" ? forceDelete : false), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.deleteLocalBranches = function(branchNames, forceDelete, then) {
      return this._runTask(deleteBranchesTask2(branchNames, typeof forceDelete === "boolean" ? forceDelete : false), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.branch = function(options, then) {
      return this._runTask(branchTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.branchLocal = function(then) {
      return this._runTask(branchLocalTask2(), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.raw = function(commands) {
      const createRestCommands = !Array.isArray(commands);
      const command = [].slice.call(createRestCommands ? arguments : commands, 0);
      for (let i = 0; i < command.length && createRestCommands; i++) {
        if (!filterPrimitives2(command[i])) {
          command.splice(i, command.length - i);
          break;
        }
      }
      command.push(...getTrailingOptions2(arguments, 0, true));
      var next = trailingFunctionArgument2(arguments);
      if (!command.length) {
        return this._runTask(configurationErrorTask2("Raw: must supply one or more command to execute"), next);
      }
      return this._runTask(straightThroughStringTask2(command, this._trimmed), next);
    };
    Git2.prototype.submoduleAdd = function(repo, path, then) {
      return this._runTask(addSubModuleTask2(repo, path), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.submoduleUpdate = function(args, then) {
      return this._runTask(updateSubModuleTask2(getTrailingOptions2(arguments, true)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.submoduleInit = function(args, then) {
      return this._runTask(initSubModuleTask2(getTrailingOptions2(arguments, true)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.subModule = function(options, then) {
      return this._runTask(subModuleTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.listRemote = function() {
      return this._runTask(listRemotesTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.addRemote = function(remoteName, remoteRepo, then) {
      return this._runTask(addRemoteTask2(remoteName, remoteRepo, getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.removeRemote = function(remoteName, then) {
      return this._runTask(removeRemoteTask2(remoteName), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.getRemotes = function(verbose, then) {
      return this._runTask(getRemotesTask2(verbose === true), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.remote = function(options, then) {
      return this._runTask(remoteTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.tag = function(options, then) {
      const command = getTrailingOptions2(arguments);
      if (command[0] !== "tag") {
        command.unshift("tag");
      }
      return this._runTask(straightThroughStringTask2(command), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.updateServerInfo = function(then) {
      return this._runTask(straightThroughStringTask2(["update-server-info"]), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.pushTags = function(remote, then) {
      const task = pushTagsTask2({ remote: filterType2(remote, filterString2) }, getTrailingOptions2(arguments));
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.rm = function(files) {
      return this._runTask(straightThroughStringTask2(["rm", "-f", ...asArray2(files)]), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.rmKeepLocal = function(files) {
      return this._runTask(straightThroughStringTask2(["rm", "--cached", ...asArray2(files)]), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.catFile = function(options, then) {
      return this._catFile("utf-8", arguments);
    };
    Git2.prototype.binaryCatFile = function() {
      return this._catFile("buffer", arguments);
    };
    Git2.prototype._catFile = function(format, args) {
      var handler = trailingFunctionArgument2(args);
      var command = ["cat-file"];
      var options = args[0];
      if (typeof options === "string") {
        return this._runTask(configurationErrorTask2("Git.catFile: options must be supplied as an array of strings"), handler);
      }
      if (Array.isArray(options)) {
        command.push.apply(command, options);
      }
      const task = format === "buffer" ? straightThroughBufferTask2(command) : straightThroughStringTask2(command);
      return this._runTask(task, handler);
    };
    Git2.prototype.diff = function(options, then) {
      const task = filterString2(options) ? configurationErrorTask2("git.diff: supplying options as a single string is no longer supported, switch to an array of strings") : straightThroughStringTask2(["diff", ...getTrailingOptions2(arguments)]);
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.diffSummary = function() {
      return this._runTask(diffSummaryTask2(getTrailingOptions2(arguments, 1)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.applyPatch = function(patches) {
      const task = !filterStringOrStringArray2(patches) ? configurationErrorTask2(`git.applyPatch requires one or more string patches as the first argument`) : applyPatchTask2(asArray2(patches), getTrailingOptions2([].slice.call(arguments, 1)));
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.revparse = function() {
      const commands = ["rev-parse", ...getTrailingOptions2(arguments, true)];
      return this._runTask(straightThroughStringTask2(commands, true), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.clean = function(mode, options, then) {
      const usingCleanOptionsArray = isCleanOptionsArray2(mode);
      const cleanMode = usingCleanOptionsArray && mode.join("") || filterType2(mode, filterString2) || "";
      const customArgs = getTrailingOptions2([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));
      return this._runTask(cleanWithOptionsTask2(cleanMode, customArgs), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.exec = function(then) {
      const task = {
        commands: [],
        format: "utf-8",
        parser() {
          if (typeof then === "function") {
            then();
          }
        }
      };
      return this._runTask(task);
    };
    Git2.prototype.clearQueue = function() {
      return this;
    };
    Git2.prototype.checkIgnore = function(pathnames, then) {
      return this._runTask(checkIgnoreTask2(asArray2(filterType2(pathnames, filterStringOrStringArray2, []))), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.checkIsRepo = function(checkType, then) {
      return this._runTask(checkIsRepoTask2(filterType2(checkType, filterString2)), trailingFunctionArgument2(arguments));
    };
    module2.exports = Git2;
  }
});
init_pathspec();
init_git_error();
var GitConstructError = class extends GitError {
  constructor(config, message) {
    super(void 0, message);
    this.config = config;
  }
};
init_git_error();
init_git_error();
var GitPluginError = class extends GitError {
  constructor(task, plugin, message) {
    super(task, message);
    this.task = task;
    this.plugin = plugin;
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
init_git_response_error();
init_task_configuration_error();
init_check_is_repo();
init_clean();
init_config();
init_diff_name_status();
init_grep();
init_reset();
function abortPlugin(signal) {
  if (!signal) {
    return;
  }
  const onSpawnAfter = {
    type: "spawn.after",
    action(_data, context) {
      function kill() {
        context.kill(new GitPluginError(void 0, "abort", "Abort signal received"));
      }
      signal.addEventListener("abort", kill);
      context.spawned.on("close", () => signal.removeEventListener("abort", kill));
    }
  };
  const onSpawnBefore = {
    type: "spawn.before",
    action(_data, context) {
      if (signal.aborted) {
        context.kill(new GitPluginError(void 0, "abort", "Abort already signaled"));
      }
    }
  };
  return [onSpawnBefore, onSpawnAfter];
}
function isConfigSwitch(arg) {
  return typeof arg === "string" && arg.trim().toLowerCase() === "-c";
}
function preventProtocolOverride(arg, next) {
  if (!isConfigSwitch(arg)) {
    return;
  }
  if (!/^\s*protocol(.[a-z]+)?.allow/.test(next)) {
    return;
  }
  throw new GitPluginError(void 0, "unsafe", "Configuring protocol.allow is not permitted without enabling allowUnsafeExtProtocol");
}
function preventUploadPack(arg, method) {
  if (/^\s*--(upload|receive)-pack/.test(arg)) {
    throw new GitPluginError(void 0, "unsafe", `Use of --upload-pack or --receive-pack is not permitted without enabling allowUnsafePack`);
  }
  if (method === "clone" && /^\s*-u\b/.test(arg)) {
    throw new GitPluginError(void 0, "unsafe", `Use of clone with option -u is not permitted without enabling allowUnsafePack`);
  }
  if (method === "push" && /^\s*--exec\b/.test(arg)) {
    throw new GitPluginError(void 0, "unsafe", `Use of push with option --exec is not permitted without enabling allowUnsafePack`);
  }
}
function blockUnsafeOperationsPlugin({
  allowUnsafeProtocolOverride = false,
  allowUnsafePack = false
} = {}) {
  return {
    type: "spawn.args",
    action(args, context) {
      args.forEach((current, index) => {
        const next = index < args.length ? args[index + 1] : "";
        allowUnsafeProtocolOverride || preventProtocolOverride(current, next);
        allowUnsafePack || preventUploadPack(current, context.method);
      });
      return args;
    }
  };
}
init_utils();
function commandConfigPrefixingPlugin(configuration) {
  const prefix = prefixedArray(configuration, "-c");
  return {
    type: "spawn.args",
    action(data) {
      return [...prefix, ...data];
    }
  };
}
init_utils();
var never = (0, import_promise_deferred2.deferred)().promise;
function completionDetectionPlugin({
  onClose = true,
  onExit = 50
} = {}) {
  function createEvents() {
    let exitCode = -1;
    const events = {
      close: (0, import_promise_deferred2.deferred)(),
      closeTimeout: (0, import_promise_deferred2.deferred)(),
      exit: (0, import_promise_deferred2.deferred)(),
      exitTimeout: (0, import_promise_deferred2.deferred)()
    };
    const result = Promise.race([
      onClose === false ? never : events.closeTimeout.promise,
      onExit === false ? never : events.exitTimeout.promise
    ]);
    configureTimeout(onClose, events.close, events.closeTimeout);
    configureTimeout(onExit, events.exit, events.exitTimeout);
    return {
      close(code) {
        exitCode = code;
        events.close.done();
      },
      exit(code) {
        exitCode = code;
        events.exit.done();
      },
      get exitCode() {
        return exitCode;
      },
      result
    };
  }
  function configureTimeout(flag, event, timeout) {
    if (flag === false) {
      return;
    }
    (flag === true ? event.promise : event.promise.then(() => delay(flag))).then(timeout.done);
  }
  return {
    type: "spawn.after",
    action(_0, _1) {
      return __async(this, arguments, function* (_data, { spawned, close }) {
        var _a2, _b;
        const events = createEvents();
        let deferClose = true;
        let quickClose = () => void (deferClose = false);
        (_a2 = spawned.stdout) == null ? void 0 : _a2.on("data", quickClose);
        (_b = spawned.stderr) == null ? void 0 : _b.on("data", quickClose);
        spawned.on("error", quickClose);
        spawned.on("close", (code) => events.close(code));
        spawned.on("exit", (code) => events.exit(code));
        try {
          yield events.result;
          if (deferClose) {
            yield delay(50);
          }
          close(events.exitCode);
        } catch (err) {
          close(events.exitCode, err);
        }
      });
    }
  };
}
init_git_error();
function isTaskError(result) {
  return !!(result.exitCode && result.stdErr.length);
}
function getErrorMessage(result) {
  return Buffer.concat([...result.stdOut, ...result.stdErr]);
}
function errorDetectionHandler(overwrite = false, isError = isTaskError, errorMessage = getErrorMessage) {
  return (error, result) => {
    if (!overwrite && error || !isError(result)) {
      return error;
    }
    return errorMessage(result);
  };
}
function errorDetectionPlugin(config) {
  return {
    type: "task.error",
    action(data, context) {
      const error = config(data.error, {
        stdErr: context.stdErr,
        stdOut: context.stdOut,
        exitCode: context.exitCode
      });
      if (Buffer.isBuffer(error)) {
        return { error: new GitError(void 0, error.toString("utf-8")) };
      }
      return {
        error
      };
    }
  };
}
init_utils();
var PluginStore = class {
  constructor() {
    this.plugins = /* @__PURE__ */ new Set();
  }
  add(plugin) {
    const plugins = [];
    asArray(plugin).forEach((plugin2) => plugin2 && this.plugins.add(append(plugins, plugin2)));
    return () => {
      plugins.forEach((plugin2) => this.plugins.delete(plugin2));
    };
  }
  exec(type, data, context) {
    let output = data;
    const contextual = Object.freeze(Object.create(context));
    for (const plugin of this.plugins) {
      if (plugin.type === type) {
        output = plugin.action(output, contextual);
      }
    }
    return output;
  }
};
init_utils();
function progressMonitorPlugin(progress) {
  const progressCommand = "--progress";
  const progressMethods = ["checkout", "clone", "fetch", "pull", "push"];
  const onProgress = {
    type: "spawn.after",
    action(_data, context) {
      var _a2;
      if (!context.commands.includes(progressCommand)) {
        return;
      }
      (_a2 = context.spawned.stderr) == null ? void 0 : _a2.on("data", (chunk) => {
        const message = /^([\s\S]+?):\s*(\d+)% \((\d+)\/(\d+)\)/.exec(chunk.toString("utf8"));
        if (!message) {
          return;
        }
        progress({
          method: context.method,
          stage: progressEventStage(message[1]),
          progress: asNumber(message[2]),
          processed: asNumber(message[3]),
          total: asNumber(message[4])
        });
      });
    }
  };
  const onArgs = {
    type: "spawn.args",
    action(args, context) {
      if (!progressMethods.includes(context.method)) {
        return args;
      }
      return including(args, progressCommand);
    }
  };
  return [onArgs, onProgress];
}
function progressEventStage(input) {
  return String(input.toLowerCase().split(" ", 1)) || "unknown";
}
init_utils();
function spawnOptionsPlugin(spawnOptions) {
  const options = pick(spawnOptions, ["uid", "gid"]);
  return {
    type: "spawn.options",
    action(data) {
      return __spreadValues(__spreadValues({}, options), data);
    }
  };
}
function timeoutPlugin({
  block,
  stdErr = true,
  stdOut = true
}) {
  if (block > 0) {
    return {
      type: "spawn.after",
      action(_data, context) {
        var _a2, _b;
        let timeout;
        function wait() {
          timeout && clearTimeout(timeout);
          timeout = setTimeout(kill, block);
        }
        function stop() {
          var _a3, _b2;
          (_a3 = context.spawned.stdout) == null ? void 0 : _a3.off("data", wait);
          (_b2 = context.spawned.stderr) == null ? void 0 : _b2.off("data", wait);
          context.spawned.off("exit", stop);
          context.spawned.off("close", stop);
          timeout && clearTimeout(timeout);
        }
        function kill() {
          stop();
          context.kill(new GitPluginError(void 0, "timeout", `block timeout reached`));
        }
        stdOut && ((_a2 = context.spawned.stdout) == null ? void 0 : _a2.on("data", wait));
        stdErr && ((_b = context.spawned.stderr) == null ? void 0 : _b.on("data", wait));
        context.spawned.on("exit", stop);
        context.spawned.on("close", stop);
        wait();
      }
    };
  }
}
init_pathspec();
function suffixPathsPlugin() {
  return {
    type: "spawn.args",
    action(data) {
      const prefix = [];
      let suffix;
      function append2(args) {
        (suffix = suffix || []).push(...args);
      }
      for (let i = 0; i < data.length; i++) {
        const param = data[i];
        if (isPathSpec(param)) {
          append2(toPaths(param));
          continue;
        }
        if (param === "--") {
          append2(data.slice(i + 1).flatMap((item) => isPathSpec(item) && toPaths(item) || item));
          break;
        }
        prefix.push(param);
      }
      return !suffix ? prefix : [...prefix, "--", ...suffix.map(String)];
    }
  };
}
init_utils();
var Git = require_git();
function gitInstanceFactory(baseDir, options) {
  const plugins = new PluginStore();
  const config = createInstanceConfig(baseDir && (typeof baseDir === "string" ? { baseDir } : baseDir) || {}, options);
  if (!folderExists(config.baseDir)) {
    throw new GitConstructError(config, `Cannot use simple-git on a directory that does not exist`);
  }
  if (Array.isArray(config.config)) {
    plugins.add(commandConfigPrefixingPlugin(config.config));
  }
  plugins.add(blockUnsafeOperationsPlugin(config.unsafe));
  plugins.add(suffixPathsPlugin());
  plugins.add(completionDetectionPlugin(config.completion));
  config.abort && plugins.add(abortPlugin(config.abort));
  config.progress && plugins.add(progressMonitorPlugin(config.progress));
  config.timeout && plugins.add(timeoutPlugin(config.timeout));
  config.spawnOptions && plugins.add(spawnOptionsPlugin(config.spawnOptions));
  plugins.add(errorDetectionPlugin(errorDetectionHandler(true)));
  config.errors && plugins.add(errorDetectionPlugin(config.errors));
  return new Git(config, plugins);
}
init_git_response_error();
var simpleGit = gitInstanceFactory;

// main.ts
var DEFAULT_SETTINGS = {
  refreshURL: "https://staging.sunet.se/refresh-content",
  refreshUsername: "editor",
  refreshPassword: "dummy"
};
var SunetPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    const gitOptions = {
      baseDir: this.app.vault.adapter.basePath,
      binary: "git",
      maxConcurrentProcesses: 6,
      trimmed: false
    };
    this.git = simpleGit(gitOptions);
    this.addCommand({
      id: "discard-changes",
      name: "Discard changes in current file",
      editorCallback: (editor, view) => {
        this.discardChanges(view);
      }
    });
    this.addCommand({
      id: "discard-all-changes",
      name: "Discard changes in all files",
      callback: () => {
        this.discardAllChanges();
      }
    });
    this.addCommand({
      id: "commit-push-and-fetch",
      name: "Push all changes to staging",
      callback: () => {
        this.commitPushAndFetch();
      }
    });
    this.addCommand({
      id: "hard-reset-force-push-and-fetch",
      name: "Undo last push of changes to staging",
      callback: () => {
        this.hardResetForcePushAndFetch();
      }
    });
    this.addSettingTab(new SunetSettingTab(this.app, this));
    this.registerDomEvent(document, "click", (evt) => {
      console.log("click", evt);
    });
    this.registerInterval(window.setInterval(() => console.log("setInterval"), 5 * 60 * 1e3));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async discardChanges(view) {
    const file = view.file;
    if (file) {
      const filePath = file.path;
      try {
        await this.git.checkout(["--", filePath]);
        new import_obsidian.Notice("Unstaged changes discarded");
      } catch (error) {
        console.error("Error discarding changes:", error);
        new import_obsidian.Notice("Failed to discard changes");
      }
    } else {
      new import_obsidian.Notice("No file is currently active");
    }
  }
  async discardAllChanges() {
    try {
      await this.git.checkout(["--", "."]);
      new import_obsidian.Notice("All unstaged changes discarded");
    } catch (error) {
      console.error("Error discarding changes:", error);
      new import_obsidian.Notice("Failed to discard all unstaged changes");
    }
  }
  async commitPushAndFetch() {
    try {
      await this.git.add("./*").commit("Auto-commit").push();
      const credentials = btoa(`${this.settings.refreshUsername}:${this.settings.refreshPassword}`);
      const fetchOptions = {
        method: "POST",
        withCredentials: true,
        credentials: "include",
        headers: {
          "Accept": "text/plain",
          "Authorization": `Basic ${credentials}`
        }
      };
      const response = await fetch(this.settings.refreshURL, fetchOptions);
      const body = await response.text();
      new import_obsidian.Notice(body);
    } catch (error) {
      console.error("Error during operation:", error);
      new import_obsidian.Notice("Operation failed");
    }
  }
  async hardResetForcePushAndFetch() {
    try {
      await this.git.reset(["--hard", "HEAD~1"]);
      await this.git.push(["-f"]);
      const credentials = btoa(`${this.settings.refreshUsername}:${this.settings.refreshPassword}`);
      const fetchOptions = {
        method: "POST",
        withCredentials: true,
        credentials: "include",
        headers: {
          "Accept": "text/plain",
          "Authorization": `Basic ${credentials}`
        }
      };
      const response = await fetch(this.settings.refreshURL, fetchOptions);
      const body = await response.text();
      new import_obsidian.Notice(body);
    } catch (error) {
      console.error("Error during operation:", error);
      new import_obsidian.Notice("Operation failed: " + error.message);
    }
  }
};
var SunetSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Staging URL").setDesc("URL of the staging site for sunet.se, ending in /refresh-content").addText((text) => text.setPlaceholder("https://staging.sunet.se/refresh-content").setValue(this.plugin.settings.refreshURL).onChange(async (value) => {
      this.plugin.settings.refreshURL = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Staging Username").setDesc("Basic auth username for the /refresh-content endpoint").addText((text) => text.setPlaceholder("editor").setValue(this.plugin.settings.refreshUsername).onChange(async (value) => {
      this.plugin.settings.refreshUsername = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Staging password").setDesc("Basic auth password for the /refresh-content endpoint").addText((text) => text.setPlaceholder("dummy").setValue(this.plugin.settings.refreshPassword).onChange(async (value) => {
      this.plugin.settings.refreshPassword = value;
      await this.plugin.saveSettings();
    }));
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsICJub2RlX21vZHVsZXMvQGt3c2l0ZXMvZmlsZS1leGlzdHMvc3JjL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9Aa3dzaXRlcy9maWxlLWV4aXN0cy9pbmRleC50cyIsICJub2RlX21vZHVsZXMvQGt3c2l0ZXMvcHJvbWlzZS1kZWZlcnJlZC9zcmMvaW5kZXgudHMiLCAibWFpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL2FyZ3MvcGF0aHNwZWMudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9lcnJvcnMvZ2l0LWVycm9yLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvZXJyb3JzL2dpdC1yZXNwb25zZS1lcnJvci50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL2Vycm9ycy90YXNrLWNvbmZpZ3VyYXRpb24tZXJyb3IudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi91dGlscy91dGlsLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdXRpbHMvYXJndW1lbnQtZmlsdGVycy50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3V0aWxzL2V4aXQtY29kZXMudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi91dGlscy9naXQtb3V0cHV0LXN0cmVhbXMudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi91dGlscy9saW5lLXBhcnNlci50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3V0aWxzL3NpbXBsZS1naXQtb3B0aW9ucy50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3V0aWxzL3Rhc2stb3B0aW9ucy50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3V0aWxzL3Rhc2stcGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdXRpbHMvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9jaGVjay1pcy1yZXBvLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcmVzcG9uc2VzL0NsZWFuU3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL3Rhc2sudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9jbGVhbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Jlc3BvbnNlcy9Db25maWdMaXN0LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvY29uZmlnLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvZGlmZi1uYW1lLXN0YXR1cy50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL2dyZXAudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9yZXNldC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL2dpdC1sb2dnZXIudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9ydW5uZXJzL3Rhc2tzLXBlbmRpbmctcXVldWUudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9ydW5uZXJzL2dpdC1leGVjdXRvci1jaGFpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3J1bm5lcnMvZ2l0LWV4ZWN1dG9yLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFzay1jYWxsYmFjay50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL2NoYW5nZS13b3JraW5nLWRpcmVjdG9yeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL2NoZWNrb3V0LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGFyc2Vycy9wYXJzZS1jb21taXQudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9jb21taXQudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9maXJzdC1jb21taXQudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9oYXNoLW9iamVjdC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Jlc3BvbnNlcy9Jbml0U3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL2luaXQudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9hcmdzL2xvZy1mb3JtYXQudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvRGlmZlN1bW1hcnkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wYXJzZXJzL3BhcnNlLWRpZmYtc3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtbGlzdC1sb2ctc3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL2RpZmYudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9sb2cudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvTWVyZ2VTdW1tYXJ5LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcmVzcG9uc2VzL1B1bGxTdW1tYXJ5LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGFyc2Vycy9wYXJzZS1yZW1vdGUtb2JqZWN0cy50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtcmVtb3RlLW1lc3NhZ2VzLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGFyc2Vycy9wYXJzZS1wdWxsLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGFyc2Vycy9wYXJzZS1tZXJnZS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL21lcmdlLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGFyc2Vycy9wYXJzZS1wdXNoLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvcHVzaC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL3Nob3cudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvRmlsZVN0YXR1c1N1bW1hcnkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvU3RhdHVzU3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL3N0YXR1cy50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL3ZlcnNpb24udHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9zaW1wbGUtZ2l0LWFwaS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3J1bm5lcnMvc2NoZWR1bGVyLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvYXBwbHktcGF0Y2gudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvQnJhbmNoRGVsZXRlU3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtYnJhbmNoLWRlbGV0ZS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Jlc3BvbnNlcy9CcmFuY2hTdW1tYXJ5LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGFyc2Vycy9wYXJzZS1icmFuY2gudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9icmFuY2gudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvQ2hlY2tJZ25vcmUudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9jaGVjay1pZ25vcmUudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9jbG9uZS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtZmV0Y2gudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9mZXRjaC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtbW92ZS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL21vdmUudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9wdWxsLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcmVzcG9uc2VzL0dldFJlbW90ZVN1bW1hcnkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9yZW1vdGUudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9zdGFzaC1saXN0LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3Mvc3ViLW1vZHVsZS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Jlc3BvbnNlcy9UYWdMaXN0LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvdGFnLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9naXQuanMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9hcGkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9lcnJvcnMvZ2l0LWNvbnN0cnVjdC1lcnJvci50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL2Vycm9ycy9naXQtcGx1Z2luLWVycm9yLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGx1Z2lucy9hYm9ydC1wbHVnaW4udHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wbHVnaW5zL2Jsb2NrLXVuc2FmZS1vcGVyYXRpb25zLXBsdWdpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BsdWdpbnMvY29tbWFuZC1jb25maWctcHJlZml4aW5nLXBsdWdpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BsdWdpbnMvY29tcGxldGlvbi1kZXRlY3Rpb24ucGx1Z2luLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGx1Z2lucy9lcnJvci1kZXRlY3Rpb24ucGx1Z2luLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGx1Z2lucy9wbHVnaW4tc3RvcmUudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wbHVnaW5zL3Byb2dyZXNzLW1vbml0b3ItcGx1Z2luLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGx1Z2lucy9zcGF3bi1vcHRpb25zLXBsdWdpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BsdWdpbnMvdGltb3V0LXBsdWdpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BsdWdpbnMvc3VmZml4LXBhdGhzLnBsdWdpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL2dpdC1mYWN0b3J5LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcnVubmVycy9wcm9taXNlLXdyYXBwZWQudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2VzbS5tanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuIiwgIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblx0Y3JlYXRlRGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cblx0T2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Y3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuXHR9KTtcblxuXHQvKipcblx0KiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0Ki9cblxuXHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0KlxuXHQqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0Ki9cblx0Y3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2Vcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblx0XHRsZXQgZW5hYmxlT3ZlcnJpZGUgPSBudWxsO1xuXHRcdGxldCBuYW1lc3BhY2VzQ2FjaGU7XG5cdFx0bGV0IGVuYWJsZWRDYWNoZTtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyUnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdFx0XHRtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0XHRcdFx0XHQvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cdFx0XHRjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0XHRcdGNvbnN0IGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuXHRcdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXG5cdFx0ZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuXHRcdGRlYnVnLmNvbG9yID0gY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGNyZWF0ZURlYnVnLmRlc3Ryb3k7IC8vIFhYWCBUZW1wb3JhcnkuIFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRlYnVnLCAnZW5hYmxlZCcsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdFx0Z2V0OiAoKSA9PiB7XG5cdFx0XHRcdGlmIChlbmFibGVPdmVycmlkZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBlbmFibGVPdmVycmlkZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobmFtZXNwYWNlc0NhY2hlICE9PSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzKSB7XG5cdFx0XHRcdFx0bmFtZXNwYWNlc0NhY2hlID0gY3JlYXRlRGVidWcubmFtZXNwYWNlcztcblx0XHRcdFx0XHRlbmFibGVkQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZW5hYmxlZENhY2hlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogdiA9PiB7XG5cdFx0XHRcdGVuYWJsZU92ZXJyaWRlID0gdjtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcblx0XHRjb25zdCBuZXdEZWJ1ZyA9IGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG5cdFx0bmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG5cdFx0cmV0dXJuIG5ld0RlYnVnO1xuXHR9XG5cblx0LyoqXG5cdCogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdFx0Y3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcblx0XHRjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcztcblxuXHRcdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdFx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHRcdGxldCBpO1xuXHRcdGNvbnN0IHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0XHRjb25zdCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICghc3BsaXRbaV0pIHtcblx0XHRcdFx0Ly8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG5cdFx0XHRpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnNsaWNlKDEpICsgJyQnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0LyoqXG5cdCogWFhYIERPIE5PVCBVU0UuIFRoaXMgaXMgYSB0ZW1wb3Jhcnkgc3R1YiBmdW5jdGlvbi5cblx0KiBYWFggSXQgV0lMTCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cdCovXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4iLCAiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5leHBvcnRzLmRlc3Ryb3kgPSAoKCkgPT4ge1xuXHRsZXQgd2FybmVkID0gZmFsc2U7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoIXdhcm5lZCkge1xuXHRcdFx0d2FybmVkID0gdHJ1ZTtcblx0XHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHRcdH1cblx0fTtcbn0pKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuXHQnIzAwMDBDQycsXG5cdCcjMDAwMEZGJyxcblx0JyMwMDMzQ0MnLFxuXHQnIzAwMzNGRicsXG5cdCcjMDA2NkNDJyxcblx0JyMwMDY2RkYnLFxuXHQnIzAwOTlDQycsXG5cdCcjMDA5OUZGJyxcblx0JyMwMENDMDAnLFxuXHQnIzAwQ0MzMycsXG5cdCcjMDBDQzY2Jyxcblx0JyMwMENDOTknLFxuXHQnIzAwQ0NDQycsXG5cdCcjMDBDQ0ZGJyxcblx0JyMzMzAwQ0MnLFxuXHQnIzMzMDBGRicsXG5cdCcjMzMzM0NDJyxcblx0JyMzMzMzRkYnLFxuXHQnIzMzNjZDQycsXG5cdCcjMzM2NkZGJyxcblx0JyMzMzk5Q0MnLFxuXHQnIzMzOTlGRicsXG5cdCcjMzNDQzAwJyxcblx0JyMzM0NDMzMnLFxuXHQnIzMzQ0M2NicsXG5cdCcjMzNDQzk5Jyxcblx0JyMzM0NDQ0MnLFxuXHQnIzMzQ0NGRicsXG5cdCcjNjYwMENDJyxcblx0JyM2NjAwRkYnLFxuXHQnIzY2MzNDQycsXG5cdCcjNjYzM0ZGJyxcblx0JyM2NkNDMDAnLFxuXHQnIzY2Q0MzMycsXG5cdCcjOTkwMENDJyxcblx0JyM5OTAwRkYnLFxuXHQnIzk5MzNDQycsXG5cdCcjOTkzM0ZGJyxcblx0JyM5OUNDMDAnLFxuXHQnIzk5Q0MzMycsXG5cdCcjQ0MwMDAwJyxcblx0JyNDQzAwMzMnLFxuXHQnI0NDMDA2NicsXG5cdCcjQ0MwMDk5Jyxcblx0JyNDQzAwQ0MnLFxuXHQnI0NDMDBGRicsXG5cdCcjQ0MzMzAwJyxcblx0JyNDQzMzMzMnLFxuXHQnI0NDMzM2NicsXG5cdCcjQ0MzMzk5Jyxcblx0JyNDQzMzQ0MnLFxuXHQnI0NDMzNGRicsXG5cdCcjQ0M2NjAwJyxcblx0JyNDQzY2MzMnLFxuXHQnI0NDOTkwMCcsXG5cdCcjQ0M5OTMzJyxcblx0JyNDQ0NDMDAnLFxuXHQnI0NDQ0MzMycsXG5cdCcjRkYwMDAwJyxcblx0JyNGRjAwMzMnLFxuXHQnI0ZGMDA2NicsXG5cdCcjRkYwMDk5Jyxcblx0JyNGRjAwQ0MnLFxuXHQnI0ZGMDBGRicsXG5cdCcjRkYzMzAwJyxcblx0JyNGRjMzMzMnLFxuXHQnI0ZGMzM2NicsXG5cdCcjRkYzMzk5Jyxcblx0JyNGRjMzQ0MnLFxuXHQnI0ZGMzNGRicsXG5cdCcjRkY2NjAwJyxcblx0JyNGRjY2MzMnLFxuXHQnI0ZGOTkwMCcsXG5cdCcjRkY5OTMzJyxcblx0JyNGRkNDMDAnLFxuXHQnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0Ly8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuXHQvLyBleHBsaWNpdGx5XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cdHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHRcdC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0XHQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuXHRcdC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5kZWJ1ZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqIElmIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYXZhaWxhYmxlLCBmYWxscyBiYWNrXG4gKiB0byBgY29uc29sZS5sb2dgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMubG9nID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZyB8fCAoKCkgPT4ge30pO1xuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcbiIsIG51bGwsIG51bGwsIG51bGwsICJpbXBvcnQgeyBBcHAsIEVkaXRvciwgTWFya2Rvd25WaWV3LCBNb2RhbCwgTm90aWNlLCBQbHVnaW4sIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcgfSBmcm9tICdvYnNpZGlhbic7XG5cbmltcG9ydCB7IHNpbXBsZUdpdCwgU2ltcGxlR2l0LCBDbGVhbk9wdGlvbnMgfSBmcm9tICdzaW1wbGUtZ2l0JztcblxuLy8gUmVtZW1iZXIgdG8gcmVuYW1lIHRoZXNlIGNsYXNzZXMgYW5kIGludGVyZmFjZXMhXG5cbmludGVyZmFjZSBTdW5ldFBsdWdpblNldHRpbmdzIHtcbiAgcmVmcmVzaFVSTDogc3RyaW5nO1xuICByZWZyZXNoVXNlcm5hbWU6IHN0cmluZztcbiAgcmVmcmVzaFBhc3N3b3JkOiBzdHJpbmc7XG59XG5cbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IFN1bmV0UGx1Z2luU2V0dGluZ3MgPSB7XG4gIHJlZnJlc2hVUkw6ICdodHRwczovL3N0YWdpbmcuc3VuZXQuc2UvcmVmcmVzaC1jb250ZW50JyxcbiAgcmVmcmVzaFVzZXJuYW1lOiAnZWRpdG9yJyxcbiAgcmVmcmVzaFBhc3N3b3JkOiAnZHVtbXknLFxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdW5ldFBsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG4gIHNldHRpbmdzOiBTdW5ldFBsdWdpblNldHRpbmdzO1xuICBnaXQ6IFNpbXBsZUdpdDtcblxuICBhc3luYyBvbmxvYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcblxuICAgIGNvbnN0IGdpdE9wdGlvbnM6IFBhcnRpYWw8U2ltcGxlR2l0T3B0aW9ucz4gPSB7XG4gICAgICBiYXNlRGlyOiB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLmJhc2VQYXRoLFxuICAgICAgYmluYXJ5OiAnZ2l0JyxcbiAgICAgIG1heENvbmN1cnJlbnRQcm9jZXNzZXM6IDYsXG4gICAgICB0cmltbWVkOiBmYWxzZSxcbiAgICB9O1xuICAgIHRoaXMuZ2l0ID0gc2ltcGxlR2l0KGdpdE9wdGlvbnMpO1xuXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiAnZGlzY2FyZC1jaGFuZ2VzJyxcbiAgICAgIG5hbWU6ICdEaXNjYXJkIGNoYW5nZXMgaW4gY3VycmVudCBmaWxlJyxcbiAgICAgIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuICAgICAgICB0aGlzLmRpc2NhcmRDaGFuZ2VzKHZpZXcpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6ICdkaXNjYXJkLWFsbC1jaGFuZ2VzJyxcbiAgICAgIG5hbWU6ICdEaXNjYXJkIGNoYW5nZXMgaW4gYWxsIGZpbGVzJyxcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuZGlzY2FyZEFsbENoYW5nZXMoKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiAnY29tbWl0LXB1c2gtYW5kLWZldGNoJyxcbiAgICAgIG5hbWU6ICdQdXNoIGFsbCBjaGFuZ2VzIHRvIHN0YWdpbmcnLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgdGhpcy5jb21taXRQdXNoQW5kRmV0Y2goKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiAnaGFyZC1yZXNldC1mb3JjZS1wdXNoLWFuZC1mZXRjaCcsXG4gICAgICBuYW1lOiAnVW5kbyBsYXN0IHB1c2ggb2YgY2hhbmdlcyB0byBzdGFnaW5nJyxcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuaGFyZFJlc2V0Rm9yY2VQdXNoQW5kRmV0Y2goKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBUaGlzIGFkZHMgYSBzZXR0aW5ncyB0YWIgc28gdGhlIHVzZXIgY2FuIGNvbmZpZ3VyZSB2YXJpb3VzIGFzcGVjdHMgb2YgdGhlIHBsdWdpblxuICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgU3VuZXRTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG5cbiAgICAvLyBJZiB0aGUgcGx1Z2luIGhvb2tzIHVwIGFueSBnbG9iYWwgRE9NIGV2ZW50cyAob24gcGFydHMgb2YgdGhlIGFwcCB0aGF0IGRvZXNuJ3QgYmVsb25nIHRvIHRoaXMgcGx1Z2luKVxuICAgIC8vIFVzaW5nIHRoaXMgZnVuY3Rpb24gd2lsbCBhdXRvbWF0aWNhbGx5IHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXIgd2hlbiB0aGlzIHBsdWdpbiBpcyBkaXNhYmxlZC5cbiAgICB0aGlzLnJlZ2lzdGVyRG9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycsIChldnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdjbGljaycsIGV2dCk7XG4gICAgfSk7XG5cbiAgICAvLyBXaGVuIHJlZ2lzdGVyaW5nIGludGVydmFscywgdGhpcyBmdW5jdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgY2xlYXIgdGhlIGludGVydmFsIHdoZW4gdGhlIHBsdWdpbiBpcyBkaXNhYmxlZC5cbiAgICB0aGlzLnJlZ2lzdGVySW50ZXJ2YWwod2luZG93LnNldEludGVydmFsKCgpID0+IGNvbnNvbGUubG9nKCdzZXRJbnRlcnZhbCcpLCA1ICogNjAgKiAxMDAwKSk7XG4gIH1cblxuICBvbnVubG9hZCgpIHtcblxuICB9XG5cbiAgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xuICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuICB9XG5cbiAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG4gIH1cblxuICBhc3luYyBkaXNjYXJkQ2hhbmdlcyh2aWV3OiBNYXJrZG93blZpZXcpIHtcbiAgICBjb25zdCBmaWxlID0gdmlldy5maWxlO1xuICAgIGlmIChmaWxlKSB7XG4gICAgICBjb25zdCBmaWxlUGF0aCA9IGZpbGUucGF0aDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZ2l0LmNoZWNrb3V0KFsnLS0nLCBmaWxlUGF0aF0pO1xuICAgICAgICBuZXcgTm90aWNlKCdVbnN0YWdlZCBjaGFuZ2VzIGRpc2NhcmRlZCcpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGlzY2FyZGluZyBjaGFuZ2VzOicsIGVycm9yKTtcbiAgICAgICAgbmV3IE5vdGljZSgnRmFpbGVkIHRvIGRpc2NhcmQgY2hhbmdlcycpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXcgTm90aWNlKCdObyBmaWxlIGlzIGN1cnJlbnRseSBhY3RpdmUnKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZGlzY2FyZEFsbENoYW5nZXMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIERpc2NhcmQgYWxsIHVuc3RhZ2VkIGNoYW5nZXMgaW4gdGhlIHJlcG9zaXRvcnlcbiAgICAgIGF3YWl0IHRoaXMuZ2l0LmNoZWNrb3V0KFsnLS0nLCAnLiddKTtcbiAgICAgIG5ldyBOb3RpY2UoJ0FsbCB1bnN0YWdlZCBjaGFuZ2VzIGRpc2NhcmRlZCcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkaXNjYXJkaW5nIGNoYW5nZXM6JywgZXJyb3IpO1xuICAgICAgbmV3IE5vdGljZSgnRmFpbGVkIHRvIGRpc2NhcmQgYWxsIHVuc3RhZ2VkIGNoYW5nZXMnKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY29tbWl0UHVzaEFuZEZldGNoKCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBTdGFnZSwgY29tbWl0LCBhbmQgcHVzaCBjaGFuZ2VzXG4gICAgICBhd2FpdCB0aGlzLmdpdC5hZGQoJy4vKicpLmNvbW1pdCgnQXV0by1jb21taXQnKS5wdXNoKCk7XG5cblx0ICBjb25zdCBjcmVkZW50aWFscyA9IGJ0b2EoYCR7dGhpcy5zZXR0aW5ncy5yZWZyZXNoVXNlcm5hbWV9OiR7dGhpcy5zZXR0aW5ncy5yZWZyZXNoUGFzc3dvcmR9YCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGZldGNoT3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIHdpdGhDcmVkZW50aWFsczogdHJ1ZSxcbiAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQWNjZXB0XCI6IFwidGV4dC9wbGFpblwiLFxuXHRcdCAgXCJBdXRob3JpemF0aW9uXCI6IGBCYXNpYyAke2NyZWRlbnRpYWxzfWAsXG5cdFx0fSxcbiAgICAgIH07XG4gICAgICAvLyBGZXRjaCBkYXRhIGZyb20gZXhhbXBsZS5jb21cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy5zZXR0aW5ncy5yZWZyZXNoVVJMLCBmZXRjaE9wdGlvbnMpO1xuICAgICAgY29uc3QgYm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcblxuICAgICAgLy8gU2hvdyB0aGUgcmVzcG9uc2UgaW4gYSBOb3RpY2VcbiAgICAgIG5ldyBOb3RpY2UoYm9keSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBvcGVyYXRpb246JywgZXJyb3IpO1xuICAgICAgbmV3IE5vdGljZSgnT3BlcmF0aW9uIGZhaWxlZCcpO1xuICAgIH1cbiAgfVxuICBhc3luYyBoYXJkUmVzZXRGb3JjZVB1c2hBbmRGZXRjaCgpIHtcbiAgICB0cnkge1xuICAgICAgLy8gSGFyZCByZXNldCBhbmQgZm9yY2UgcHVzaFxuICAgICAgYXdhaXQgdGhpcy5naXQucmVzZXQoWyctLWhhcmQnLCAnSEVBRH4xJ10pO1xuICAgICAgYXdhaXQgdGhpcy5naXQucHVzaChbJy1mJ10pO1xuXG5cdCAgY29uc3QgY3JlZGVudGlhbHMgPSBidG9hKGAke3RoaXMuc2V0dGluZ3MucmVmcmVzaFVzZXJuYW1lfToke3RoaXMuc2V0dGluZ3MucmVmcmVzaFBhc3N3b3JkfWApO1xuICAgICAgXG4gICAgICBjb25zdCBmZXRjaE9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHRydWUsXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkFjY2VwdFwiOiBcInRleHQvcGxhaW5cIixcblx0XHQgIFwiQXV0aG9yaXphdGlvblwiOiBgQmFzaWMgJHtjcmVkZW50aWFsc31gLFxuXHRcdH0sXG4gICAgICB9O1xuXG4gICAgICAvLyBGZXRjaCBkYXRhIGZyb20gZXhhbXBsZS5jb21cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy5zZXR0aW5ncy5yZWZyZXNoVVJMLCBmZXRjaE9wdGlvbnMpO1xuICAgICAgY29uc3QgYm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcblxuICAgICAgLy8gU2hvdyB0aGUgcmVzcG9uc2UgaW4gYSBOb3RpY2VcbiAgICAgIG5ldyBOb3RpY2UoYm9keSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBvcGVyYXRpb246JywgZXJyb3IpO1xuICAgICAgbmV3IE5vdGljZSgnT3BlcmF0aW9uIGZhaWxlZDogJyArIGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5cbmNsYXNzIFN1bmV0U2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuICBwbHVnaW46IFN1bmV0UGx1Z2luO1xuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IFN1bmV0UGx1Z2luKSB7XG4gICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICB9XG5cbiAgZGlzcGxheSgpOiB2b2lkIHtcbiAgICBjb25zdCB7Y29udGFpbmVyRWx9ID0gdGhpcztcblxuICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKCdTdGFnaW5nIFVSTCcpXG4gICAgICAuc2V0RGVzYygnVVJMIG9mIHRoZSBzdGFnaW5nIHNpdGUgZm9yIHN1bmV0LnNlLCBlbmRpbmcgaW4gL3JlZnJlc2gtY29udGVudCcpXG4gICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdodHRwczovL3N0YWdpbmcuc3VuZXQuc2UvcmVmcmVzaC1jb250ZW50JylcbiAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnJlZnJlc2hVUkwpXG4gICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZWZyZXNoVVJMID0gdmFsdWU7XG4gICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgIH0pKTtcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgLnNldE5hbWUoJ1N0YWdpbmcgVXNlcm5hbWUnKVxuICAgICAgLnNldERlc2MoJ0Jhc2ljIGF1dGggdXNlcm5hbWUgZm9yIHRoZSAvcmVmcmVzaC1jb250ZW50IGVuZHBvaW50JylcbiAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ2VkaXRvcicpXG4gICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZWZyZXNoVXNlcm5hbWUpXG4gICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZWZyZXNoVXNlcm5hbWUgPSB2YWx1ZTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgfSkpO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZSgnU3RhZ2luZyBwYXNzd29yZCcpXG4gICAgICAuc2V0RGVzYygnQmFzaWMgYXV0aCBwYXNzd29yZCBmb3IgdGhlIC9yZWZyZXNoLWNvbnRlbnQgZW5kcG9pbnQnKVxuICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgIC5zZXRQbGFjZWhvbGRlcignZHVtbXknKVxuICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucmVmcmVzaFBhc3N3b3JkKVxuICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucmVmcmVzaFBhc3N3b3JkID0gdmFsdWU7XG4gICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgIH0pKTtcbiAgfVxufVxuIiwgImNvbnN0IGNhY2hlID0gbmV3IFdlYWtNYXA8U3RyaW5nLCBzdHJpbmdbXT4oKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGhzcGVjKC4uLnBhdGhzOiBzdHJpbmdbXSkge1xuICAgY29uc3Qga2V5ID0gbmV3IFN0cmluZyhwYXRocyk7XG4gICBjYWNoZS5zZXQoa2V5LCBwYXRocyk7XG5cbiAgIHJldHVybiBrZXkgYXMgc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQYXRoU3BlYyhwYXRoOiBzdHJpbmcgfCB1bmtub3duKTogcGF0aCBpcyBzdHJpbmcge1xuICAgcmV0dXJuIHBhdGggaW5zdGFuY2VvZiBTdHJpbmcgJiYgY2FjaGUuaGFzKHBhdGgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9QYXRocyhwYXRoU3BlYzogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgcmV0dXJuIGNhY2hlLmdldChwYXRoU3BlYykgfHwgW107XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBTaW1wbGVHaXRUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG4vKipcbiAqIFRoZSBgR2l0RXJyb3JgIGlzIHRocm93biB3aGVuIHRoZSB1bmRlcmx5aW5nIGBnaXRgIHByb2Nlc3MgdGhyb3dzIGFcbiAqIGZhdGFsIGV4Y2VwdGlvbiAoZWcgYW4gYEVOT0VOVGAgZXhjZXB0aW9uIHdoZW4gYXR0ZW1wdGluZyB0byB1c2UgYVxuICogbm9uLXdyaXRhYmxlIGRpcmVjdG9yeSBhcyB0aGUgcm9vdCBmb3IgeW91ciByZXBvKSwgYW5kIGFjdHMgYXMgdGhlXG4gKiBiYXNlIGNsYXNzIGZvciBtb3JlIHNwZWNpZmljIGVycm9ycyB0aHJvd24gYnkgdGhlIHBhcnNpbmcgb2YgdGhlXG4gKiBnaXQgcmVzcG9uc2Ugb3IgZXJyb3JzIGluIHRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSB0YXNrIGFib3V0IHRvXG4gKiBiZSBydW4uXG4gKlxuICogV2hlbiBhbiBleGNlcHRpb24gaXMgdGhyb3duLCBwZW5kaW5nIHRhc2tzIGluIHRoZSBzYW1lIGluc3RhbmNlIHdpbGxcbiAqIG5vdCBiZSBleGVjdXRlZC4gVGhlIHJlY29tbWVuZGVkIHdheSB0byBydW4gYSBzZXJpZXMgb2YgdGFza3MgdGhhdFxuICogY2FuIGluZGVwZW5kZW50bHkgZmFpbCB3aXRob3V0IG5lZWRpbmcgdG8gcHJldmVudCBmdXR1cmUgdGFza3MgZnJvbVxuICogcnVubmluZyBpcyB0byBjYXRjaCB0aGVtIGluZGl2aWR1YWxseTpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gaW1wb3J0IHsgZ2l0UCwgU2ltcGxlR2l0LCBHaXRFcnJvciwgUHVsbFJlc3VsdCB9IGZyb20gJ3NpbXBsZS1naXQnO1xuXG4gZnVuY3Rpb24gY2F0Y2hUYXNrIChlOiBHaXRFcnJvcikge1xuICAgcmV0dXJuIGUuXG4gfVxuXG4gY29uc3QgZ2l0ID0gZ2l0UChyZXBvV29ya2luZ0Rpcik7XG4gY29uc3QgcHVsbGVkOiBQdWxsUmVzdWx0IHwgR2l0RXJyb3IgPSBhd2FpdCBnaXQucHVsbCgpLmNhdGNoKGNhdGNoVGFzayk7XG4gY29uc3QgcHVzaGVkOiBzdHJpbmcgfCBHaXRFcnJvciA9IGF3YWl0IGdpdC5wdXNoVGFncygpLmNhdGNoKGNhdGNoVGFzayk7XG4gYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBHaXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgIGNvbnN0cnVjdG9yKFxuICAgICAgcHVibGljIHRhc2s/OiBTaW1wbGVHaXRUYXNrPGFueT4sXG4gICAgICBtZXNzYWdlPzogc3RyaW5nXG4gICApIHtcbiAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBHaXRFcnJvciB9IGZyb20gJy4vZ2l0LWVycm9yJztcblxuLyoqXG4gKiBUaGUgYEdpdFJlc3BvbnNlRXJyb3JgIGlzIHRoZSB3cmFwcGVyIGZvciBhIHBhcnNlZCByZXNwb25zZSB0aGF0IGlzIHRyZWF0ZWQgYXNcbiAqIGEgZmF0YWwgZXJyb3IsIGZvciBleGFtcGxlIGF0dGVtcHRpbmcgYSBgbWVyZ2VgIGNhbiBsZWF2ZSB0aGUgcmVwbyBpbiBhIGNvcnJ1cHRlZFxuICogc3RhdGUgd2hlbiB0aGVyZSBhcmUgY29uZmxpY3RzIHNvIHRoZSB0YXNrIHdpbGwgcmVqZWN0IHJhdGhlciB0aGFuIHJlc29sdmUuXG4gKlxuICogRm9yIGV4YW1wbGUsIGNhdGNoaW5nIHRoZSBtZXJnZSBjb25mbGljdCBleGNlcHRpb246XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuIGltcG9ydCB7IGdpdFAsIFNpbXBsZUdpdCwgR2l0UmVzcG9uc2VFcnJvciwgTWVyZ2VTdW1tYXJ5IH0gZnJvbSAnc2ltcGxlLWdpdCc7XG5cbiBjb25zdCBnaXQgPSBnaXRQKHJlcG9Sb290KTtcbiBjb25zdCBtZXJnZU9wdGlvbnM6IHN0cmluZ1tdID0gWyctLW5vLWZmJywgJ290aGVyLWJyYW5jaCddO1xuIGNvbnN0IG1lcmdlU3VtbWFyeTogTWVyZ2VTdW1tYXJ5ID0gYXdhaXQgZ2l0Lm1lcmdlKG1lcmdlT3B0aW9ucylcbiAgICAgIC5jYXRjaCgoZTogR2l0UmVzcG9uc2VFcnJvcjxNZXJnZVN1bW1hcnk+KSA9PiBlLmdpdCk7XG5cbiBpZiAobWVyZ2VTdW1tYXJ5LmZhaWxlZCkge1xuICAgLy8gZGVhbCB3aXRoIHRoZSBlcnJvclxuIH1cbiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEdpdFJlc3BvbnNlRXJyb3I8VCA9IGFueT4gZXh0ZW5kcyBHaXRFcnJvciB7XG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIC8qKlxuICAgICAgICogYC5naXRgIGFjY2VzcyB0aGUgcGFyc2VkIHJlc3BvbnNlIHRoYXQgaXMgdHJlYXRlZCBhcyBiZWluZyBhbiBlcnJvclxuICAgICAgICovXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgZ2l0OiBULFxuICAgICAgbWVzc2FnZT86IHN0cmluZ1xuICAgKSB7XG4gICAgICBzdXBlcih1bmRlZmluZWQsIG1lc3NhZ2UgfHwgU3RyaW5nKGdpdCkpO1xuICAgfVxufVxuIiwgImltcG9ydCB7IEdpdEVycm9yIH0gZnJvbSAnLi9naXQtZXJyb3InO1xuXG4vKipcbiAqIFRoZSBgVGFza0NvbmZpZ3VyYXRpb25FcnJvcmAgaXMgdGhyb3duIHdoZW4gYSBjb21tYW5kIHdhcyBpbmNvcnJlY3RseVxuICogY29uZmlndXJlZC4gQW4gZXJyb3Igb2YgdGhpcyBraW5kIG1lYW5zIHRoYXQgbm8gYXR0ZW1wdCB3YXMgbWFkZSB0b1xuICogcnVuIHlvdXIgY29tbWFuZCB0aHJvdWdoIHRoZSB1bmRlcmx5aW5nIGBnaXRgIGJpbmFyeS5cbiAqXG4gKiBDaGVjayB0aGUgYC5tZXNzYWdlYCBwcm9wZXJ0eSBmb3IgbW9yZSBkZXRhaWwgb24gd2h5IHlvdXIgY29uZmlndXJhdGlvblxuICogcmVzdWx0ZWQgaW4gYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBjbGFzcyBUYXNrQ29uZmlndXJhdGlvbkVycm9yIGV4dGVuZHMgR2l0RXJyb3Ige1xuICAgY29uc3RydWN0b3IobWVzc2FnZT86IHN0cmluZykge1xuICAgICAgc3VwZXIodW5kZWZpbmVkLCBtZXNzYWdlKTtcbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBleGlzdHMsIEZPTERFUiB9IGZyb20gJ0Brd3NpdGVzL2ZpbGUtZXhpc3RzJztcbmltcG9ydCB7IE1heWJlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgTlVMTCA9ICdcXDAnO1xuXG5leHBvcnQgY29uc3QgTk9PUDogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkID0gKCkgPT4ge307XG5cbi8qKlxuICogUmV0dXJucyBlaXRoZXIgdGhlIHNvdXJjZSBhcmd1bWVudCB3aGVuIGl0IGlzIGEgYEZ1bmN0aW9uYCwgb3IgdGhlIGRlZmF1bHRcbiAqIGBOT09QYCBmdW5jdGlvbiBjb25zdGFudFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNGdW5jdGlvbjxUIGV4dGVuZHMgKCkgPT4gYW55Pihzb3VyY2U6IFQgfCBhbnkpOiBUIHtcbiAgIHJldHVybiB0eXBlb2Ygc291cmNlID09PSAnZnVuY3Rpb24nID8gc291cmNlIDogTk9PUDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHN1cHBsaWVkIGFyZ3VtZW50IGlzIGJvdGggYSBmdW5jdGlvbiwgYW5kIGlzIG5vdFxuICogdGhlIGBOT09QYCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVXNlckZ1bmN0aW9uPFQgZXh0ZW5kcyBGdW5jdGlvbj4oc291cmNlOiBUIHwgYW55KTogc291cmNlIGlzIFQge1xuICAgcmV0dXJuIHR5cGVvZiBzb3VyY2UgPT09ICdmdW5jdGlvbicgJiYgc291cmNlICE9PSBOT09QO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRPbihpbnB1dDogc3RyaW5nLCBjaGFyOiBzdHJpbmcpOiBbc3RyaW5nLCBzdHJpbmddIHtcbiAgIGNvbnN0IGluZGV4ID0gaW5wdXQuaW5kZXhPZihjaGFyKTtcbiAgIGlmIChpbmRleCA8PSAwKSB7XG4gICAgICByZXR1cm4gW2lucHV0LCAnJ107XG4gICB9XG5cbiAgIHJldHVybiBbaW5wdXQuc3Vic3RyKDAsIGluZGV4KSwgaW5wdXQuc3Vic3RyKGluZGV4ICsgMSldO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlyc3Q8VCBleHRlbmRzIGFueVtdPihpbnB1dDogVCwgb2Zmc2V0PzogbnVtYmVyKTogTWF5YmU8VFtudW1iZXJdPjtcbmV4cG9ydCBmdW5jdGlvbiBmaXJzdDxUIGV4dGVuZHMgSUFyZ3VtZW50cz4oaW5wdXQ6IFQsIG9mZnNldD86IG51bWJlcik6IE1heWJlPHVua25vd24+O1xuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0KGlucHV0OiBhbnlbXSB8IElBcmd1bWVudHMsIG9mZnNldCA9IDApOiBNYXliZTx1bmtub3duPiB7XG4gICByZXR1cm4gaXNBcnJheUxpa2UoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA+IG9mZnNldCA/IGlucHV0W29mZnNldF0gOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXN0PFQgZXh0ZW5kcyBhbnlbXT4oaW5wdXQ6IFQsIG9mZnNldD86IG51bWJlcik6IE1heWJlPFRbbnVtYmVyXT47XG5leHBvcnQgZnVuY3Rpb24gbGFzdDxUIGV4dGVuZHMgSUFyZ3VtZW50cz4oaW5wdXQ6IFQsIG9mZnNldD86IG51bWJlcik6IE1heWJlPHVua25vd24+O1xuZXhwb3J0IGZ1bmN0aW9uIGxhc3Q8VD4oaW5wdXQ6IFQsIG9mZnNldD86IG51bWJlcik6IE1heWJlPHVua25vd24+O1xuZXhwb3J0IGZ1bmN0aW9uIGxhc3QoaW5wdXQ6IHVua25vd24sIG9mZnNldCA9IDApIHtcbiAgIGlmIChpc0FycmF5TGlrZShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID4gb2Zmc2V0KSB7XG4gICAgICByZXR1cm4gaW5wdXRbaW5wdXQubGVuZ3RoIC0gMSAtIG9mZnNldF07XG4gICB9XG59XG5cbnR5cGUgQXJyYXlMaWtlPFQgPSBhbnk+ID0gVFtdIHwgSUFyZ3VtZW50cyB8IHsgW2luZGV4OiBudW1iZXJdOiBUOyBsZW5ndGg6IG51bWJlciB9O1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZShpbnB1dDogYW55KTogaW5wdXQgaXMgQXJyYXlMaWtlIHtcbiAgIHJldHVybiAhIShpbnB1dCAmJiB0eXBlb2YgaW5wdXQubGVuZ3RoID09PSAnbnVtYmVyJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0xpbmVzV2l0aENvbnRlbnQoaW5wdXQgPSAnJywgdHJpbW1lZCA9IHRydWUsIHNlcGFyYXRvciA9ICdcXG4nKTogc3RyaW5nW10ge1xuICAgcmV0dXJuIGlucHV0LnNwbGl0KHNlcGFyYXRvcikucmVkdWNlKChvdXRwdXQsIGxpbmUpID0+IHtcbiAgICAgIGNvbnN0IGxpbmVDb250ZW50ID0gdHJpbW1lZCA/IGxpbmUudHJpbSgpIDogbGluZTtcbiAgICAgIGlmIChsaW5lQ29udGVudCkge1xuICAgICAgICAgb3V0cHV0LnB1c2gobGluZUNvbnRlbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgIH0sIFtdIGFzIHN0cmluZ1tdKTtcbn1cblxudHlwZSBMaW5lV2l0aENvbnRlbnRDYWxsYmFjazxUID0gdm9pZD4gPSAobGluZTogc3RyaW5nKSA9PiBUO1xuXG5leHBvcnQgZnVuY3Rpb24gZm9yRWFjaExpbmVXaXRoQ29udGVudDxUPihcbiAgIGlucHV0OiBzdHJpbmcsXG4gICBjYWxsYmFjazogTGluZVdpdGhDb250ZW50Q2FsbGJhY2s8VD5cbik6IFRbXSB7XG4gICByZXR1cm4gdG9MaW5lc1dpdGhDb250ZW50KGlucHV0LCB0cnVlKS5tYXAoKGxpbmUpID0+IGNhbGxiYWNrKGxpbmUpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvbGRlckV4aXN0cyhwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgIHJldHVybiBleGlzdHMocGF0aCwgRk9MREVSKTtcbn1cblxuLyoqXG4gKiBBZGRzIGBpdGVtYCBpbnRvIHRoZSBgdGFyZ2V0YCBgQXJyYXlgIG9yIGBTZXRgIHdoZW4gaXQgaXMgbm90IGFscmVhZHkgcHJlc2VudCBhbmQgcmV0dXJucyB0aGUgYGl0ZW1gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kPFQ+KHRhcmdldDogVFtdIHwgU2V0PFQ+LCBpdGVtOiBUKTogdHlwZW9mIGl0ZW0ge1xuICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgaWYgKCF0YXJnZXQuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgICAgIHRhcmdldC5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5hZGQoaXRlbSk7XG4gICB9XG4gICByZXR1cm4gaXRlbTtcbn1cblxuLyoqXG4gKiBBZGRzIGBpdGVtYCBpbnRvIHRoZSBgdGFyZ2V0YCBgQXJyYXlgIHdoZW4gaXQgaXMgbm90IGFscmVhZHkgcHJlc2VudCBhbmQgcmV0dXJucyB0aGUgYHRhcmdldGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmNsdWRpbmc8VD4odGFyZ2V0OiBUW10sIGl0ZW06IFQpOiB0eXBlb2YgdGFyZ2V0IHtcbiAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgIXRhcmdldC5pbmNsdWRlcyhpdGVtKSkge1xuICAgICAgdGFyZ2V0LnB1c2goaXRlbSk7XG4gICB9XG5cbiAgIHJldHVybiB0YXJnZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmU8VD4odGFyZ2V0OiBTZXQ8VD4gfCBUW10sIGl0ZW06IFQpOiBUIHtcbiAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGFyZ2V0LmluZGV4T2YoaXRlbSk7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgdGFyZ2V0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0LmRlbGV0ZShpdGVtKTtcbiAgIH1cbiAgIHJldHVybiBpdGVtO1xufVxuXG5leHBvcnQgY29uc3Qgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSBhcyAoXG4gICBpbnB1dDogYW55XG4pID0+IHN0cmluZztcblxuZXhwb3J0IGZ1bmN0aW9uIGFzQXJyYXk8VD4oc291cmNlOiBUIHwgVFtdKTogVFtdIHtcbiAgIHJldHVybiBBcnJheS5pc0FycmF5KHNvdXJjZSkgPyBzb3VyY2UgOiBbc291cmNlXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzU3RyaW5nQXJyYXk8VD4oc291cmNlOiBUIHwgVFtdKTogc3RyaW5nW10ge1xuICAgcmV0dXJuIGFzQXJyYXkoc291cmNlKS5tYXAoU3RyaW5nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzTnVtYmVyKHNvdXJjZTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCwgb25OYU4gPSAwKSB7XG4gICBpZiAoc291cmNlID09IG51bGwpIHtcbiAgICAgIHJldHVybiBvbk5hTjtcbiAgIH1cblxuICAgY29uc3QgbnVtID0gcGFyc2VJbnQoc291cmNlLCAxMCk7XG4gICByZXR1cm4gaXNOYU4obnVtKSA/IG9uTmFOIDogbnVtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJlZml4ZWRBcnJheTxUPihpbnB1dDogVFtdLCBwcmVmaXg6IFQpOiBUW10ge1xuICAgY29uc3Qgb3V0cHV0OiBUW10gPSBbXTtcbiAgIGZvciAobGV0IGkgPSAwLCBtYXggPSBpbnB1dC5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgb3V0cHV0LnB1c2gocHJlZml4LCBpbnB1dFtpXSk7XG4gICB9XG4gICByZXR1cm4gb3V0cHV0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVmZmVyVG9TdHJpbmcoaW5wdXQ6IEJ1ZmZlciB8IEJ1ZmZlcltdKTogc3RyaW5nIHtcbiAgIHJldHVybiAoQXJyYXkuaXNBcnJheShpbnB1dCkgPyBCdWZmZXIuY29uY2F0KGlucHV0KSA6IGlucHV0KS50b1N0cmluZygndXRmLTgnKTtcbn1cblxuLyoqXG4gKiBHZXQgYSBuZXcgb2JqZWN0IGZyb20gYSBzb3VyY2Ugb2JqZWN0IHdpdGggb25seSB0aGUgbGlzdGVkIHByb3BlcnRpZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwaWNrKHNvdXJjZTogUmVjb3JkPHN0cmluZywgYW55PiwgcHJvcGVydGllczogc3RyaW5nW10pIHtcbiAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAge30sXG4gICAgICAuLi5wcm9wZXJ0aWVzLm1hcCgocHJvcGVydHkpID0+IChwcm9wZXJ0eSBpbiBzb3VyY2UgPyB7IFtwcm9wZXJ0eV06IHNvdXJjZVtwcm9wZXJ0eV0gfSA6IHt9KSlcbiAgICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxheShkdXJhdGlvbiA9IDApOiBQcm9taXNlPHZvaWQ+IHtcbiAgIHJldHVybiBuZXcgUHJvbWlzZSgoZG9uZSkgPT4gc2V0VGltZW91dChkb25lLCBkdXJhdGlvbikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3JWb2lkPFQ+KGlucHV0OiBUIHwgZmFsc2UpIHtcbiAgIGlmIChpbnB1dCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICB9XG4gICByZXR1cm4gaW5wdXQ7XG59XG4iLCAiaW1wb3J0IHsgTWF5YmUsIE9wdGlvbnMsIFByaW1pdGl2ZXMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBvYmplY3RUb1N0cmluZyB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBpc1BhdGhTcGVjIH0gZnJvbSAnLi4vYXJncy9wYXRoc3BlYyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXJndW1lbnRGaWx0ZXJQcmVkaWNhdGU8VD4ge1xuICAgKGlucHV0OiBhbnkpOiBpbnB1dCBpcyBUO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyVHlwZTxULCBLPihcbiAgIGlucHV0OiBLLFxuICAgZmlsdGVyOiBBcmd1bWVudEZpbHRlclByZWRpY2F0ZTxUPlxuKTogSyBleHRlbmRzIFQgPyBUIDogdW5kZWZpbmVkO1xuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlclR5cGU8VCwgSz4oaW5wdXQ6IEssIGZpbHRlcjogQXJndW1lbnRGaWx0ZXJQcmVkaWNhdGU8VD4sIGRlZjogVCk6IFQ7XG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyVHlwZTxULCBLPihpbnB1dDogSywgZmlsdGVyOiBBcmd1bWVudEZpbHRlclByZWRpY2F0ZTxUPiwgZGVmPzogVCk6IE1heWJlPFQ+IHtcbiAgIGlmIChmaWx0ZXIoaW5wdXQpKSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICB9XG4gICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBkZWYgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBjb25zdCBmaWx0ZXJBcnJheTogQXJndW1lbnRGaWx0ZXJQcmVkaWNhdGU8QXJyYXk8YW55Pj4gPSAoaW5wdXQpOiBpbnB1dCBpcyBBcnJheTxhbnk+ID0+IHtcbiAgIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJQcmltaXRpdmVzKFxuICAgaW5wdXQ6IHVua25vd24sXG4gICBvbWl0PzogQXJyYXk8J2Jvb2xlYW4nIHwgJ3N0cmluZycgfCAnbnVtYmVyJz5cbik6IGlucHV0IGlzIFByaW1pdGl2ZXMge1xuICAgY29uc3QgdHlwZSA9IGlzUGF0aFNwZWMoaW5wdXQpID8gJ3N0cmluZycgOiB0eXBlb2YgaW5wdXQ7XG5cbiAgIHJldHVybiAoXG4gICAgICAvbnVtYmVyfHN0cmluZ3xib29sZWFuLy50ZXN0KHR5cGUpICYmXG4gICAgICAoIW9taXQgfHwgIW9taXQuaW5jbHVkZXModHlwZSBhcyAnYm9vbGVhbicgfCAnc3RyaW5nJyB8ICdudW1iZXInKSlcbiAgICk7XG59XG5cbmV4cG9ydCBjb25zdCBmaWx0ZXJTdHJpbmc6IEFyZ3VtZW50RmlsdGVyUHJlZGljYXRlPHN0cmluZz4gPSAoaW5wdXQpOiBpbnB1dCBpcyBzdHJpbmcgPT4ge1xuICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZyc7XG59O1xuXG5leHBvcnQgY29uc3QgZmlsdGVyU3RyaW5nQXJyYXk6IEFyZ3VtZW50RmlsdGVyUHJlZGljYXRlPHN0cmluZ1tdPiA9IChpbnB1dCk6IGlucHV0IGlzIHN0cmluZ1tdID0+IHtcbiAgIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0KSAmJiBpbnB1dC5ldmVyeShmaWx0ZXJTdHJpbmcpO1xufTtcblxuZXhwb3J0IGNvbnN0IGZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXk6IEFyZ3VtZW50RmlsdGVyUHJlZGljYXRlPHN0cmluZyB8IHN0cmluZ1tdPiA9IChcbiAgIGlucHV0XG4pOiBpbnB1dCBpcyBzdHJpbmcgfCBzdHJpbmdbXSA9PiB7XG4gICByZXR1cm4gZmlsdGVyU3RyaW5nKGlucHV0KSB8fCAoQXJyYXkuaXNBcnJheShpbnB1dCkgJiYgaW5wdXQuZXZlcnkoZmlsdGVyU3RyaW5nKSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyUGxhaW5PYmplY3Q8VCBleHRlbmRzIE9wdGlvbnM+KGlucHV0OiBUIHwgdW5rbm93bik6IGlucHV0IGlzIFQ7XG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyUGxhaW5PYmplY3Q8VCBleHRlbmRzIE9iamVjdD4oaW5wdXQ6IFQgfCB1bmtub3duKTogaW5wdXQgaXMgVCB7XG4gICByZXR1cm4gISFpbnB1dCAmJiBvYmplY3RUb1N0cmluZyhpbnB1dCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyRnVuY3Rpb24oaW5wdXQ6IHVua25vd24pOiBpbnB1dCBpcyBGdW5jdGlvbiB7XG4gICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgY29uc3QgZmlsdGVySGFzTGVuZ3RoOiBBcmd1bWVudEZpbHRlclByZWRpY2F0ZTx7IGxlbmd0aDogbnVtYmVyIH0+ID0gKFxuICAgaW5wdXRcbik6IGlucHV0IGlzIHsgbGVuZ3RoOiBudW1iZXIgfSA9PiB7XG4gICBpZiAoaW5wdXQgPT0gbnVsbCB8fCAnbnVtYmVyfGJvb2xlYW58ZnVuY3Rpb24nLmluY2x1ZGVzKHR5cGVvZiBpbnB1dCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgIH1cbiAgIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0KSB8fCB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBpbnB1dC5sZW5ndGggPT09ICdudW1iZXInO1xufTtcbiIsICIvKipcbiAqIEtub3duIHByb2Nlc3MgZXhpdCBjb2RlcyB1c2VkIGJ5IHRoZSB0YXNrIHBhcnNlcnMgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYW4gZXJyb3JcbiAqIHdhcyBvbmUgdGhleSBjYW4gYXV0b21hdGljYWxseSBoYW5kbGVcbiAqL1xuZXhwb3J0IGVudW0gRXhpdENvZGVzIHtcbiAgIFNVQ0NFU1MsXG4gICBFUlJPUixcbiAgIE5PVF9GT1VORCA9IC0yLFxuICAgVU5DTEVBTiA9IDEyOCxcbn1cbiIsICJpbXBvcnQgeyBUYXNrUmVzcG9uc2VGb3JtYXQgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBHaXRPdXRwdXRTdHJlYW1zPFQgZXh0ZW5kcyBUYXNrUmVzcG9uc2VGb3JtYXQgPSBCdWZmZXI+IHtcbiAgIGNvbnN0cnVjdG9yKFxuICAgICAgcHVibGljIHJlYWRvbmx5IHN0ZE91dDogVCxcbiAgICAgIHB1YmxpYyByZWFkb25seSBzdGRFcnI6IFRcbiAgICkge31cblxuICAgYXNTdHJpbmdzKCk6IEdpdE91dHB1dFN0cmVhbXM8c3RyaW5nPiB7XG4gICAgICByZXR1cm4gbmV3IEdpdE91dHB1dFN0cmVhbXModGhpcy5zdGRPdXQudG9TdHJpbmcoJ3V0ZjgnKSwgdGhpcy5zdGRFcnIudG9TdHJpbmcoJ3V0ZjgnKSk7XG4gICB9XG59XG4iLCAiZXhwb3J0IGNsYXNzIExpbmVQYXJzZXI8VD4ge1xuICAgcHJvdGVjdGVkIG1hdGNoZXM6IHN0cmluZ1tdID0gW107XG5cbiAgIHByaXZhdGUgX3JlZ0V4cDogUmVnRXhwW107XG5cbiAgIGNvbnN0cnVjdG9yKFxuICAgICAgcmVnRXhwOiBSZWdFeHAgfCBSZWdFeHBbXSxcbiAgICAgIHVzZU1hdGNoZXM/OiAodGFyZ2V0OiBULCBtYXRjaDogc3RyaW5nW10pID0+IGJvb2xlYW4gfCB2b2lkXG4gICApIHtcbiAgICAgIHRoaXMuX3JlZ0V4cCA9IEFycmF5LmlzQXJyYXkocmVnRXhwKSA/IHJlZ0V4cCA6IFtyZWdFeHBdO1xuICAgICAgaWYgKHVzZU1hdGNoZXMpIHtcbiAgICAgICAgIHRoaXMudXNlTWF0Y2hlcyA9IHVzZU1hdGNoZXM7XG4gICAgICB9XG4gICB9XG5cbiAgIHBhcnNlID0gKGxpbmU6IChvZmZzZXQ6IG51bWJlcikgPT4gc3RyaW5nIHwgdW5kZWZpbmVkLCB0YXJnZXQ6IFQpOiBib29sZWFuID0+IHtcbiAgICAgIHRoaXMucmVzZXRNYXRjaGVzKCk7XG5cbiAgICAgIGlmICghdGhpcy5fcmVnRXhwLmV2ZXJ5KChyZWcsIGluZGV4KSA9PiB0aGlzLmFkZE1hdGNoKHJlZywgaW5kZXgsIGxpbmUoaW5kZXgpKSkpIHtcbiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMudXNlTWF0Y2hlcyh0YXJnZXQsIHRoaXMucHJlcGFyZU1hdGNoZXMoKSkgIT09IGZhbHNlO1xuICAgfTtcblxuICAgLy8gQHRzLWlnbm9yZVxuICAgcHJvdGVjdGVkIHVzZU1hdGNoZXModGFyZ2V0OiBULCBtYXRjaDogc3RyaW5nW10pOiBib29sZWFuIHwgdm9pZCB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmVQYXJzZXI6dXNlTWF0Y2hlcyBub3QgaW1wbGVtZW50ZWRgKTtcbiAgIH1cblxuICAgcHJvdGVjdGVkIHJlc2V0TWF0Y2hlcygpIHtcbiAgICAgIHRoaXMubWF0Y2hlcy5sZW5ndGggPSAwO1xuICAgfVxuXG4gICBwcm90ZWN0ZWQgcHJlcGFyZU1hdGNoZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXRjaGVzO1xuICAgfVxuXG4gICBwcm90ZWN0ZWQgYWRkTWF0Y2gocmVnOiBSZWdFeHAsIGluZGV4OiBudW1iZXIsIGxpbmU/OiBzdHJpbmcpIHtcbiAgICAgIGNvbnN0IG1hdGNoZWQgPSBsaW5lICYmIHJlZy5leGVjKGxpbmUpO1xuICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgIHRoaXMucHVzaE1hdGNoKGluZGV4LCBtYXRjaGVkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICEhbWF0Y2hlZDtcbiAgIH1cblxuICAgcHJvdGVjdGVkIHB1c2hNYXRjaChfaW5kZXg6IG51bWJlciwgbWF0Y2hlZDogc3RyaW5nW10pIHtcbiAgICAgIHRoaXMubWF0Y2hlcy5wdXNoKC4uLm1hdGNoZWQuc2xpY2UoMSkpO1xuICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVtb3RlTGluZVBhcnNlcjxUPiBleHRlbmRzIExpbmVQYXJzZXI8VD4ge1xuICAgcHJvdGVjdGVkIGFkZE1hdGNoKHJlZzogUmVnRXhwLCBpbmRleDogbnVtYmVyLCBsaW5lPzogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gL15yZW1vdGU6XFxzLy50ZXN0KFN0cmluZyhsaW5lKSkgJiYgc3VwZXIuYWRkTWF0Y2gocmVnLCBpbmRleCwgbGluZSk7XG4gICB9XG5cbiAgIHByb3RlY3RlZCBwdXNoTWF0Y2goaW5kZXg6IG51bWJlciwgbWF0Y2hlZDogc3RyaW5nW10pIHtcbiAgICAgIGlmIChpbmRleCA+IDAgfHwgbWF0Y2hlZC5sZW5ndGggPiAxKSB7XG4gICAgICAgICBzdXBlci5wdXNoTWF0Y2goaW5kZXgsIG1hdGNoZWQpO1xuICAgICAgfVxuICAgfVxufVxuIiwgImltcG9ydCB7IFNpbXBsZUdpdE9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zOiBPbWl0PFNpbXBsZUdpdE9wdGlvbnMsICdiYXNlRGlyJz4gPSB7XG4gICBiaW5hcnk6ICdnaXQnLFxuICAgbWF4Q29uY3VycmVudFByb2Nlc3NlczogNSxcbiAgIGNvbmZpZzogW10sXG4gICB0cmltbWVkOiBmYWxzZSxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZUNvbmZpZyhcbiAgIC4uLm9wdGlvbnM6IEFycmF5PFBhcnRpYWw8U2ltcGxlR2l0T3B0aW9ucz4gfCB1bmRlZmluZWQ+XG4pOiBTaW1wbGVHaXRPcHRpb25zIHtcbiAgIGNvbnN0IGJhc2VEaXIgPSBwcm9jZXNzLmN3ZCgpO1xuICAgY29uc3QgY29uZmlnOiBTaW1wbGVHaXRPcHRpb25zID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHsgYmFzZURpciwgLi4uZGVmYXVsdE9wdGlvbnMgfSxcbiAgICAgIC4uLm9wdGlvbnMuZmlsdGVyKChvKSA9PiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgbylcbiAgICk7XG5cbiAgIGNvbmZpZy5iYXNlRGlyID0gY29uZmlnLmJhc2VEaXIgfHwgYmFzZURpcjtcbiAgIGNvbmZpZy50cmltbWVkID0gY29uZmlnLnRyaW1tZWQgPT09IHRydWU7XG5cbiAgIHJldHVybiBjb25maWc7XG59XG4iLCAiaW1wb3J0IHtcbiAgIGZpbHRlckFycmF5LFxuICAgZmlsdGVyRnVuY3Rpb24sXG4gICBmaWx0ZXJQbGFpbk9iamVjdCxcbiAgIGZpbHRlclByaW1pdGl2ZXMsXG4gICBmaWx0ZXJUeXBlLFxufSBmcm9tICcuL2FyZ3VtZW50LWZpbHRlcnMnO1xuaW1wb3J0IHsgYXNGdW5jdGlvbiwgaXNVc2VyRnVuY3Rpb24sIGxhc3QgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgTWF5YmUsIE9wdGlvbnMsIE9wdGlvbnNWYWx1ZXMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBpc1BhdGhTcGVjIH0gZnJvbSAnLi4vYXJncy9wYXRoc3BlYyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRUYXNrT3B0aW9uczxUIGV4dGVuZHMgT3B0aW9ucyA9IE9wdGlvbnM+KFxuICAgb3B0aW9uczogTWF5YmU8VD4sXG4gICBjb21tYW5kczogc3RyaW5nW10gPSBbXVxuKTogc3RyaW5nW10ge1xuICAgaWYgKCFmaWx0ZXJQbGFpbk9iamVjdDxPcHRpb25zPihvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIGNvbW1hbmRzO1xuICAgfVxuXG4gICByZXR1cm4gT2JqZWN0LmtleXMob3B0aW9ucykucmVkdWNlKChjb21tYW5kczogc3RyaW5nW10sIGtleTogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZTogT3B0aW9uc1ZhbHVlcyA9IG9wdGlvbnNba2V5XTtcblxuICAgICAgaWYgKGlzUGF0aFNwZWModmFsdWUpKSB7XG4gICAgICAgICBjb21tYW5kcy5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoZmlsdGVyUHJpbWl0aXZlcyh2YWx1ZSwgWydib29sZWFuJ10pKSB7XG4gICAgICAgICBjb21tYW5kcy5wdXNoKGtleSArICc9JyArIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICBjb21tYW5kcy5wdXNoKGtleSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb21tYW5kcztcbiAgIH0sIGNvbW1hbmRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYWlsaW5nT3B0aW9ucyhcbiAgIGFyZ3M6IElBcmd1bWVudHMsXG4gICBpbml0aWFsUHJpbWl0aXZlID0gMCxcbiAgIG9iamVjdE9ubHkgPSBmYWxzZVxuKTogc3RyaW5nW10ge1xuICAgY29uc3QgY29tbWFuZDogc3RyaW5nW10gPSBbXTtcblxuICAgZm9yIChsZXQgaSA9IDAsIG1heCA9IGluaXRpYWxQcmltaXRpdmUgPCAwID8gYXJncy5sZW5ndGggOiBpbml0aWFsUHJpbWl0aXZlOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgIGlmICgnc3RyaW5nfG51bWJlcicuaW5jbHVkZXModHlwZW9mIGFyZ3NbaV0pKSB7XG4gICAgICAgICBjb21tYW5kLnB1c2goU3RyaW5nKGFyZ3NbaV0pKTtcbiAgICAgIH1cbiAgIH1cblxuICAgYXBwZW5kVGFza09wdGlvbnModHJhaWxpbmdPcHRpb25zQXJndW1lbnQoYXJncyksIGNvbW1hbmQpO1xuICAgaWYgKCFvYmplY3RPbmx5KSB7XG4gICAgICBjb21tYW5kLnB1c2goLi4udHJhaWxpbmdBcnJheUFyZ3VtZW50KGFyZ3MpKTtcbiAgIH1cblxuICAgcmV0dXJuIGNvbW1hbmQ7XG59XG5cbmZ1bmN0aW9uIHRyYWlsaW5nQXJyYXlBcmd1bWVudChhcmdzOiBJQXJndW1lbnRzKSB7XG4gICBjb25zdCBoYXNUcmFpbGluZ0NhbGxiYWNrID0gdHlwZW9mIGxhc3QoYXJncykgPT09ICdmdW5jdGlvbic7XG4gICByZXR1cm4gZmlsdGVyVHlwZShsYXN0KGFyZ3MsIGhhc1RyYWlsaW5nQ2FsbGJhY2sgPyAxIDogMCksIGZpbHRlckFycmF5LCBbXSk7XG59XG5cbi8qKlxuICogR2l2ZW4gYW55IG51bWJlciBvZiBhcmd1bWVudHMsIHJldHVybnMgdGhlIHRyYWlsaW5nIG9wdGlvbnMgYXJndW1lbnQsIGlnbm9yaW5nIGEgdHJhaWxpbmcgZnVuY3Rpb24gYXJndW1lbnRcbiAqIGlmIHRoZXJlIGlzIG9uZS4gV2hlbiBub3QgZm91bmQsIHRoZSByZXR1cm4gdmFsdWUgaXMgbnVsbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYWlsaW5nT3B0aW9uc0FyZ3VtZW50KGFyZ3M6IElBcmd1bWVudHMpOiBNYXliZTxPcHRpb25zPiB7XG4gICBjb25zdCBoYXNUcmFpbGluZ0NhbGxiYWNrID0gZmlsdGVyRnVuY3Rpb24obGFzdChhcmdzKSk7XG4gICByZXR1cm4gZmlsdGVyVHlwZShsYXN0KGFyZ3MsIGhhc1RyYWlsaW5nQ2FsbGJhY2sgPyAxIDogMCksIGZpbHRlclBsYWluT2JqZWN0KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGVpdGhlciB0aGUgc291cmNlIGFyZ3VtZW50IHdoZW4gaXQgaXMgYSBgRnVuY3Rpb25gLCBvciB0aGUgZGVmYXVsdFxuICogYE5PT1BgIGZ1bmN0aW9uIGNvbnN0YW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoXG4gICBhcmdzOiB1bmtub3duW10gfCBJQXJndW1lbnRzIHwgdW5rbm93bixcbiAgIGluY2x1ZGVOb29wID0gdHJ1ZVxuKTogTWF5YmU8KC4uLmFyZ3M6IGFueVtdKSA9PiB1bmtub3duPiB7XG4gICBjb25zdCBjYWxsYmFjayA9IGFzRnVuY3Rpb24obGFzdChhcmdzKSk7XG4gICByZXR1cm4gaW5jbHVkZU5vb3AgfHwgaXNVc2VyRnVuY3Rpb24oY2FsbGJhY2spID8gY2FsbGJhY2sgOiB1bmRlZmluZWQ7XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBNYXliZUFycmF5LCBUYXNrUGFyc2VyLCBUYXNrUmVzcG9uc2VGb3JtYXQgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBHaXRPdXRwdXRTdHJlYW1zIH0gZnJvbSAnLi9naXQtb3V0cHV0LXN0cmVhbXMnO1xuaW1wb3J0IHsgTGluZVBhcnNlciB9IGZyb20gJy4vbGluZS1wYXJzZXInO1xuaW1wb3J0IHsgYXNBcnJheSwgdG9MaW5lc1dpdGhDb250ZW50IH0gZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGxUYXNrUGFyc2VyPElOUFVUIGV4dGVuZHMgVGFza1Jlc3BvbnNlRm9ybWF0LCBSRVNQT05TRT4oXG4gICBwYXJzZXI6IFRhc2tQYXJzZXI8SU5QVVQsIFJFU1BPTlNFPixcbiAgIHN0cmVhbXM6IEdpdE91dHB1dFN0cmVhbXM8SU5QVVQ+XG4pIHtcbiAgIHJldHVybiBwYXJzZXIoc3RyZWFtcy5zdGRPdXQsIHN0cmVhbXMuc3RkRXJyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU3RyaW5nUmVzcG9uc2U8VD4oXG4gICByZXN1bHQ6IFQsXG4gICBwYXJzZXJzOiBMaW5lUGFyc2VyPFQ+W10sXG4gICB0ZXh0czogTWF5YmVBcnJheTxzdHJpbmc+LFxuICAgdHJpbSA9IHRydWVcbik6IFQge1xuICAgYXNBcnJheSh0ZXh0cykuZm9yRWFjaCgodGV4dCkgPT4ge1xuICAgICAgZm9yIChsZXQgbGluZXMgPSB0b0xpbmVzV2l0aENvbnRlbnQodGV4dCwgdHJpbSksIGkgPSAwLCBtYXggPSBsaW5lcy5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgY29uc3QgbGluZSA9IChvZmZzZXQgPSAwKSA9PiB7XG4gICAgICAgICAgICBpZiAoaSArIG9mZnNldCA+PSBtYXgpIHtcbiAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaW5lc1tpICsgb2Zmc2V0XTtcbiAgICAgICAgIH07XG5cbiAgICAgICAgIHBhcnNlcnMuc29tZSgoeyBwYXJzZSB9KSA9PiBwYXJzZShsaW5lLCByZXN1bHQpKTtcbiAgICAgIH1cbiAgIH0pO1xuXG4gICByZXR1cm4gcmVzdWx0O1xufVxuIiwgImV4cG9ydCAqIGZyb20gJy4vYXJndW1lbnQtZmlsdGVycyc7XG5leHBvcnQgKiBmcm9tICcuL2V4aXQtY29kZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9naXQtb3V0cHV0LXN0cmVhbXMnO1xuZXhwb3J0ICogZnJvbSAnLi9saW5lLXBhcnNlcic7XG5leHBvcnQgKiBmcm9tICcuL3NpbXBsZS1naXQtb3B0aW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL3Rhc2stb3B0aW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL3Rhc2stcGFyc2VyJztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbCc7XG4iLCAiaW1wb3J0IHsgRXhpdENvZGVzIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgTWF5YmUsIFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBlbnVtIENoZWNrUmVwb0FjdGlvbnMge1xuICAgQkFSRSA9ICdiYXJlJyxcbiAgIElOX1RSRUUgPSAndHJlZScsXG4gICBJU19SRVBPX1JPT1QgPSAncm9vdCcsXG59XG5cbmNvbnN0IG9uRXJyb3I6IFN0cmluZ1Rhc2s8Ym9vbGVhbj5bJ29uRXJyb3InXSA9ICh7IGV4aXRDb2RlIH0sIGVycm9yLCBkb25lLCBmYWlsKSA9PiB7XG4gICBpZiAoZXhpdENvZGUgPT09IEV4aXRDb2Rlcy5VTkNMRUFOICYmIGlzTm90UmVwb01lc3NhZ2UoZXJyb3IpKSB7XG4gICAgICByZXR1cm4gZG9uZShCdWZmZXIuZnJvbSgnZmFsc2UnKSk7XG4gICB9XG5cbiAgIGZhaWwoZXJyb3IpO1xufTtcblxuY29uc3QgcGFyc2VyOiBTdHJpbmdUYXNrPGJvb2xlYW4+WydwYXJzZXInXSA9ICh0ZXh0KSA9PiB7XG4gICByZXR1cm4gdGV4dC50cmltKCkgPT09ICd0cnVlJztcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0lzUmVwb1Rhc2soYWN0aW9uOiBNYXliZTxDaGVja1JlcG9BY3Rpb25zPik6IFN0cmluZ1Rhc2s8Ym9vbGVhbj4ge1xuICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgIGNhc2UgQ2hlY2tSZXBvQWN0aW9ucy5CQVJFOlxuICAgICAgICAgcmV0dXJuIGNoZWNrSXNCYXJlUmVwb1Rhc2soKTtcbiAgICAgIGNhc2UgQ2hlY2tSZXBvQWN0aW9ucy5JU19SRVBPX1JPT1Q6XG4gICAgICAgICByZXR1cm4gY2hlY2tJc1JlcG9Sb290VGFzaygpO1xuICAgfVxuXG4gICBjb25zdCBjb21tYW5kcyA9IFsncmV2LXBhcnNlJywgJy0taXMtaW5zaWRlLXdvcmstdHJlZSddO1xuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBvbkVycm9yLFxuICAgICAgcGFyc2VyLFxuICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrSXNSZXBvUm9vdFRhc2soKTogU3RyaW5nVGFzazxib29sZWFuPiB7XG4gICBjb25zdCBjb21tYW5kcyA9IFsncmV2LXBhcnNlJywgJy0tZ2l0LWRpciddO1xuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBvbkVycm9yLFxuICAgICAgcGFyc2VyKHBhdGgpIHtcbiAgICAgICAgIHJldHVybiAvXlxcLihnaXQpPyQvLnRlc3QocGF0aC50cmltKCkpO1xuICAgICAgfSxcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0lzQmFyZVJlcG9UYXNrKCk6IFN0cmluZ1Rhc2s8Ym9vbGVhbj4ge1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ3Jldi1wYXJzZScsICctLWlzLWJhcmUtcmVwb3NpdG9yeSddO1xuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBvbkVycm9yLFxuICAgICAgcGFyc2VyLFxuICAgfTtcbn1cblxuZnVuY3Rpb24gaXNOb3RSZXBvTWVzc2FnZShlcnJvcjogRXJyb3IpOiBib29sZWFuIHtcbiAgIHJldHVybiAvKE5vdCBhIGdpdCByZXBvc2l0b3J5fEtlaW4gR2l0LVJlcG9zaXRvcnkpL2kudGVzdChTdHJpbmcoZXJyb3IpKTtcbn1cbiIsICJpbXBvcnQgeyBDbGVhblN1bW1hcnkgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IHRvTGluZXNXaXRoQ29udGVudCB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGNsYXNzIENsZWFuUmVzcG9uc2UgaW1wbGVtZW50cyBDbGVhblN1bW1hcnkge1xuICAgcHVibGljIHBhdGhzOiBzdHJpbmdbXSA9IFtdO1xuICAgcHVibGljIGZpbGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgcHVibGljIGZvbGRlcnM6IHN0cmluZ1tdID0gW107XG5cbiAgIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBkcnlSdW46IGJvb2xlYW4pIHt9XG59XG5cbmNvbnN0IHJlbW92YWxSZWdleHAgPSAvXlthLXpdK1xccyovaTtcbmNvbnN0IGRyeVJ1blJlbW92YWxSZWdleHAgPSAvXlthLXpdK1xccytbYS16XStcXHMqL2k7XG5jb25zdCBpc0ZvbGRlclJlZ2V4cCA9IC9cXC8kLztcblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuU3VtbWFyeVBhcnNlcihkcnlSdW46IGJvb2xlYW4sIHRleHQ6IHN0cmluZyk6IENsZWFuU3VtbWFyeSB7XG4gICBjb25zdCBzdW1tYXJ5ID0gbmV3IENsZWFuUmVzcG9uc2UoZHJ5UnVuKTtcbiAgIGNvbnN0IHJlZ2V4cCA9IGRyeVJ1biA/IGRyeVJ1blJlbW92YWxSZWdleHAgOiByZW1vdmFsUmVnZXhwO1xuXG4gICB0b0xpbmVzV2l0aENvbnRlbnQodGV4dCkuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgICAgY29uc3QgcmVtb3ZlZCA9IGxpbmUucmVwbGFjZShyZWdleHAsICcnKTtcblxuICAgICAgc3VtbWFyeS5wYXRocy5wdXNoKHJlbW92ZWQpO1xuICAgICAgKGlzRm9sZGVyUmVnZXhwLnRlc3QocmVtb3ZlZCkgPyBzdW1tYXJ5LmZvbGRlcnMgOiBzdW1tYXJ5LmZpbGVzKS5wdXNoKHJlbW92ZWQpO1xuICAgfSk7XG5cbiAgIHJldHVybiBzdW1tYXJ5O1xufVxuIiwgImltcG9ydCB7IFRhc2tDb25maWd1cmF0aW9uRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvdGFzay1jb25maWd1cmF0aW9uLWVycm9yJztcbmltcG9ydCB0eXBlIHsgQnVmZmVyVGFzaywgRW1wdHlUYXNrUGFyc2VyLCBTaW1wbGVHaXRUYXNrLCBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgRU1QVFlfQ09NTUFORFM6IFtdID0gW107XG5cbmV4cG9ydCB0eXBlIEVtcHR5VGFzayA9IHtcbiAgIGNvbW1hbmRzOiB0eXBlb2YgRU1QVFlfQ09NTUFORFM7XG4gICBmb3JtYXQ6ICdlbXB0eSc7XG4gICBwYXJzZXI6IEVtcHR5VGFza1BhcnNlcjtcbiAgIG9uRXJyb3I/OiB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gYWRob2NFeGVjVGFzayhwYXJzZXI6IEVtcHR5VGFza1BhcnNlcik6IEVtcHR5VGFzayB7XG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHM6IEVNUFRZX0NPTU1BTkRTLFxuICAgICAgZm9ybWF0OiAnZW1wdHknLFxuICAgICAgcGFyc2VyLFxuICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soZXJyb3I6IEVycm9yIHwgc3RyaW5nKTogRW1wdHlUYXNrIHtcbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kczogRU1QVFlfQ09NTUFORFMsXG4gICAgICBmb3JtYXQ6ICdlbXB0eScsXG4gICAgICBwYXJzZXIoKSB7XG4gICAgICAgICB0aHJvdyB0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnID8gbmV3IFRhc2tDb25maWd1cmF0aW9uRXJyb3IoZXJyb3IpIDogZXJyb3I7XG4gICAgICB9LFxuICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHM6IHN0cmluZ1tdLCB0cmltbWVkID0gZmFsc2UpOiBTdHJpbmdUYXNrPHN0cmluZz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgcGFyc2VyKHRleHQpIHtcbiAgICAgICAgIHJldHVybiB0cmltbWVkID8gU3RyaW5nKHRleHQpLnRyaW0oKSA6IHRleHQ7XG4gICAgICB9LFxuICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2soY29tbWFuZHM6IHN0cmluZ1tdKTogQnVmZmVyVGFzazxhbnk+IHtcbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kcyxcbiAgICAgIGZvcm1hdDogJ2J1ZmZlcicsXG4gICAgICBwYXJzZXIoYnVmZmVyKSB7XG4gICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgICAgfSxcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0J1ZmZlclRhc2s8Uj4odGFzazogU2ltcGxlR2l0VGFzazxSPik6IHRhc2sgaXMgQnVmZmVyVGFzazxSPiB7XG4gICByZXR1cm4gdGFzay5mb3JtYXQgPT09ICdidWZmZXInO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFbXB0eVRhc2s8Uj4odGFzazogU2ltcGxlR2l0VGFzazxSPik6IHRhc2sgaXMgRW1wdHlUYXNrIHtcbiAgIHJldHVybiB0YXNrLmZvcm1hdCA9PT0gJ2VtcHR5JyB8fCAhdGFzay5jb21tYW5kcy5sZW5ndGg7XG59XG4iLCAiaW1wb3J0IHsgQ2xlYW5TdW1tYXJ5IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBjbGVhblN1bW1hcnlQYXJzZXIgfSBmcm9tICcuLi9yZXNwb25zZXMvQ2xlYW5TdW1tYXJ5JztcbmltcG9ydCB7IE1heWJlLCBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgYXNTdHJpbmdBcnJheSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IGNvbmZpZ3VyYXRpb25FcnJvclRhc2sgfSBmcm9tICcuL3Rhc2snO1xuXG5leHBvcnQgY29uc3QgQ09ORklHX0VSUk9SX0lOVEVSQUNUSVZFX01PREUgPSAnR2l0IGNsZWFuIGludGVyYWN0aXZlIG1vZGUgaXMgbm90IHN1cHBvcnRlZCc7XG5leHBvcnQgY29uc3QgQ09ORklHX0VSUk9SX01PREVfUkVRVUlSRUQgPSAnR2l0IGNsZWFuIG1vZGUgcGFyYW1ldGVyIChcIm5cIiBvciBcImZcIikgaXMgcmVxdWlyZWQnO1xuZXhwb3J0IGNvbnN0IENPTkZJR19FUlJPUl9VTktOT1dOX09QVElPTiA9ICdHaXQgY2xlYW4gdW5rbm93biBvcHRpb24gZm91bmQgaW46ICc7XG5cbi8qKlxuICogQWxsIHN1cHBvcnRlZCBvcHRpb24gc3dpdGNoZXMgYXZhaWxhYmxlIGZvciB1c2UgaW4gYSBgZ2l0LmNsZWFuYCBvcGVyYXRpb25cbiAqL1xuZXhwb3J0IGVudW0gQ2xlYW5PcHRpb25zIHtcbiAgIERSWV9SVU4gPSAnbicsXG4gICBGT1JDRSA9ICdmJyxcbiAgIElHTk9SRURfSU5DTFVERUQgPSAneCcsXG4gICBJR05PUkVEX09OTFkgPSAnWCcsXG4gICBFWENMVURJTkcgPSAnZScsXG4gICBRVUlFVCA9ICdxJyxcbiAgIFJFQ1VSU0lWRSA9ICdkJyxcbn1cblxuLyoqXG4gKiBUaGUgdHdvIG1vZGVzIGBnaXQuY2xlYW5gIGNhbiBydW4gaW4gLSBvbmUgb2YgdGhlc2UgbXVzdCBiZSBzdXBwbGllZCBpbiBvcmRlclxuICogZm9yIHRoZSBjb21tYW5kIHRvIG5vdCB0aHJvdyBhIGBUYXNrQ29uZmlndXJhdGlvbkVycm9yYFxuICovXG5leHBvcnQgdHlwZSBDbGVhbk1vZGUgPSBDbGVhbk9wdGlvbnMuRk9SQ0UgfCBDbGVhbk9wdGlvbnMuRFJZX1JVTjtcblxuY29uc3QgQ2xlYW5PcHRpb25WYWx1ZXM6IFNldDxzdHJpbmc+ID0gbmV3IFNldChbXG4gICAnaScsXG4gICAuLi5hc1N0cmluZ0FycmF5KE9iamVjdC52YWx1ZXMoQ2xlYW5PcHRpb25zIGFzIGFueSkpLFxuXSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbldpdGhPcHRpb25zVGFzayhtb2RlOiBDbGVhbk1vZGUgfCBzdHJpbmcsIGN1c3RvbUFyZ3M6IHN0cmluZ1tdKSB7XG4gICBjb25zdCB7IGNsZWFuTW9kZSwgb3B0aW9ucywgdmFsaWQgfSA9IGdldENsZWFuT3B0aW9ucyhtb2RlKTtcblxuICAgaWYgKCFjbGVhbk1vZGUpIHtcbiAgICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKENPTkZJR19FUlJPUl9NT0RFX1JFUVVJUkVEKTtcbiAgIH1cblxuICAgaWYgKCF2YWxpZC5vcHRpb25zKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhDT05GSUdfRVJST1JfVU5LTk9XTl9PUFRJT04gKyBKU09OLnN0cmluZ2lmeShtb2RlKSk7XG4gICB9XG5cbiAgIG9wdGlvbnMucHVzaCguLi5jdXN0b21BcmdzKTtcblxuICAgaWYgKG9wdGlvbnMuc29tZShpc0ludGVyYWN0aXZlTW9kZSkpIHtcbiAgICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKENPTkZJR19FUlJPUl9JTlRFUkFDVElWRV9NT0RFKTtcbiAgIH1cblxuICAgcmV0dXJuIGNsZWFuVGFzayhjbGVhbk1vZGUsIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xlYW5UYXNrKG1vZGU6IENsZWFuTW9kZSwgY3VzdG9tQXJnczogc3RyaW5nW10pOiBTdHJpbmdUYXNrPENsZWFuU3VtbWFyeT4ge1xuICAgY29uc3QgY29tbWFuZHM6IHN0cmluZ1tdID0gWydjbGVhbicsIGAtJHttb2RlfWAsIC4uLmN1c3RvbUFyZ3NdO1xuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXIodGV4dDogc3RyaW5nKTogQ2xlYW5TdW1tYXJ5IHtcbiAgICAgICAgIHJldHVybiBjbGVhblN1bW1hcnlQYXJzZXIobW9kZSA9PT0gQ2xlYW5PcHRpb25zLkRSWV9SVU4sIHRleHQpO1xuICAgICAgfSxcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NsZWFuT3B0aW9uc0FycmF5KGlucHV0OiBzdHJpbmdbXSk6IGlucHV0IGlzIENsZWFuT3B0aW9uc1tdIHtcbiAgIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0KSAmJiBpbnB1dC5ldmVyeSgodGVzdCkgPT4gQ2xlYW5PcHRpb25WYWx1ZXMuaGFzKHRlc3QpKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xlYW5PcHRpb25zKGlucHV0OiBzdHJpbmcpIHtcbiAgIGxldCBjbGVhbk1vZGU6IE1heWJlPENsZWFuTW9kZT47XG4gICBsZXQgb3B0aW9uczogc3RyaW5nW10gPSBbXTtcbiAgIGxldCB2YWxpZCA9IHsgY2xlYW5Nb2RlOiBmYWxzZSwgb3B0aW9uczogdHJ1ZSB9O1xuXG4gICBpbnB1dFxuICAgICAgLnJlcGxhY2UoL1teYS16XWkvZywgJycpXG4gICAgICAuc3BsaXQoJycpXG4gICAgICAuZm9yRWFjaCgoY2hhcikgPT4ge1xuICAgICAgICAgaWYgKGlzQ2xlYW5Nb2RlKGNoYXIpKSB7XG4gICAgICAgICAgICBjbGVhbk1vZGUgPSBjaGFyO1xuICAgICAgICAgICAgdmFsaWQuY2xlYW5Nb2RlID0gdHJ1ZTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWxpZC5vcHRpb25zID0gdmFsaWQub3B0aW9ucyAmJiBpc0tub3duT3B0aW9uKChvcHRpb25zW29wdGlvbnMubGVuZ3RoXSA9IGAtJHtjaGFyfWApKTtcbiAgICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICByZXR1cm4ge1xuICAgICAgY2xlYW5Nb2RlLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHZhbGlkLFxuICAgfTtcbn1cblxuZnVuY3Rpb24gaXNDbGVhbk1vZGUoY2xlYW5Nb2RlPzogc3RyaW5nKTogY2xlYW5Nb2RlIGlzIENsZWFuTW9kZSB7XG4gICByZXR1cm4gY2xlYW5Nb2RlID09PSBDbGVhbk9wdGlvbnMuRk9SQ0UgfHwgY2xlYW5Nb2RlID09PSBDbGVhbk9wdGlvbnMuRFJZX1JVTjtcbn1cblxuZnVuY3Rpb24gaXNLbm93bk9wdGlvbihvcHRpb246IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgcmV0dXJuIC9eLVthLXpdJC9pLnRlc3Qob3B0aW9uKSAmJiBDbGVhbk9wdGlvblZhbHVlcy5oYXMob3B0aW9uLmNoYXJBdCgxKSk7XG59XG5cbmZ1bmN0aW9uIGlzSW50ZXJhY3RpdmVNb2RlKG9wdGlvbjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICBpZiAoL14tW15cXC1dLy50ZXN0KG9wdGlvbikpIHtcbiAgICAgIHJldHVybiBvcHRpb24uaW5kZXhPZignaScpID4gMDtcbiAgIH1cblxuICAgcmV0dXJuIG9wdGlvbiA9PT0gJy0taW50ZXJhY3RpdmUnO1xufVxuIiwgImltcG9ydCB7IENvbmZpZ0dldFJlc3VsdCwgQ29uZmlnTGlzdFN1bW1hcnksIENvbmZpZ1ZhbHVlcyB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgbGFzdCwgc3BsaXRPbiB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGNsYXNzIENvbmZpZ0xpc3QgaW1wbGVtZW50cyBDb25maWdMaXN0U3VtbWFyeSB7XG4gICBwdWJsaWMgZmlsZXM6IHN0cmluZ1tdID0gW107XG4gICBwdWJsaWMgdmFsdWVzOiB7IFtmaWxlTmFtZTogc3RyaW5nXTogQ29uZmlnVmFsdWVzIH0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICBwcml2YXRlIF9hbGw6IENvbmZpZ1ZhbHVlcyB8IHVuZGVmaW5lZDtcblxuICAgcHVibGljIGdldCBhbGwoKTogQ29uZmlnVmFsdWVzIHtcbiAgICAgIGlmICghdGhpcy5fYWxsKSB7XG4gICAgICAgICB0aGlzLl9hbGwgPSB0aGlzLmZpbGVzLnJlZHVjZSgoYWxsOiBDb25maWdWYWx1ZXMsIGZpbGU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWxsLCB0aGlzLnZhbHVlc1tmaWxlXSk7XG4gICAgICAgICB9LCB7fSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9hbGw7XG4gICB9XG5cbiAgIHB1YmxpYyBhZGRGaWxlKGZpbGU6IHN0cmluZyk6IENvbmZpZ1ZhbHVlcyB7XG4gICAgICBpZiAoIShmaWxlIGluIHRoaXMudmFsdWVzKSkge1xuICAgICAgICAgY29uc3QgbGF0ZXN0ID0gbGFzdCh0aGlzLmZpbGVzKTtcbiAgICAgICAgIHRoaXMudmFsdWVzW2ZpbGVdID0gbGF0ZXN0ID8gT2JqZWN0LmNyZWF0ZSh0aGlzLnZhbHVlc1tsYXRlc3RdKSA6IHt9O1xuXG4gICAgICAgICB0aGlzLmZpbGVzLnB1c2goZmlsZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnZhbHVlc1tmaWxlXTtcbiAgIH1cblxuICAgcHVibGljIGFkZFZhbHVlKGZpbGU6IHN0cmluZywga2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuYWRkRmlsZShmaWxlKTtcblxuICAgICAgaWYgKCF2YWx1ZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgdmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXNba2V5XSkpIHtcbiAgICAgICAgICh2YWx1ZXNba2V5XSBhcyBzdHJpbmdbXSkucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgdmFsdWVzW2tleV0gPSBbdmFsdWVzW2tleV0gYXMgc3RyaW5nLCB2YWx1ZV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FsbCA9IHVuZGVmaW5lZDtcbiAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmZpZ0xpc3RQYXJzZXIodGV4dDogc3RyaW5nKTogQ29uZmlnTGlzdCB7XG4gICBjb25zdCBjb25maWcgPSBuZXcgQ29uZmlnTGlzdCgpO1xuXG4gICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29uZmlnUGFyc2VyKHRleHQpKSB7XG4gICAgICBjb25maWcuYWRkVmFsdWUoaXRlbS5maWxlLCBTdHJpbmcoaXRlbS5rZXkpLCBpdGVtLnZhbHVlKTtcbiAgIH1cblxuICAgcmV0dXJuIGNvbmZpZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmZpZ0dldFBhcnNlcih0ZXh0OiBzdHJpbmcsIGtleTogc3RyaW5nKTogQ29uZmlnR2V0UmVzdWx0IHtcbiAgIGxldCB2YWx1ZTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICBjb25zdCB2YWx1ZXM6IHN0cmluZ1tdID0gW107XG4gICBjb25zdCBzY29wZXM6IE1hcDxzdHJpbmcsIHN0cmluZ1tdPiA9IG5ldyBNYXAoKTtcblxuICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbmZpZ1BhcnNlcih0ZXh0LCBrZXkpKSB7XG4gICAgICBpZiAoaXRlbS5rZXkgIT09IGtleSkge1xuICAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlcy5wdXNoKCh2YWx1ZSA9IGl0ZW0udmFsdWUpKTtcblxuICAgICAgaWYgKCFzY29wZXMuaGFzKGl0ZW0uZmlsZSkpIHtcbiAgICAgICAgIHNjb3Blcy5zZXQoaXRlbS5maWxlLCBbXSk7XG4gICAgICB9XG5cbiAgICAgIHNjb3Blcy5nZXQoaXRlbS5maWxlKSEucHVzaCh2YWx1ZSk7XG4gICB9XG5cbiAgIHJldHVybiB7XG4gICAgICBrZXksXG4gICAgICBwYXRoczogQXJyYXkuZnJvbShzY29wZXMua2V5cygpKSxcbiAgICAgIHNjb3BlcyxcbiAgICAgIHZhbHVlLFxuICAgICAgdmFsdWVzLFxuICAgfTtcbn1cblxuZnVuY3Rpb24gY29uZmlnRmlsZVBhdGgoZmlsZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICByZXR1cm4gZmlsZVBhdGgucmVwbGFjZSgvXihmaWxlKTovLCAnJyk7XG59XG5cbmZ1bmN0aW9uKiBjb25maWdQYXJzZXIodGV4dDogc3RyaW5nLCByZXF1ZXN0ZWRLZXk6IHN0cmluZyB8IG51bGwgPSBudWxsKSB7XG4gICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcMCcpO1xuXG4gICBmb3IgKGxldCBpID0gMCwgbWF4ID0gbGluZXMubGVuZ3RoIC0gMTsgaSA8IG1heDsgKSB7XG4gICAgICBjb25zdCBmaWxlID0gY29uZmlnRmlsZVBhdGgobGluZXNbaSsrXSk7XG5cbiAgICAgIGxldCB2YWx1ZSA9IGxpbmVzW2krK107XG4gICAgICBsZXQga2V5ID0gcmVxdWVzdGVkS2V5O1xuXG4gICAgICBpZiAodmFsdWUuaW5jbHVkZXMoJ1xcbicpKSB7XG4gICAgICAgICBjb25zdCBsaW5lID0gc3BsaXRPbih2YWx1ZSwgJ1xcbicpO1xuICAgICAgICAga2V5ID0gbGluZVswXTtcbiAgICAgICAgIHZhbHVlID0gbGluZVsxXTtcbiAgICAgIH1cblxuICAgICAgeWllbGQgeyBmaWxlLCBrZXksIHZhbHVlIH07XG4gICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBDb25maWdHZXRSZXN1bHQsIENvbmZpZ0xpc3RTdW1tYXJ5LCBTaW1wbGVHaXQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IGNvbmZpZ0dldFBhcnNlciwgY29uZmlnTGlzdFBhcnNlciB9IGZyb20gJy4uL3Jlc3BvbnNlcy9Db25maWdMaXN0JztcbmltcG9ydCB0eXBlIHsgU2ltcGxlR2l0QXBpIH0gZnJvbSAnLi4vc2ltcGxlLWdpdC1hcGknO1xuaW1wb3J0IHR5cGUgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50IH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZW51bSBHaXRDb25maWdTY29wZSB7XG4gICBzeXN0ZW0gPSAnc3lzdGVtJyxcbiAgIGdsb2JhbCA9ICdnbG9iYWwnLFxuICAgbG9jYWwgPSAnbG9jYWwnLFxuICAgd29ya3RyZWUgPSAnd29ya3RyZWUnLFxufVxuXG5mdW5jdGlvbiBhc0NvbmZpZ1Njb3BlPFQgZXh0ZW5kcyBHaXRDb25maWdTY29wZSB8IHVuZGVmaW5lZD4oXG4gICBzY29wZTogR2l0Q29uZmlnU2NvcGUgfCB1bmtub3duLFxuICAgZmFsbGJhY2s6IFRcbik6IEdpdENvbmZpZ1Njb3BlIHwgVCB7XG4gICBpZiAodHlwZW9mIHNjb3BlID09PSAnc3RyaW5nJyAmJiBHaXRDb25maWdTY29wZS5oYXNPd25Qcm9wZXJ0eShzY29wZSkpIHtcbiAgICAgIHJldHVybiBzY29wZSBhcyBHaXRDb25maWdTY29wZTtcbiAgIH1cbiAgIHJldHVybiBmYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gYWRkQ29uZmlnVGFzayhcbiAgIGtleTogc3RyaW5nLFxuICAgdmFsdWU6IHN0cmluZyxcbiAgIGFwcGVuZDogYm9vbGVhbixcbiAgIHNjb3BlOiBHaXRDb25maWdTY29wZVxuKTogU3RyaW5nVGFzazxzdHJpbmc+IHtcbiAgIGNvbnN0IGNvbW1hbmRzOiBzdHJpbmdbXSA9IFsnY29uZmlnJywgYC0tJHtzY29wZX1gXTtcblxuICAgaWYgKGFwcGVuZCkge1xuICAgICAgY29tbWFuZHMucHVzaCgnLS1hZGQnKTtcbiAgIH1cblxuICAgY29tbWFuZHMucHVzaChrZXksIHZhbHVlKTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgcGFyc2VyKHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgIH0sXG4gICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb25maWdUYXNrKGtleTogc3RyaW5nLCBzY29wZT86IEdpdENvbmZpZ1Njb3BlKTogU3RyaW5nVGFzazxDb25maWdHZXRSZXN1bHQ+IHtcbiAgIGNvbnN0IGNvbW1hbmRzOiBzdHJpbmdbXSA9IFsnY29uZmlnJywgJy0tbnVsbCcsICctLXNob3ctb3JpZ2luJywgJy0tZ2V0LWFsbCcsIGtleV07XG5cbiAgIGlmIChzY29wZSkge1xuICAgICAgY29tbWFuZHMuc3BsaWNlKDEsIDAsIGAtLSR7c2NvcGV9YCk7XG4gICB9XG5cbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kcyxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcih0ZXh0KSB7XG4gICAgICAgICByZXR1cm4gY29uZmlnR2V0UGFyc2VyKHRleHQsIGtleSk7XG4gICAgICB9LFxuICAgfTtcbn1cblxuZnVuY3Rpb24gbGlzdENvbmZpZ1Rhc2soc2NvcGU/OiBHaXRDb25maWdTY29wZSk6IFN0cmluZ1Rhc2s8Q29uZmlnTGlzdFN1bW1hcnk+IHtcbiAgIGNvbnN0IGNvbW1hbmRzID0gWydjb25maWcnLCAnLS1saXN0JywgJy0tc2hvdy1vcmlnaW4nLCAnLS1udWxsJ107XG5cbiAgIGlmIChzY29wZSkge1xuICAgICAgY29tbWFuZHMucHVzaChgLS0ke3Njb3BlfWApO1xuICAgfVxuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXIodGV4dDogc3RyaW5nKSB7XG4gICAgICAgICByZXR1cm4gY29uZmlnTGlzdFBhcnNlcih0ZXh0KTtcbiAgICAgIH0sXG4gICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKTogUGljazxTaW1wbGVHaXQsICdhZGRDb25maWcnIHwgJ2dldENvbmZpZycgfCAnbGlzdENvbmZpZyc+IHtcbiAgIHJldHVybiB7XG4gICAgICBhZGRDb25maWcodGhpczogU2ltcGxlR2l0QXBpLCBrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZywgLi4ucmVzdDogdW5rbm93bltdKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIGFkZENvbmZpZ1Rhc2soXG4gICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgIHJlc3RbMF0gPT09IHRydWUsXG4gICAgICAgICAgICAgICBhc0NvbmZpZ1Njb3BlKHJlc3RbMV0sIEdpdENvbmZpZ1Njb3BlLmxvY2FsKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICApO1xuICAgICAgfSxcblxuICAgICAgZ2V0Q29uZmlnKHRoaXM6IFNpbXBsZUdpdEFwaSwga2V5OiBzdHJpbmcsIHNjb3BlPzogR2l0Q29uZmlnU2NvcGUpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgICAgZ2V0Q29uZmlnVGFzayhrZXksIGFzQ29uZmlnU2NvcGUoc2NvcGUsIHVuZGVmaW5lZCkpLFxuICAgICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICAgICk7XG4gICAgICB9LFxuXG4gICAgICBsaXN0Q29uZmlnKHRoaXM6IFNpbXBsZUdpdEFwaSwgLi4ucmVzdDogdW5rbm93bltdKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIGxpc3RDb25maWdUYXNrKGFzQ29uZmlnU2NvcGUocmVzdFswXSwgdW5kZWZpbmVkKSksXG4gICAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgICAgKTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImV4cG9ydCBlbnVtIERpZmZOYW1lU3RhdHVzIHtcbiAgIEFEREVEID0gJ0EnLFxuICAgQ09QSUVEID0gJ0MnLFxuICAgREVMRVRFRCA9ICdEJyxcbiAgIE1PRElGSUVEID0gJ00nLFxuICAgUkVOQU1FRCA9ICdSJyxcbiAgIENIQU5HRUQgPSAnVCcsXG4gICBVTk1FUkdFRCA9ICdVJyxcbiAgIFVOS05PV04gPSAnWCcsXG4gICBCUk9LRU4gPSAnQicsXG59XG5cbmNvbnN0IGRpZmZOYW1lU3RhdHVzID0gbmV3IFNldChPYmplY3QudmFsdWVzKERpZmZOYW1lU3RhdHVzKSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RpZmZOYW1lU3RhdHVzKGlucHV0OiBzdHJpbmcpOiBpbnB1dCBpcyBEaWZmTmFtZVN0YXR1cyB7XG4gICByZXR1cm4gZGlmZk5hbWVTdGF0dXMuaGFzKGlucHV0IGFzIERpZmZOYW1lU3RhdHVzKTtcbn1cbiIsICJpbXBvcnQgeyBHcmVwUmVzdWx0LCBTaW1wbGVHaXQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IFNpbXBsZUdpdEFwaSB9IGZyb20gJy4uL3NpbXBsZS1naXQtYXBpJztcbmltcG9ydCB7XG4gICBhc051bWJlcixcbiAgIGZvckVhY2hMaW5lV2l0aENvbnRlbnQsXG4gICBnZXRUcmFpbGluZ09wdGlvbnMsXG4gICBOVUxMLFxuICAgcHJlZml4ZWRBcnJheSxcbiAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudCxcbn0gZnJvbSAnLi4vdXRpbHMnO1xuXG5pbXBvcnQgeyBjb25maWd1cmF0aW9uRXJyb3JUYXNrIH0gZnJvbSAnLi90YXNrJztcblxuY29uc3QgZGlzYWxsb3dlZE9wdGlvbnMgPSBbJy1oJ107XG5cbmNvbnN0IFF1ZXJ5ID0gU3ltYm9sKCdncmVwUXVlcnknKTtcblxuZXhwb3J0IGludGVyZmFjZSBHaXRHcmVwUXVlcnkgZXh0ZW5kcyBJdGVyYWJsZTxzdHJpbmc+IHtcbiAgIC8qKiBBZGRzIG9uZSBvciBtb3JlIHRlcm1zIHRvIGJlIGdyb3VwZWQgYXMgYW4gXCJhbmRcIiB0byBhbnkgb3RoZXIgdGVybXMgKi9cbiAgIGFuZCguLi5hbmQ6IHN0cmluZ1tdKTogdGhpcztcblxuICAgLyoqIEFkZHMgb25lIG9yIG1vcmUgc2VhcmNoIHRlcm1zIC0gZ2l0LmdyZXAgd2lsbCBcIm9yXCIgdGhpcyB0byBvdGhlciB0ZXJtcyAqL1xuICAgcGFyYW0oLi4ucGFyYW06IHN0cmluZ1tdKTogdGhpcztcbn1cblxuY2xhc3MgR3JlcFF1ZXJ5IGltcGxlbWVudHMgR2l0R3JlcFF1ZXJ5IHtcbiAgIHByaXZhdGUgW1F1ZXJ5XTogc3RyaW5nW10gPSBbXTtcblxuICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgZm9yIChjb25zdCBxdWVyeSBvZiB0aGlzW1F1ZXJ5XSkge1xuICAgICAgICAgeWllbGQgcXVlcnk7XG4gICAgICB9XG4gICB9XG5cbiAgIGFuZCguLi5hbmQ6IHN0cmluZ1tdKSB7XG4gICAgICBhbmQubGVuZ3RoICYmIHRoaXNbUXVlcnldLnB1c2goJy0tYW5kJywgJygnLCAuLi5wcmVmaXhlZEFycmF5KGFuZCwgJy1lJyksICcpJyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgIH1cblxuICAgcGFyYW0oLi4ucGFyYW06IHN0cmluZ1tdKSB7XG4gICAgICB0aGlzW1F1ZXJ5XS5wdXNoKC4uLnByZWZpeGVkQXJyYXkocGFyYW0sICctZScpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYnVpbGRlciBmb3IgYSBgZ2l0LmdyZXBgIHF1ZXJ5IHdpdGggb3B0aW9uYWwgcGFyYW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBncmVwUXVlcnlCdWlsZGVyKC4uLnBhcmFtczogc3RyaW5nW10pOiBHaXRHcmVwUXVlcnkge1xuICAgcmV0dXJuIG5ldyBHcmVwUXVlcnkoKS5wYXJhbSguLi5wYXJhbXMpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUdyZXAoZ3JlcDogc3RyaW5nKTogR3JlcFJlc3VsdCB7XG4gICBjb25zdCBwYXRoczogR3JlcFJlc3VsdFsncGF0aHMnXSA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgY29uc3QgcmVzdWx0czogR3JlcFJlc3VsdFsncmVzdWx0cyddID0ge307XG5cbiAgIGZvckVhY2hMaW5lV2l0aENvbnRlbnQoZ3JlcCwgKGlucHV0KSA9PiB7XG4gICAgICBjb25zdCBbcGF0aCwgbGluZSwgcHJldmlld10gPSBpbnB1dC5zcGxpdChOVUxMKTtcbiAgICAgIHBhdGhzLmFkZChwYXRoKTtcbiAgICAgIChyZXN1bHRzW3BhdGhdID0gcmVzdWx0c1twYXRoXSB8fCBbXSkucHVzaCh7XG4gICAgICAgICBsaW5lOiBhc051bWJlcihsaW5lKSxcbiAgICAgICAgIHBhdGgsXG4gICAgICAgICBwcmV2aWV3LFxuICAgICAgfSk7XG4gICB9KTtcblxuICAgcmV0dXJuIHtcbiAgICAgIHBhdGhzLFxuICAgICAgcmVzdWx0cyxcbiAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpOiBQaWNrPFNpbXBsZUdpdCwgJ2dyZXAnPiB7XG4gICByZXR1cm4ge1xuICAgICAgZ3JlcCh0aGlzOiBTaW1wbGVHaXRBcGksIHNlYXJjaFRlcm06IHN0cmluZyB8IEdpdEdyZXBRdWVyeSkge1xuICAgICAgICAgY29uc3QgdGhlbiA9IHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpO1xuICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpO1xuXG4gICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBkaXNhbGxvd2VkT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZXMob3B0aW9uKSkge1xuICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uRXJyb3JUYXNrKGBnaXQuZ3JlcDogdXNlIG9mIFwiJHtvcHRpb259XCIgaXMgbm90IHN1cHBvcnRlZC5gKSxcbiAgICAgICAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoVGVybSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNlYXJjaFRlcm0gPSBncmVwUXVlcnlCdWlsZGVyKCkucGFyYW0oc2VhcmNoVGVybSk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGNvbnN0IGNvbW1hbmRzID0gWydncmVwJywgJy0tbnVsbCcsICctbicsICctLWZ1bGwtbmFtZScsIC4uLm9wdGlvbnMsIC4uLnNlYXJjaFRlcm1dO1xuXG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgIGNvbW1hbmRzLFxuICAgICAgICAgICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgICAgICAgICAgcGFyc2VyKHN0ZE91dCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlR3JlcChzdGRPdXQpO1xuICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGVuXG4gICAgICAgICApO1xuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5pbXBvcnQgeyBNYXliZSwgT3B0aW9uRmxhZ3MsIE9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBlbnVtIFJlc2V0TW9kZSB7XG4gICBNSVhFRCA9ICdtaXhlZCcsXG4gICBTT0ZUID0gJ3NvZnQnLFxuICAgSEFSRCA9ICdoYXJkJyxcbiAgIE1FUkdFID0gJ21lcmdlJyxcbiAgIEtFRVAgPSAna2VlcCcsXG59XG5cbmNvbnN0IFJlc2V0TW9kZXMgPSBBcnJheS5mcm9tKE9iamVjdC52YWx1ZXMoUmVzZXRNb2RlKSk7XG5cbmV4cG9ydCB0eXBlIFJlc2V0T3B0aW9ucyA9IE9wdGlvbnMgJlxuICAgT3B0aW9uRmxhZ3M8Jy1xJyB8ICctLXF1aWV0JyB8ICctLW5vLXF1aWV0JyB8ICctLXBhdGhzcGVjLWZyb20tbnVsJz4gJlxuICAgT3B0aW9uRmxhZ3M8Jy0tcGF0aHNwZWMtZnJvbS1maWxlJywgc3RyaW5nPjtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0VGFzayhtb2RlOiBNYXliZTxSZXNldE1vZGU+LCBjdXN0b21BcmdzOiBzdHJpbmdbXSkge1xuICAgY29uc3QgY29tbWFuZHM6IHN0cmluZ1tdID0gWydyZXNldCddO1xuICAgaWYgKGlzVmFsaWRSZXNldE1vZGUobW9kZSkpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goYC0tJHttb2RlfWApO1xuICAgfVxuICAgY29tbWFuZHMucHVzaCguLi5jdXN0b21BcmdzKTtcblxuICAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVzZXRNb2RlKG1vZGU6IFJlc2V0TW9kZSB8IGFueSk6IE1heWJlPFJlc2V0TW9kZT4ge1xuICAgaWYgKGlzVmFsaWRSZXNldE1vZGUobW9kZSkpIHtcbiAgICAgIHJldHVybiBtb2RlO1xuICAgfVxuXG4gICBzd2l0Y2ggKHR5cGVvZiBtb2RlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgIHJldHVybiBSZXNldE1vZGUuU09GVDtcbiAgIH1cblxuICAgcmV0dXJuO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkUmVzZXRNb2RlKG1vZGU6IFJlc2V0TW9kZSB8IGFueSk6IG1vZGUgaXMgUmVzZXRNb2RlIHtcbiAgIHJldHVybiBSZXNldE1vZGVzLmluY2x1ZGVzKG1vZGUpO1xufVxuIiwgImltcG9ydCBkZWJ1ZywgeyBEZWJ1Z2dlciB9IGZyb20gJ2RlYnVnJztcbmltcG9ydCB7XG4gICBhcHBlbmQsXG4gICBmaWx0ZXJIYXNMZW5ndGgsXG4gICBmaWx0ZXJTdHJpbmcsXG4gICBmaWx0ZXJUeXBlLFxuICAgTk9PUCxcbiAgIG9iamVjdFRvU3RyaW5nLFxuICAgcmVtb3ZlLFxufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IE1heWJlIH0gZnJvbSAnLi90eXBlcyc7XG5cbmRlYnVnLmZvcm1hdHRlcnMuTCA9ICh2YWx1ZTogYW55KSA9PiBTdHJpbmcoZmlsdGVySGFzTGVuZ3RoKHZhbHVlKSA/IHZhbHVlLmxlbmd0aCA6ICctJyk7XG5kZWJ1Zy5mb3JtYXR0ZXJzLkIgPSAodmFsdWU6IEJ1ZmZlcikgPT4ge1xuICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygndXRmOCcpO1xuICAgfVxuICAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn07XG5cbnR5cGUgT3V0cHV0TG9nZ2luZ0hhbmRsZXIgPSAobWVzc2FnZTogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZDtcblxuZnVuY3Rpb24gY3JlYXRlTG9nKCkge1xuICAgcmV0dXJuIGRlYnVnKCdzaW1wbGUtZ2l0Jyk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3V0cHV0TG9nZ2VyIGV4dGVuZHMgT3V0cHV0TG9nZ2luZ0hhbmRsZXIge1xuICAgcmVhZG9ubHkgbGFiZWw6IHN0cmluZztcblxuICAgaW5mbzogT3V0cHV0TG9nZ2luZ0hhbmRsZXI7XG4gICBzdGVwKG5leHRTdGVwPzogc3RyaW5nKTogT3V0cHV0TG9nZ2VyO1xuICAgc2libGluZyhuYW1lOiBzdHJpbmcpOiBPdXRwdXRMb2dnZXI7XG59XG5cbmZ1bmN0aW9uIHByZWZpeGVkTG9nZ2VyKFxuICAgdG86IERlYnVnZ2VyLFxuICAgcHJlZml4OiBzdHJpbmcsXG4gICBmb3J3YXJkPzogT3V0cHV0TG9nZ2luZ0hhbmRsZXJcbik6IE91dHB1dExvZ2dpbmdIYW5kbGVyIHtcbiAgIGlmICghcHJlZml4IHx8ICFTdHJpbmcocHJlZml4KS5yZXBsYWNlKC9cXHMqLywgJycpKSB7XG4gICAgICByZXR1cm4gIWZvcndhcmRcbiAgICAgICAgID8gdG9cbiAgICAgICAgIDogKG1lc3NhZ2UsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgdG8obWVzc2FnZSwgLi4uYXJncyk7XG4gICAgICAgICAgICAgIGZvcndhcmQobWVzc2FnZSwgLi4uYXJncyk7XG4gICAgICAgICAgIH07XG4gICB9XG5cbiAgIHJldHVybiAobWVzc2FnZSwgLi4uYXJncykgPT4ge1xuICAgICAgdG8oYCVzICR7bWVzc2FnZX1gLCBwcmVmaXgsIC4uLmFyZ3MpO1xuICAgICAgaWYgKGZvcndhcmQpIHtcbiAgICAgICAgIGZvcndhcmQobWVzc2FnZSwgLi4uYXJncyk7XG4gICAgICB9XG4gICB9O1xufVxuXG5mdW5jdGlvbiBjaGlsZExvZ2dlck5hbWUoXG4gICBuYW1lOiBNYXliZTxzdHJpbmc+LFxuICAgY2hpbGREZWJ1Z2dlcjogTWF5YmU8RGVidWdnZXI+LFxuICAgeyBuYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSB9OiBEZWJ1Z2dlclxuKTogc3RyaW5nIHtcbiAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgfVxuICAgY29uc3QgY2hpbGROYW1lc3BhY2UgPSAoY2hpbGREZWJ1Z2dlciAmJiBjaGlsZERlYnVnZ2VyLm5hbWVzcGFjZSkgfHwgJyc7XG5cbiAgIGlmIChjaGlsZE5hbWVzcGFjZS5zdGFydHNXaXRoKHBhcmVudE5hbWVzcGFjZSkpIHtcbiAgICAgIHJldHVybiBjaGlsZE5hbWVzcGFjZS5zdWJzdHIocGFyZW50TmFtZXNwYWNlLmxlbmd0aCArIDEpO1xuICAgfVxuXG4gICByZXR1cm4gY2hpbGROYW1lc3BhY2UgfHwgcGFyZW50TmFtZXNwYWNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTG9nZ2VyKFxuICAgbGFiZWw6IHN0cmluZyxcbiAgIHZlcmJvc2U/OiBzdHJpbmcgfCBEZWJ1Z2dlcixcbiAgIGluaXRpYWxTdGVwPzogc3RyaW5nLFxuICAgaW5mb0RlYnVnZ2VyID0gY3JlYXRlTG9nKClcbik6IE91dHB1dExvZ2dlciB7XG4gICBjb25zdCBsYWJlbFByZWZpeCA9IChsYWJlbCAmJiBgWyR7bGFiZWx9XWApIHx8ICcnO1xuXG4gICBjb25zdCBzcGF3bmVkOiBPdXRwdXRMb2dnZXJbXSA9IFtdO1xuICAgY29uc3QgZGVidWdEZWJ1Z2dlcjogTWF5YmU8RGVidWdnZXI+ID1cbiAgICAgIHR5cGVvZiB2ZXJib3NlID09PSAnc3RyaW5nJyA/IGluZm9EZWJ1Z2dlci5leHRlbmQodmVyYm9zZSkgOiB2ZXJib3NlO1xuICAgY29uc3Qga2V5ID0gY2hpbGRMb2dnZXJOYW1lKGZpbHRlclR5cGUodmVyYm9zZSwgZmlsdGVyU3RyaW5nKSwgZGVidWdEZWJ1Z2dlciwgaW5mb0RlYnVnZ2VyKTtcblxuICAgcmV0dXJuIHN0ZXAoaW5pdGlhbFN0ZXApO1xuXG4gICBmdW5jdGlvbiBzaWJsaW5nKG5hbWU6IHN0cmluZywgaW5pdGlhbD86IHN0cmluZykge1xuICAgICAgcmV0dXJuIGFwcGVuZChcbiAgICAgICAgIHNwYXduZWQsXG4gICAgICAgICBjcmVhdGVMb2dnZXIobGFiZWwsIGtleS5yZXBsYWNlKC9eW146XSsvLCBuYW1lKSwgaW5pdGlhbCwgaW5mb0RlYnVnZ2VyKVxuICAgICAgKTtcbiAgIH1cblxuICAgZnVuY3Rpb24gc3RlcChwaGFzZT86IHN0cmluZykge1xuICAgICAgY29uc3Qgc3RlcFByZWZpeCA9IChwaGFzZSAmJiBgWyR7cGhhc2V9XWApIHx8ICcnO1xuICAgICAgY29uc3QgZGVidWcgPSAoZGVidWdEZWJ1Z2dlciAmJiBwcmVmaXhlZExvZ2dlcihkZWJ1Z0RlYnVnZ2VyLCBzdGVwUHJlZml4KSkgfHwgTk9PUDtcbiAgICAgIGNvbnN0IGluZm8gPSBwcmVmaXhlZExvZ2dlcihpbmZvRGVidWdnZXIsIGAke2xhYmVsUHJlZml4fSAke3N0ZXBQcmVmaXh9YCwgZGVidWcpO1xuXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkZWJ1Z0RlYnVnZ2VyID8gZGVidWcgOiBpbmZvLCB7XG4gICAgICAgICBsYWJlbCxcbiAgICAgICAgIHNpYmxpbmcsXG4gICAgICAgICBpbmZvLFxuICAgICAgICAgc3RlcCxcbiAgICAgIH0pO1xuICAgfVxufVxuXG4vKipcbiAqIFRoZSBgR2l0TG9nZ2VyYCBpcyB1c2VkIGJ5IHRoZSBtYWluIGBTaW1wbGVHaXRgIHJ1bm5lciB0byBoYW5kbGUgbG9nZ2luZ1xuICogYW55IHdhcm5pbmdzIG9yIGVycm9ycy5cbiAqL1xuZXhwb3J0IGNsYXNzIEdpdExvZ2dlciB7XG4gICBwdWJsaWMgZXJyb3I6IE91dHB1dExvZ2dpbmdIYW5kbGVyO1xuXG4gICBwdWJsaWMgd2FybjogT3V0cHV0TG9nZ2luZ0hhbmRsZXI7XG5cbiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX291dDogRGVidWdnZXIgPSBjcmVhdGVMb2coKSkge1xuICAgICAgdGhpcy5lcnJvciA9IHByZWZpeGVkTG9nZ2VyKF9vdXQsICdbRVJST1JdJyk7XG4gICAgICB0aGlzLndhcm4gPSBwcmVmaXhlZExvZ2dlcihfb3V0LCAnW1dBUk5dJyk7XG4gICB9XG5cbiAgIHNpbGVudChzaWxlbmNlID0gZmFsc2UpIHtcbiAgICAgIGlmIChzaWxlbmNlICE9PSB0aGlzLl9vdXQuZW5hYmxlZCkge1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7IG5hbWVzcGFjZSB9ID0gdGhpcy5fb3V0O1xuICAgICAgY29uc3QgZW52ID0gKHByb2Nlc3MuZW52LkRFQlVHIHx8ICcnKS5zcGxpdCgnLCcpLmZpbHRlcigocykgPT4gISFzKTtcbiAgICAgIGNvbnN0IGhhc09uID0gZW52LmluY2x1ZGVzKG5hbWVzcGFjZSk7XG4gICAgICBjb25zdCBoYXNPZmYgPSBlbnYuaW5jbHVkZXMoYC0ke25hbWVzcGFjZX1gKTtcblxuICAgICAgLy8gZW5hYmxpbmcgdGhlIGxvZ1xuICAgICAgaWYgKCFzaWxlbmNlKSB7XG4gICAgICAgICBpZiAoaGFzT2ZmKSB7XG4gICAgICAgICAgICByZW1vdmUoZW52LCBgLSR7bmFtZXNwYWNlfWApO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVudi5wdXNoKG5hbWVzcGFjZSk7XG4gICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgaWYgKGhhc09uKSB7XG4gICAgICAgICAgICByZW1vdmUoZW52LCBuYW1lc3BhY2UpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVudi5wdXNoKGAtJHtuYW1lc3BhY2V9YCk7XG4gICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRlYnVnLmVuYWJsZShlbnYuam9pbignLCcpKTtcbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBTaW1wbGVHaXRUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgR2l0RXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZ2l0LWVycm9yJztcbmltcG9ydCB7IGNyZWF0ZUxvZ2dlciwgT3V0cHV0TG9nZ2VyIH0gZnJvbSAnLi4vZ2l0LWxvZ2dlcic7XG5cbnR5cGUgQW55U2ltcGxlR2l0VGFzayA9IFNpbXBsZUdpdFRhc2s8YW55PjtcblxudHlwZSBUYXNrSW5Qcm9ncmVzcyA9IHtcbiAgIG5hbWU6IHN0cmluZztcbiAgIGxvZ2dlcjogT3V0cHV0TG9nZ2VyO1xuICAgdGFzazogQW55U2ltcGxlR2l0VGFzaztcbn07XG5cbmV4cG9ydCBjbGFzcyBUYXNrc1BlbmRpbmdRdWV1ZSB7XG4gICBwcml2YXRlIF9xdWV1ZTogTWFwPEFueVNpbXBsZUdpdFRhc2ssIFRhc2tJblByb2dyZXNzPiA9IG5ldyBNYXAoKTtcblxuICAgY29uc3RydWN0b3IocHJpdmF0ZSBsb2dMYWJlbCA9ICdHaXRFeGVjdXRvcicpIHt9XG5cbiAgIHByaXZhdGUgd2l0aFByb2dyZXNzKHRhc2s6IEFueVNpbXBsZUdpdFRhc2spIHtcbiAgICAgIHJldHVybiB0aGlzLl9xdWV1ZS5nZXQodGFzayk7XG4gICB9XG5cbiAgIHByaXZhdGUgY3JlYXRlUHJvZ3Jlc3ModGFzazogQW55U2ltcGxlR2l0VGFzayk6IFRhc2tJblByb2dyZXNzIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBUYXNrc1BlbmRpbmdRdWV1ZS5nZXROYW1lKHRhc2suY29tbWFuZHNbMF0pO1xuICAgICAgY29uc3QgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKHRoaXMubG9nTGFiZWwsIG5hbWUpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgdGFzayxcbiAgICAgICAgIGxvZ2dlcixcbiAgICAgICAgIG5hbWUsXG4gICAgICB9O1xuICAgfVxuXG4gICBwdXNoKHRhc2s6IEFueVNpbXBsZUdpdFRhc2spOiBUYXNrSW5Qcm9ncmVzcyB7XG4gICAgICBjb25zdCBwcm9ncmVzcyA9IHRoaXMuY3JlYXRlUHJvZ3Jlc3ModGFzayk7XG4gICAgICBwcm9ncmVzcy5sb2dnZXIoJ0FkZGluZyB0YXNrIHRvIHRoZSBxdWV1ZSwgY29tbWFuZHMgPSAlbycsIHRhc2suY29tbWFuZHMpO1xuXG4gICAgICB0aGlzLl9xdWV1ZS5zZXQodGFzaywgcHJvZ3Jlc3MpO1xuXG4gICAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gICB9XG5cbiAgIGZhdGFsKGVycjogR2l0RXJyb3IpIHtcbiAgICAgIGZvciAoY29uc3QgW3Rhc2ssIHsgbG9nZ2VyIH1dIG9mIEFycmF5LmZyb20odGhpcy5fcXVldWUuZW50cmllcygpKSkge1xuICAgICAgICAgaWYgKHRhc2sgPT09IGVyci50YXNrKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgRmFpbGVkICVvYCwgZXJyKTtcbiAgICAgICAgICAgIGxvZ2dlcihcbiAgICAgICAgICAgICAgIGBGYXRhbCBleGNlcHRpb24sIGFueSBhcy15ZXQgdW4tc3RhcnRlZCB0YXNrcyBydW4gdGhyb3VnaCB0aGlzIGV4ZWN1dG9yIHdpbGwgbm90IGJlIGF0dGVtcHRlZGBcbiAgICAgICAgICAgICk7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICBgQSBmYXRhbCBleGNlcHRpb24gb2NjdXJyZWQgaW4gYSBwcmV2aW91cyB0YXNrLCB0aGUgcXVldWUgaGFzIGJlZW4gcHVyZ2VkOiAlb2AsXG4gICAgICAgICAgICAgICBlcnIubWVzc2FnZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgdGhpcy5jb21wbGV0ZSh0YXNrKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3F1ZXVlLnNpemUgIT09IDApIHtcbiAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUXVldWUgc2l6ZSBzaG91bGQgYmUgemVybyBhZnRlciBmYXRhbDogJHt0aGlzLl9xdWV1ZS5zaXplfWApO1xuICAgICAgfVxuICAgfVxuXG4gICBjb21wbGV0ZSh0YXNrOiBBbnlTaW1wbGVHaXRUYXNrKSB7XG4gICAgICBjb25zdCBwcm9ncmVzcyA9IHRoaXMud2l0aFByb2dyZXNzKHRhc2spO1xuICAgICAgaWYgKHByb2dyZXNzKSB7XG4gICAgICAgICB0aGlzLl9xdWV1ZS5kZWxldGUodGFzayk7XG4gICAgICB9XG4gICB9XG5cbiAgIGF0dGVtcHQodGFzazogQW55U2ltcGxlR2l0VGFzayk6IFRhc2tJblByb2dyZXNzIHtcbiAgICAgIGNvbnN0IHByb2dyZXNzID0gdGhpcy53aXRoUHJvZ3Jlc3ModGFzayk7XG4gICAgICBpZiAoIXByb2dyZXNzKSB7XG4gICAgICAgICB0aHJvdyBuZXcgR2l0RXJyb3IodW5kZWZpbmVkLCAnVGFza3NQZW5kaW5nUXVldWU6IGF0dGVtcHQgY2FsbGVkIGZvciBhbiB1bmtub3duIHRhc2snKTtcbiAgICAgIH1cbiAgICAgIHByb2dyZXNzLmxvZ2dlcignU3RhcnRpbmcgdGFzaycpO1xuXG4gICAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gICB9XG5cbiAgIHN0YXRpYyBnZXROYW1lKG5hbWUgPSAnZW1wdHknKSB7XG4gICAgICByZXR1cm4gYHRhc2s6JHtuYW1lfTokeysrVGFza3NQZW5kaW5nUXVldWUuY291bnRlcn1gO1xuICAgfVxuXG4gICBwcml2YXRlIHN0YXRpYyBjb3VudGVyID0gMDtcbn1cbiIsICJpbXBvcnQgeyBzcGF3biwgU3Bhd25PcHRpb25zIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgeyBHaXRFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9naXQtZXJyb3InO1xuaW1wb3J0IHsgT3V0cHV0TG9nZ2VyIH0gZnJvbSAnLi4vZ2l0LWxvZ2dlcic7XG5pbXBvcnQgeyBQbHVnaW5TdG9yZSB9IGZyb20gJy4uL3BsdWdpbnMnO1xuaW1wb3J0IHsgRW1wdHlUYXNrLCBpc0J1ZmZlclRhc2ssIGlzRW1wdHlUYXNrIH0gZnJvbSAnLi4vdGFza3MvdGFzayc7XG5pbXBvcnQge1xuICAgR2l0RXhlY3V0b3JSZXN1bHQsXG4gICBNYXliZSxcbiAgIG91dHB1dEhhbmRsZXIsXG4gICBSdW5uYWJsZVRhc2ssXG4gICBTaW1wbGVHaXRFeGVjdXRvcixcbiAgIFNpbXBsZUdpdFRhc2ssXG59IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGNhbGxUYXNrUGFyc2VyLCBmaXJzdCwgR2l0T3V0cHV0U3RyZWFtcywgb2JqZWN0VG9TdHJpbmcgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBTY2hlZHVsZXIgfSBmcm9tICcuL3NjaGVkdWxlcic7XG5pbXBvcnQgeyBUYXNrc1BlbmRpbmdRdWV1ZSB9IGZyb20gJy4vdGFza3MtcGVuZGluZy1xdWV1ZSc7XG5cbmV4cG9ydCBjbGFzcyBHaXRFeGVjdXRvckNoYWluIGltcGxlbWVudHMgU2ltcGxlR2l0RXhlY3V0b3Ige1xuICAgcHJpdmF0ZSBfY2hhaW46IFByb21pc2U8YW55PiA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgcHJpdmF0ZSBfcXVldWUgPSBuZXcgVGFza3NQZW5kaW5nUXVldWUoKTtcbiAgIHByaXZhdGUgX2N3ZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gICBwdWJsaWMgZ2V0IGJpbmFyeSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9leGVjdXRvci5iaW5hcnk7XG4gICB9XG5cbiAgIHB1YmxpYyBnZXQgY3dkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2N3ZCB8fCB0aGlzLl9leGVjdXRvci5jd2Q7XG4gICB9XG5cbiAgIHB1YmxpYyBzZXQgY3dkKGN3ZDogc3RyaW5nKSB7XG4gICAgICB0aGlzLl9jd2QgPSBjd2Q7XG4gICB9XG5cbiAgIHB1YmxpYyBnZXQgZW52KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2V4ZWN1dG9yLmVudjtcbiAgIH1cblxuICAgcHVibGljIGdldCBvdXRwdXRIYW5kbGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2V4ZWN1dG9yLm91dHB1dEhhbmRsZXI7XG4gICB9XG5cbiAgIGNvbnN0cnVjdG9yKFxuICAgICAgcHJpdmF0ZSBfZXhlY3V0b3I6IFNpbXBsZUdpdEV4ZWN1dG9yLFxuICAgICAgcHJpdmF0ZSBfc2NoZWR1bGVyOiBTY2hlZHVsZXIsXG4gICAgICBwcml2YXRlIF9wbHVnaW5zOiBQbHVnaW5TdG9yZVxuICAgKSB7fVxuXG4gICBwdWJsaWMgY2hhaW4oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgIH1cblxuICAgcHVibGljIHB1c2g8Uj4odGFzazogU2ltcGxlR2l0VGFzazxSPik6IFByb21pc2U8Uj4ge1xuICAgICAgdGhpcy5fcXVldWUucHVzaCh0YXNrKTtcblxuICAgICAgcmV0dXJuICh0aGlzLl9jaGFpbiA9IHRoaXMuX2NoYWluLnRoZW4oKCkgPT4gdGhpcy5hdHRlbXB0VGFzayh0YXNrKSkpO1xuICAgfVxuXG4gICBwcml2YXRlIGFzeW5jIGF0dGVtcHRUYXNrPFI+KHRhc2s6IFNpbXBsZUdpdFRhc2s8Uj4pOiBQcm9taXNlPHZvaWQgfCBSPiB7XG4gICAgICBjb25zdCBvblNjaGVkdWxlQ29tcGxldGUgPSBhd2FpdCB0aGlzLl9zY2hlZHVsZXIubmV4dCgpO1xuICAgICAgY29uc3Qgb25RdWV1ZUNvbXBsZXRlID0gKCkgPT4gdGhpcy5fcXVldWUuY29tcGxldGUodGFzayk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgICBjb25zdCB7IGxvZ2dlciB9ID0gdGhpcy5fcXVldWUuYXR0ZW1wdCh0YXNrKTtcbiAgICAgICAgIHJldHVybiAoYXdhaXQgKGlzRW1wdHlUYXNrKHRhc2spXG4gICAgICAgICAgICA/IHRoaXMuYXR0ZW1wdEVtcHR5VGFzayh0YXNrLCBsb2dnZXIpXG4gICAgICAgICAgICA6IHRoaXMuYXR0ZW1wdFJlbW90ZVRhc2sodGFzaywgbG9nZ2VyKSkpIGFzIFI7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICB0aHJvdyB0aGlzLm9uRmF0YWxFeGNlcHRpb24odGFzaywgZSBhcyBFcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgb25RdWV1ZUNvbXBsZXRlKCk7XG4gICAgICAgICBvblNjaGVkdWxlQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgIH1cblxuICAgcHJpdmF0ZSBvbkZhdGFsRXhjZXB0aW9uPFI+KHRhc2s6IFNpbXBsZUdpdFRhc2s8Uj4sIGU6IEVycm9yKSB7XG4gICAgICBjb25zdCBnaXRFcnJvciA9XG4gICAgICAgICBlIGluc3RhbmNlb2YgR2l0RXJyb3IgPyBPYmplY3QuYXNzaWduKGUsIHsgdGFzayB9KSA6IG5ldyBHaXRFcnJvcih0YXNrLCBlICYmIFN0cmluZyhlKSk7XG5cbiAgICAgIHRoaXMuX2NoYWluID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB0aGlzLl9xdWV1ZS5mYXRhbChnaXRFcnJvcik7XG5cbiAgICAgIHJldHVybiBnaXRFcnJvcjtcbiAgIH1cblxuICAgcHJpdmF0ZSBhc3luYyBhdHRlbXB0UmVtb3RlVGFzazxSPih0YXNrOiBSdW5uYWJsZVRhc2s8Uj4sIGxvZ2dlcjogT3V0cHV0TG9nZ2VyKSB7XG4gICAgICBjb25zdCBhcmdzID0gdGhpcy5fcGx1Z2lucy5leGVjKFxuICAgICAgICAgJ3NwYXduLmFyZ3MnLFxuICAgICAgICAgWy4uLnRhc2suY29tbWFuZHNdLFxuICAgICAgICAgcGx1Z2luQ29udGV4dCh0YXNrLCB0YXNrLmNvbW1hbmRzKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgcmF3ID0gYXdhaXQgdGhpcy5naXRSZXNwb25zZShcbiAgICAgICAgIHRhc2ssXG4gICAgICAgICB0aGlzLmJpbmFyeSxcbiAgICAgICAgIGFyZ3MsXG4gICAgICAgICB0aGlzLm91dHB1dEhhbmRsZXIsXG4gICAgICAgICBsb2dnZXIuc3RlcCgnU1BBV04nKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IG91dHB1dFN0cmVhbXMgPSBhd2FpdCB0aGlzLmhhbmRsZVRhc2tEYXRhKHRhc2ssIGFyZ3MsIHJhdywgbG9nZ2VyLnN0ZXAoJ0hBTkRMRScpKTtcblxuICAgICAgbG9nZ2VyKGBwYXNzaW5nIHJlc3BvbnNlIHRvIHRhc2sncyBwYXJzZXIgYXMgYSAlc2AsIHRhc2suZm9ybWF0KTtcblxuICAgICAgaWYgKGlzQnVmZmVyVGFzayh0YXNrKSkge1xuICAgICAgICAgcmV0dXJuIGNhbGxUYXNrUGFyc2VyKHRhc2sucGFyc2VyLCBvdXRwdXRTdHJlYW1zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhbGxUYXNrUGFyc2VyKHRhc2sucGFyc2VyLCBvdXRwdXRTdHJlYW1zLmFzU3RyaW5ncygpKTtcbiAgIH1cblxuICAgcHJpdmF0ZSBhc3luYyBhdHRlbXB0RW1wdHlUYXNrKHRhc2s6IEVtcHR5VGFzaywgbG9nZ2VyOiBPdXRwdXRMb2dnZXIpIHtcbiAgICAgIGxvZ2dlcihgZW1wdHkgdGFzayBieXBhc3NpbmcgY2hpbGQgcHJvY2VzcyB0byBjYWxsIHRvIHRhc2sncyBwYXJzZXJgKTtcbiAgICAgIHJldHVybiB0YXNrLnBhcnNlcih0aGlzKTtcbiAgIH1cblxuICAgcHJpdmF0ZSBoYW5kbGVUYXNrRGF0YTxSPihcbiAgICAgIHRhc2s6IFNpbXBsZUdpdFRhc2s8Uj4sXG4gICAgICBhcmdzOiBzdHJpbmdbXSxcbiAgICAgIHJlc3VsdDogR2l0RXhlY3V0b3JSZXN1bHQsXG4gICAgICBsb2dnZXI6IE91dHB1dExvZ2dlclxuICAgKTogUHJvbWlzZTxHaXRPdXRwdXRTdHJlYW1zPiB7XG4gICAgICBjb25zdCB7IGV4aXRDb2RlLCByZWplY3Rpb24sIHN0ZE91dCwgc3RkRXJyIH0gPSByZXN1bHQ7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoZG9uZSwgZmFpbCkgPT4ge1xuICAgICAgICAgbG9nZ2VyKGBQcmVwYXJpbmcgdG8gaGFuZGxlIHByb2Nlc3MgcmVzcG9uc2UgZXhpdENvZGU9JWQgc3RkT3V0PWAsIGV4aXRDb2RlKTtcblxuICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gdGhpcy5fcGx1Z2lucy5leGVjKFxuICAgICAgICAgICAgJ3Rhc2suZXJyb3InLFxuICAgICAgICAgICAgeyBlcnJvcjogcmVqZWN0aW9uIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAuLi5wbHVnaW5Db250ZXh0KHRhc2ssIGFyZ3MpLFxuICAgICAgICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICAgICAgfVxuICAgICAgICAgKTtcblxuICAgICAgICAgaWYgKGVycm9yICYmIHRhc2sub25FcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYGV4aXRDb2RlPSVzIGhhbmRsaW5nIHdpdGggY3VzdG9tIGVycm9yIGhhbmRsZXJgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRhc2sub25FcnJvcihcbiAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgKG5ld1N0ZE91dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oYGN1c3RvbSBlcnJvciBoYW5kbGVyIHRyZWF0ZWQgYXMgc3VjY2Vzc2ApO1xuICAgICAgICAgICAgICAgICAgbG9nZ2VyKGBjdXN0b20gZXJyb3IgcmV0dXJuZWQgYSAlc2AsIG9iamVjdFRvU3RyaW5nKG5ld1N0ZE91dCkpO1xuXG4gICAgICAgICAgICAgICAgICBkb25lKFxuICAgICAgICAgICAgICAgICAgICAgbmV3IEdpdE91dHB1dFN0cmVhbXMoXG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KG5ld1N0ZE91dCkgPyBCdWZmZXIuY29uY2F0KG5ld1N0ZE91dCkgOiBuZXdTdGRPdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBCdWZmZXIuY29uY2F0KHN0ZEVycilcbiAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgZmFpbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgICAgICAgIGBoYW5kbGluZyBhcyBlcnJvcjogZXhpdENvZGU9JXMgc3RkRXJyPSVzIHJlamVjdGlvbj0lb2AsXG4gICAgICAgICAgICAgICBleGl0Q29kZSxcbiAgICAgICAgICAgICAgIHN0ZEVyci5sZW5ndGgsXG4gICAgICAgICAgICAgICByZWplY3Rpb25cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gZmFpbChlcnJvcik7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGxvZ2dlci5pbmZvKGByZXRyaWV2aW5nIHRhc2sgb3V0cHV0IGNvbXBsZXRlYCk7XG4gICAgICAgICBkb25lKG5ldyBHaXRPdXRwdXRTdHJlYW1zKEJ1ZmZlci5jb25jYXQoc3RkT3V0KSwgQnVmZmVyLmNvbmNhdChzdGRFcnIpKSk7XG4gICAgICB9KTtcbiAgIH1cblxuICAgcHJpdmF0ZSBhc3luYyBnaXRSZXNwb25zZTxSPihcbiAgICAgIHRhc2s6IFNpbXBsZUdpdFRhc2s8Uj4sXG4gICAgICBjb21tYW5kOiBzdHJpbmcsXG4gICAgICBhcmdzOiBzdHJpbmdbXSxcbiAgICAgIG91dHB1dEhhbmRsZXI6IE1heWJlPG91dHB1dEhhbmRsZXI+LFxuICAgICAgbG9nZ2VyOiBPdXRwdXRMb2dnZXJcbiAgICk6IFByb21pc2U8R2l0RXhlY3V0b3JSZXN1bHQ+IHtcbiAgICAgIGNvbnN0IG91dHB1dExvZ2dlciA9IGxvZ2dlci5zaWJsaW5nKCdvdXRwdXQnKTtcbiAgICAgIGNvbnN0IHNwYXduT3B0aW9uczogU3Bhd25PcHRpb25zID0gdGhpcy5fcGx1Z2lucy5leGVjKFxuICAgICAgICAgJ3NwYXduLm9wdGlvbnMnLFxuICAgICAgICAge1xuICAgICAgICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgICAgICAgIGVudjogdGhpcy5lbnYsXG4gICAgICAgICAgICB3aW5kb3dzSGlkZTogdHJ1ZSxcbiAgICAgICAgIH0sXG4gICAgICAgICBwbHVnaW5Db250ZXh0KHRhc2ssIHRhc2suY29tbWFuZHMpXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKGRvbmUpID0+IHtcbiAgICAgICAgIGNvbnN0IHN0ZE91dDogQnVmZmVyW10gPSBbXTtcbiAgICAgICAgIGNvbnN0IHN0ZEVycjogQnVmZmVyW10gPSBbXTtcblxuICAgICAgICAgbG9nZ2VyLmluZm8oYCVzICVvYCwgY29tbWFuZCwgYXJncyk7XG4gICAgICAgICBsb2dnZXIoJyVPJywgc3Bhd25PcHRpb25zKTtcblxuICAgICAgICAgbGV0IHJlamVjdGlvbiA9IHRoaXMuX2JlZm9yZVNwYXduKHRhc2ssIGFyZ3MpO1xuICAgICAgICAgaWYgKHJlamVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGRvbmUoe1xuICAgICAgICAgICAgICAgc3RkT3V0LFxuICAgICAgICAgICAgICAgc3RkRXJyLFxuICAgICAgICAgICAgICAgZXhpdENvZGU6IDk5MDEsXG4gICAgICAgICAgICAgICByZWplY3Rpb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgIH1cblxuICAgICAgICAgdGhpcy5fcGx1Z2lucy5leGVjKCdzcGF3bi5iZWZvcmUnLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgIC4uLnBsdWdpbkNvbnRleHQodGFzaywgYXJncyksXG4gICAgICAgICAgICBraWxsKHJlYXNvbikge1xuICAgICAgICAgICAgICAgcmVqZWN0aW9uID0gcmVhc29uIHx8IHJlamVjdGlvbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICB9KTtcblxuICAgICAgICAgY29uc3Qgc3Bhd25lZCA9IHNwYXduKGNvbW1hbmQsIGFyZ3MsIHNwYXduT3B0aW9ucyk7XG5cbiAgICAgICAgIHNwYXduZWQuc3Rkb3V0IS5vbihcbiAgICAgICAgICAgICdkYXRhJyxcbiAgICAgICAgICAgIG9uRGF0YVJlY2VpdmVkKHN0ZE91dCwgJ3N0ZE91dCcsIGxvZ2dlciwgb3V0cHV0TG9nZ2VyLnN0ZXAoJ3N0ZE91dCcpKVxuICAgICAgICAgKTtcbiAgICAgICAgIHNwYXduZWQuc3RkZXJyIS5vbihcbiAgICAgICAgICAgICdkYXRhJyxcbiAgICAgICAgICAgIG9uRGF0YVJlY2VpdmVkKHN0ZEVyciwgJ3N0ZEVycicsIGxvZ2dlciwgb3V0cHV0TG9nZ2VyLnN0ZXAoJ3N0ZEVycicpKVxuICAgICAgICAgKTtcblxuICAgICAgICAgc3Bhd25lZC5vbignZXJyb3InLCBvbkVycm9yUmVjZWl2ZWQoc3RkRXJyLCBsb2dnZXIpKTtcblxuICAgICAgICAgaWYgKG91dHB1dEhhbmRsZXIpIHtcbiAgICAgICAgICAgIGxvZ2dlcihgUGFzc2luZyBjaGlsZCBwcm9jZXNzIHN0ZE91dC9zdGRFcnIgdG8gY3VzdG9tIG91dHB1dEhhbmRsZXJgKTtcbiAgICAgICAgICAgIG91dHB1dEhhbmRsZXIoY29tbWFuZCwgc3Bhd25lZC5zdGRvdXQhLCBzcGF3bmVkLnN0ZGVyciEsIFsuLi5hcmdzXSk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX3BsdWdpbnMuZXhlYygnc3Bhd24uYWZ0ZXInLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgIC4uLnBsdWdpbkNvbnRleHQodGFzaywgYXJncyksXG4gICAgICAgICAgICBzcGF3bmVkLFxuICAgICAgICAgICAgY2xvc2UoZXhpdENvZGU6IG51bWJlciwgcmVhc29uPzogRXJyb3IpIHtcbiAgICAgICAgICAgICAgIGRvbmUoe1xuICAgICAgICAgICAgICAgICAgc3RkT3V0LFxuICAgICAgICAgICAgICAgICAgc3RkRXJyLFxuICAgICAgICAgICAgICAgICAgZXhpdENvZGUsXG4gICAgICAgICAgICAgICAgICByZWplY3Rpb246IHJlamVjdGlvbiB8fCByZWFzb24sXG4gICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBraWxsKHJlYXNvbjogRXJyb3IpIHtcbiAgICAgICAgICAgICAgIGlmIChzcGF3bmVkLmtpbGxlZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICByZWplY3Rpb24gPSByZWFzb247XG4gICAgICAgICAgICAgICBzcGF3bmVkLmtpbGwoJ1NJR0lOVCcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgIH0pO1xuICAgICAgfSk7XG4gICB9XG5cbiAgIHByaXZhdGUgX2JlZm9yZVNwYXduPFI+KHRhc2s6IFNpbXBsZUdpdFRhc2s8Uj4sIGFyZ3M6IHN0cmluZ1tdKSB7XG4gICAgICBsZXQgcmVqZWN0aW9uOiBNYXliZTxFcnJvcj47XG4gICAgICB0aGlzLl9wbHVnaW5zLmV4ZWMoJ3NwYXduLmJlZm9yZScsIHVuZGVmaW5lZCwge1xuICAgICAgICAgLi4ucGx1Z2luQ29udGV4dCh0YXNrLCBhcmdzKSxcbiAgICAgICAgIGtpbGwocmVhc29uKSB7XG4gICAgICAgICAgICByZWplY3Rpb24gPSByZWFzb24gfHwgcmVqZWN0aW9uO1xuICAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmVqZWN0aW9uO1xuICAgfVxufVxuXG5mdW5jdGlvbiBwbHVnaW5Db250ZXh0PFI+KHRhc2s6IFNpbXBsZUdpdFRhc2s8Uj4sIGNvbW1hbmRzOiBzdHJpbmdbXSkge1xuICAgcmV0dXJuIHtcbiAgICAgIG1ldGhvZDogZmlyc3QodGFzay5jb21tYW5kcykgfHwgJycsXG4gICAgICBjb21tYW5kcyxcbiAgIH07XG59XG5cbmZ1bmN0aW9uIG9uRXJyb3JSZWNlaXZlZCh0YXJnZXQ6IEJ1ZmZlcltdLCBsb2dnZXI6IE91dHB1dExvZ2dlcikge1xuICAgcmV0dXJuIChlcnI6IEVycm9yKSA9PiB7XG4gICAgICBsb2dnZXIoYFtFUlJPUl0gY2hpbGQgcHJvY2VzcyBleGNlcHRpb24gJW9gLCBlcnIpO1xuICAgICAgdGFyZ2V0LnB1c2goQnVmZmVyLmZyb20oU3RyaW5nKGVyci5zdGFjayksICdhc2NpaScpKTtcbiAgIH07XG59XG5cbmZ1bmN0aW9uIG9uRGF0YVJlY2VpdmVkKFxuICAgdGFyZ2V0OiBCdWZmZXJbXSxcbiAgIG5hbWU6IHN0cmluZyxcbiAgIGxvZ2dlcjogT3V0cHV0TG9nZ2VyLFxuICAgb3V0cHV0OiBPdXRwdXRMb2dnZXJcbikge1xuICAgcmV0dXJuIChidWZmZXI6IEJ1ZmZlcikgPT4ge1xuICAgICAgbG9nZ2VyKGAlcyByZWNlaXZlZCAlTCBieXRlc2AsIG5hbWUsIGJ1ZmZlcik7XG4gICAgICBvdXRwdXQoYCVCYCwgYnVmZmVyKTtcbiAgICAgIHRhcmdldC5wdXNoKGJ1ZmZlcik7XG4gICB9O1xufVxuIiwgImltcG9ydCB0eXBlIHsgUGx1Z2luU3RvcmUgfSBmcm9tICcuLi9wbHVnaW5zJztcbmltcG9ydCB0eXBlIHsgR2l0RXhlY3V0b3JFbnYsIG91dHB1dEhhbmRsZXIsIFNpbXBsZUdpdEV4ZWN1dG9yLCBTaW1wbGVHaXRUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBHaXRFeGVjdXRvckNoYWluIH0gZnJvbSAnLi9naXQtZXhlY3V0b3ItY2hhaW4nO1xuaW1wb3J0IHsgU2NoZWR1bGVyIH0gZnJvbSAnLi9zY2hlZHVsZXInO1xuXG5leHBvcnQgY2xhc3MgR2l0RXhlY3V0b3IgaW1wbGVtZW50cyBTaW1wbGVHaXRFeGVjdXRvciB7XG4gICBwcml2YXRlIF9jaGFpbiA9IG5ldyBHaXRFeGVjdXRvckNoYWluKHRoaXMsIHRoaXMuX3NjaGVkdWxlciwgdGhpcy5fcGx1Z2lucyk7XG5cbiAgIHB1YmxpYyBlbnY6IEdpdEV4ZWN1dG9yRW52O1xuICAgcHVibGljIG91dHB1dEhhbmRsZXI/OiBvdXRwdXRIYW5kbGVyO1xuXG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyBiaW5hcnk6IHN0cmluZyA9ICdnaXQnLFxuICAgICAgcHVibGljIGN3ZDogc3RyaW5nLFxuICAgICAgcHJpdmF0ZSBfc2NoZWR1bGVyOiBTY2hlZHVsZXIsXG4gICAgICBwcml2YXRlIF9wbHVnaW5zOiBQbHVnaW5TdG9yZVxuICAgKSB7fVxuXG4gICBjaGFpbigpOiBTaW1wbGVHaXRFeGVjdXRvciB7XG4gICAgICByZXR1cm4gbmV3IEdpdEV4ZWN1dG9yQ2hhaW4odGhpcywgdGhpcy5fc2NoZWR1bGVyLCB0aGlzLl9wbHVnaW5zKTtcbiAgIH1cblxuICAgcHVzaDxSPih0YXNrOiBTaW1wbGVHaXRUYXNrPFI+KTogUHJvbWlzZTxSPiB7XG4gICAgICByZXR1cm4gdGhpcy5fY2hhaW4ucHVzaCh0YXNrKTtcbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBHaXRFcnJvciB9IGZyb20gJy4vZXJyb3JzL2dpdC1lcnJvcic7XG5pbXBvcnQgeyBHaXRSZXNwb25zZUVycm9yIH0gZnJvbSAnLi9lcnJvcnMvZ2l0LXJlc3BvbnNlLWVycm9yJztcbmltcG9ydCB7IFNpbXBsZUdpdFRhc2ssIFNpbXBsZUdpdFRhc2tDYWxsYmFjayB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgTk9PUCB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gdGFza0NhbGxiYWNrPFI+KFxuICAgdGFzazogU2ltcGxlR2l0VGFzazxSPixcbiAgIHJlc3BvbnNlOiBQcm9taXNlPFI+LFxuICAgY2FsbGJhY2s6IFNpbXBsZUdpdFRhc2tDYWxsYmFjazxSPiA9IE5PT1Bcbikge1xuICAgY29uc3Qgb25TdWNjZXNzID0gKGRhdGE6IFIpID0+IHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgfTtcblxuICAgY29uc3Qgb25FcnJvciA9IChlcnI6IEdpdEVycm9yIHwgR2l0UmVzcG9uc2VFcnJvcikgPT4ge1xuICAgICAgaWYgKGVycj8udGFzayA9PT0gdGFzaykge1xuICAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgICBlcnIgaW5zdGFuY2VvZiBHaXRSZXNwb25zZUVycm9yID8gYWRkRGVwcmVjYXRpb25Ob3RpY2VUb0Vycm9yKGVycikgOiBlcnIsXG4gICAgICAgICAgICB1bmRlZmluZWQgYXMgYW55XG4gICAgICAgICApO1xuICAgICAgfVxuICAgfTtcblxuICAgcmVzcG9uc2UudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpO1xufVxuXG5mdW5jdGlvbiBhZGREZXByZWNhdGlvbk5vdGljZVRvRXJyb3IoZXJyOiBHaXRSZXNwb25zZUVycm9yKSB7XG4gICBsZXQgbG9nID0gKG5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgYHNpbXBsZS1naXQgZGVwcmVjYXRpb24gbm90aWNlOiBhY2Nlc3NpbmcgR2l0UmVzcG9uc2VFcnJvci4ke25hbWV9IHNob3VsZCBiZSBHaXRSZXNwb25zZUVycm9yLmdpdC4ke25hbWV9LCB0aGlzIHdpbGwgbm8gbG9uZ2VyIGJlIGF2YWlsYWJsZSBpbiB2ZXJzaW9uIDNgXG4gICAgICApO1xuICAgICAgbG9nID0gTk9PUDtcbiAgIH07XG5cbiAgIHJldHVybiBPYmplY3QuY3JlYXRlKGVyciwgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZXJyLmdpdCkucmVkdWNlKGRlc2NyaXB0b3JSZWR1Y2VyLCB7fSkpO1xuXG4gICBmdW5jdGlvbiBkZXNjcmlwdG9yUmVkdWNlcihhbGw6IFByb3BlcnR5RGVzY3JpcHRvck1hcCwgbmFtZTogc3RyaW5nKTogdHlwZW9mIGFsbCB7XG4gICAgICBpZiAobmFtZSBpbiBlcnIpIHtcbiAgICAgICAgIHJldHVybiBhbGw7XG4gICAgICB9XG5cbiAgICAgIGFsbFtuYW1lXSA9IHtcbiAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIGxvZyhuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBlcnIuZ2l0W25hbWVdO1xuICAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBhbGw7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgZm9sZGVyRXhpc3RzIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgU2ltcGxlR2l0RXhlY3V0b3IgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBhZGhvY0V4ZWNUYXNrIH0gZnJvbSAnLi90YXNrJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNoYW5nZVdvcmtpbmdEaXJlY3RvcnlUYXNrKGRpcmVjdG9yeTogc3RyaW5nLCByb290PzogU2ltcGxlR2l0RXhlY3V0b3IpIHtcbiAgIHJldHVybiBhZGhvY0V4ZWNUYXNrKChpbnN0YW5jZTogU2ltcGxlR2l0RXhlY3V0b3IpID0+IHtcbiAgICAgIGlmICghZm9sZGVyRXhpc3RzKGRpcmVjdG9yeSkpIHtcbiAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR2l0LmN3ZDogY2Fubm90IGNoYW5nZSB0byBub24tZGlyZWN0b3J5IFwiJHtkaXJlY3Rvcnl9XCJgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICgocm9vdCB8fCBpbnN0YW5jZSkuY3dkID0gZGlyZWN0b3J5KTtcbiAgIH0pO1xufVxuIiwgImltcG9ydCB0eXBlIHsgU2ltcGxlR2l0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgdHlwZSB7IFNpbXBsZUdpdEFwaSB9IGZyb20gJy4uL3NpbXBsZS1naXQtYXBpJztcbmltcG9ydCB7IGdldFRyYWlsaW5nT3B0aW9ucywgcmVtb3ZlLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrIH0gZnJvbSAnLi90YXNrJztcblxuZnVuY3Rpb24gY2hlY2tvdXRUYXNrKGFyZ3M6IHN0cmluZ1tdKSB7XG4gICBjb25zdCBjb21tYW5kcyA9IFsnY2hlY2tvdXQnLCAuLi5hcmdzXTtcbiAgIGlmIChjb21tYW5kc1sxXSA9PT0gJy1iJyAmJiBjb21tYW5kcy5pbmNsdWRlcygnLUInKSkge1xuICAgICAgY29tbWFuZHNbMV0gPSByZW1vdmUoY29tbWFuZHMsICctQicpO1xuICAgfVxuXG4gICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpOiBQaWNrPFNpbXBsZUdpdCwgJ2NoZWNrb3V0JyB8ICdjaGVja291dEJyYW5jaCcgfCAnY2hlY2tvdXRMb2NhbEJyYW5jaCc+IHtcbiAgIHJldHVybiB7XG4gICAgICBjaGVja291dCh0aGlzOiBTaW1wbGVHaXRBcGkpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgICAgY2hlY2tvdXRUYXNrKGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMsIDEpKSxcbiAgICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICApO1xuICAgICAgfSxcblxuICAgICAgY2hlY2tvdXRCcmFuY2godGhpczogU2ltcGxlR2l0QXBpLCBicmFuY2hOYW1lLCBzdGFydFBvaW50KSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIGNoZWNrb3V0VGFzayhbJy1iJywgYnJhbmNoTmFtZSwgc3RhcnRQb2ludCwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cyldKSxcbiAgICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICApO1xuICAgICAgfSxcblxuICAgICAgY2hlY2tvdXRMb2NhbEJyYW5jaCh0aGlzOiBTaW1wbGVHaXRBcGksIGJyYW5jaE5hbWUpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgICAgY2hlY2tvdXRUYXNrKFsnLWInLCBicmFuY2hOYW1lLCAuLi5nZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKV0pLFxuICAgICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICAgICk7XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJpbXBvcnQgeyBDb21taXRSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IExpbmVQYXJzZXIsIHBhcnNlU3RyaW5nUmVzcG9uc2UgfSBmcm9tICcuLi91dGlscyc7XG5cbmNvbnN0IHBhcnNlcnM6IExpbmVQYXJzZXI8Q29tbWl0UmVzdWx0PltdID0gW1xuICAgbmV3IExpbmVQYXJzZXIoL15cXFsoW15cXHNdKykoIFxcKFteKV0rXFwpKT8gKFteXFxdXSspLywgKHJlc3VsdCwgW2JyYW5jaCwgcm9vdCwgY29tbWl0XSkgPT4ge1xuICAgICAgcmVzdWx0LmJyYW5jaCA9IGJyYW5jaDtcbiAgICAgIHJlc3VsdC5jb21taXQgPSBjb21taXQ7XG4gICAgICByZXN1bHQucm9vdCA9ICEhcm9vdDtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoL1xccypBdXRob3I6XFxzKC4rKS9pLCAocmVzdWx0LCBbYXV0aG9yXSkgPT4ge1xuICAgICAgY29uc3QgcGFydHMgPSBhdXRob3Iuc3BsaXQoJzwnKTtcbiAgICAgIGNvbnN0IGVtYWlsID0gcGFydHMucG9wKCk7XG5cbiAgICAgIGlmICghZW1haWwgfHwgIWVtYWlsLmluY2x1ZGVzKCdAJykpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0LmF1dGhvciA9IHtcbiAgICAgICAgIGVtYWlsOiBlbWFpbC5zdWJzdHIoMCwgZW1haWwubGVuZ3RoIC0gMSksXG4gICAgICAgICBuYW1lOiBwYXJ0cy5qb2luKCc8JykudHJpbSgpLFxuICAgICAgfTtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvKFxcZCspW14sXSooPzosXFxzKihcXGQrKVteLF0qKSg/OixcXHMqKFxcZCspKS9nLFxuICAgICAgKHJlc3VsdCwgW2NoYW5nZXMsIGluc2VydGlvbnMsIGRlbGV0aW9uc10pID0+IHtcbiAgICAgICAgIHJlc3VsdC5zdW1tYXJ5LmNoYW5nZXMgPSBwYXJzZUludChjaGFuZ2VzLCAxMCkgfHwgMDtcbiAgICAgICAgIHJlc3VsdC5zdW1tYXJ5Lmluc2VydGlvbnMgPSBwYXJzZUludChpbnNlcnRpb25zLCAxMCkgfHwgMDtcbiAgICAgICAgIHJlc3VsdC5zdW1tYXJ5LmRlbGV0aW9ucyA9IHBhcnNlSW50KGRlbGV0aW9ucywgMTApIHx8IDA7XG4gICAgICB9XG4gICApLFxuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvXihcXGQrKVteLF0qKD86LFxccyooXFxkKylbXihdK1xcKChbKy1dKSk/LyxcbiAgICAgIChyZXN1bHQsIFtjaGFuZ2VzLCBsaW5lcywgZGlyZWN0aW9uXSkgPT4ge1xuICAgICAgICAgcmVzdWx0LnN1bW1hcnkuY2hhbmdlcyA9IHBhcnNlSW50KGNoYW5nZXMsIDEwKSB8fCAwO1xuICAgICAgICAgY29uc3QgY291bnQgPSBwYXJzZUludChsaW5lcywgMTApIHx8IDA7XG4gICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnLScpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdW1tYXJ5LmRlbGV0aW9ucyA9IGNvdW50O1xuICAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICcrJykge1xuICAgICAgICAgICAgcmVzdWx0LnN1bW1hcnkuaW5zZXJ0aW9ucyA9IGNvdW50O1xuICAgICAgICAgfVxuICAgICAgfVxuICAgKSxcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNvbW1pdFJlc3VsdChzdGRPdXQ6IHN0cmluZyk6IENvbW1pdFJlc3VsdCB7XG4gICBjb25zdCByZXN1bHQ6IENvbW1pdFJlc3VsdCA9IHtcbiAgICAgIGF1dGhvcjogbnVsbCxcbiAgICAgIGJyYW5jaDogJycsXG4gICAgICBjb21taXQ6ICcnLFxuICAgICAgcm9vdDogZmFsc2UsXG4gICAgICBzdW1tYXJ5OiB7XG4gICAgICAgICBjaGFuZ2VzOiAwLFxuICAgICAgICAgaW5zZXJ0aW9uczogMCxcbiAgICAgICAgIGRlbGV0aW9uczogMCxcbiAgICAgIH0sXG4gICB9O1xuICAgcmV0dXJuIHBhcnNlU3RyaW5nUmVzcG9uc2UocmVzdWx0LCBwYXJzZXJzLCBzdGRPdXQpO1xufVxuIiwgImltcG9ydCB0eXBlIHsgQ29tbWl0UmVzdWx0LCBTaW1wbGVHaXQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB0eXBlIHsgU2ltcGxlR2l0QXBpIH0gZnJvbSAnLi4vc2ltcGxlLWdpdC1hcGknO1xuaW1wb3J0IHR5cGUgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgcGFyc2VDb21taXRSZXN1bHQgfSBmcm9tICcuLi9wYXJzZXJzL3BhcnNlLWNvbW1pdCc7XG5pbXBvcnQge1xuICAgYXNBcnJheSxcbiAgIGZpbHRlckFycmF5LFxuICAgZmlsdGVyU3RyaW5nT3JTdHJpbmdBcnJheSxcbiAgIGZpbHRlclR5cGUsXG4gICBnZXRUcmFpbGluZ09wdGlvbnMsXG4gICBwcmVmaXhlZEFycmF5LFxuICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50LFxufSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBjb25maWd1cmF0aW9uRXJyb3JUYXNrIH0gZnJvbSAnLi90YXNrJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbW1pdFRhc2soXG4gICBtZXNzYWdlOiBzdHJpbmdbXSxcbiAgIGZpbGVzOiBzdHJpbmdbXSxcbiAgIGN1c3RvbUFyZ3M6IHN0cmluZ1tdXG4pOiBTdHJpbmdUYXNrPENvbW1pdFJlc3VsdD4ge1xuICAgY29uc3QgY29tbWFuZHM6IHN0cmluZ1tdID0gW1xuICAgICAgJy1jJyxcbiAgICAgICdjb3JlLmFiYnJldj00MCcsXG4gICAgICAnY29tbWl0JyxcbiAgICAgIC4uLnByZWZpeGVkQXJyYXkobWVzc2FnZSwgJy1tJyksXG4gICAgICAuLi5maWxlcyxcbiAgICAgIC4uLmN1c3RvbUFyZ3MsXG4gICBdO1xuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXI6IHBhcnNlQ29tbWl0UmVzdWx0LFxuICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCk6IFBpY2s8U2ltcGxlR2l0LCAnY29tbWl0Jz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1pdCh0aGlzOiBTaW1wbGVHaXRBcGksIG1lc3NhZ2U6IHN0cmluZyB8IHN0cmluZ1tdLCAuLi5yZXN0OiB1bmtub3duW10pIHtcbiAgICAgICAgIGNvbnN0IG5leHQgPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKTtcbiAgICAgICAgIGNvbnN0IHRhc2sgPVxuICAgICAgICAgICAgcmVqZWN0RGVwcmVjYXRlZFNpZ25hdHVyZXMobWVzc2FnZSkgfHxcbiAgICAgICAgICAgIGNvbW1pdFRhc2soXG4gICAgICAgICAgICAgICBhc0FycmF5KG1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgYXNBcnJheShmaWx0ZXJUeXBlKHJlc3RbMF0sIGZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXksIFtdKSksXG4gICAgICAgICAgICAgICBbLi4uZmlsdGVyVHlwZShyZXN0WzFdLCBmaWx0ZXJBcnJheSwgW10pLCAuLi5nZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzLCAwLCB0cnVlKV1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHRhc2ssIG5leHQpO1xuICAgICAgfSxcbiAgIH07XG5cbiAgIGZ1bmN0aW9uIHJlamVjdERlcHJlY2F0ZWRTaWduYXR1cmVzKG1lc3NhZ2U/OiB1bmtub3duKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAgIWZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXkobWVzc2FnZSkgJiZcbiAgICAgICAgIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soXG4gICAgICAgICAgICBgZ2l0LmNvbW1pdDogcmVxdWlyZXMgdGhlIGNvbW1pdCBtZXNzYWdlIHRvIGJlIHN1cHBsaWVkIGFzIGEgc3RyaW5nL3N0cmluZ1tdYFxuICAgICAgICAgKVxuICAgICAgKTtcbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBSZXNwb25zZSwgU2ltcGxlR2l0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBTaW1wbGVHaXRBcGkgfSBmcm9tICcuLi9zaW1wbGUtZ2l0LWFwaSc7XG5pbXBvcnQgeyB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrIH0gZnJvbSAnLi90YXNrJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCk6IFBpY2s8U2ltcGxlR2l0LCAnZmlyc3RDb21taXQnPiB7XG4gICByZXR1cm4ge1xuICAgICAgZmlyc3RDb21taXQodGhpczogU2ltcGxlR2l0QXBpKTogUmVzcG9uc2U8c3RyaW5nPiB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soWydyZXYtbGlzdCcsICctLW1heC1wYXJlbnRzPTAnLCAnSEVBRCddLCB0cnVlKSxcbiAgICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICApO1xuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5pbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG4vKipcbiAqIFRhc2sgdXNlZCBieSBgZ2l0Lmhhc2hPYmplY3RgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoT2JqZWN0VGFzayhmaWxlUGF0aDogc3RyaW5nLCB3cml0ZTogYm9vbGVhbik6IFN0cmluZ1Rhc2s8c3RyaW5nPiB7XG4gICBjb25zdCBjb21tYW5kcyA9IFsnaGFzaC1vYmplY3QnLCBmaWxlUGF0aF07XG4gICBpZiAod3JpdGUpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goJy13Jyk7XG4gICB9XG5cbiAgIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzLCB0cnVlKTtcbn1cbiIsICJpbXBvcnQgeyBJbml0UmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5cbmV4cG9ydCBjbGFzcyBJbml0U3VtbWFyeSBpbXBsZW1lbnRzIEluaXRSZXN1bHQge1xuICAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgYmFyZTogYm9vbGVhbixcbiAgICAgIHB1YmxpYyByZWFkb25seSBwYXRoOiBzdHJpbmcsXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgZXhpc3Rpbmc6IGJvb2xlYW4sXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgZ2l0RGlyOiBzdHJpbmdcbiAgICkge31cbn1cblxuY29uc3QgaW5pdFJlc3BvbnNlUmVnZXggPSAvXkluaXQuKyByZXBvc2l0b3J5IGluICguKykkLztcbmNvbnN0IHJlSW5pdFJlc3BvbnNlUmVnZXggPSAvXlJlaW4uKyBpbiAoLispJC87XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUluaXQoYmFyZTogYm9vbGVhbiwgcGF0aDogc3RyaW5nLCB0ZXh0OiBzdHJpbmcpIHtcbiAgIGNvbnN0IHJlc3BvbnNlID0gU3RyaW5nKHRleHQpLnRyaW0oKTtcbiAgIGxldCByZXN1bHQ7XG5cbiAgIGlmICgocmVzdWx0ID0gaW5pdFJlc3BvbnNlUmVnZXguZXhlYyhyZXNwb25zZSkpKSB7XG4gICAgICByZXR1cm4gbmV3IEluaXRTdW1tYXJ5KGJhcmUsIHBhdGgsIGZhbHNlLCByZXN1bHRbMV0pO1xuICAgfVxuXG4gICBpZiAoKHJlc3VsdCA9IHJlSW5pdFJlc3BvbnNlUmVnZXguZXhlYyhyZXNwb25zZSkpKSB7XG4gICAgICByZXR1cm4gbmV3IEluaXRTdW1tYXJ5KGJhcmUsIHBhdGgsIHRydWUsIHJlc3VsdFsxXSk7XG4gICB9XG5cbiAgIGxldCBnaXREaXIgPSAnJztcbiAgIGNvbnN0IHRva2VucyA9IHJlc3BvbnNlLnNwbGl0KCcgJyk7XG4gICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcbiAgICAgIGlmICh0b2tlbiA9PT0gJ2luJykge1xuICAgICAgICAgZ2l0RGlyID0gdG9rZW5zLmpvaW4oJyAnKTtcbiAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgfVxuXG4gICByZXR1cm4gbmV3IEluaXRTdW1tYXJ5KGJhcmUsIHBhdGgsIC9ecmUvaS50ZXN0KHJlc3BvbnNlKSwgZ2l0RGlyKTtcbn1cbiIsICJpbXBvcnQgeyBJbml0UmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBwYXJzZUluaXQgfSBmcm9tICcuLi9yZXNwb25zZXMvSW5pdFN1bW1hcnknO1xuaW1wb3J0IHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcblxuY29uc3QgYmFyZUNvbW1hbmQgPSAnLS1iYXJlJztcblxuZnVuY3Rpb24gaGFzQmFyZUNvbW1hbmQoY29tbWFuZDogc3RyaW5nW10pIHtcbiAgIHJldHVybiBjb21tYW5kLmluY2x1ZGVzKGJhcmVDb21tYW5kKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRUYXNrKGJhcmUgPSBmYWxzZSwgcGF0aDogc3RyaW5nLCBjdXN0b21BcmdzOiBzdHJpbmdbXSk6IFN0cmluZ1Rhc2s8SW5pdFJlc3VsdD4ge1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ2luaXQnLCAuLi5jdXN0b21BcmdzXTtcbiAgIGlmIChiYXJlICYmICFoYXNCYXJlQ29tbWFuZChjb21tYW5kcykpIHtcbiAgICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCBiYXJlQ29tbWFuZCk7XG4gICB9XG5cbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kcyxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcih0ZXh0OiBzdHJpbmcpOiBJbml0UmVzdWx0IHtcbiAgICAgICAgIHJldHVybiBwYXJzZUluaXQoY29tbWFuZHMuaW5jbHVkZXMoJy0tYmFyZScpLCBwYXRoLCB0ZXh0KTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImV4cG9ydCBlbnVtIExvZ0Zvcm1hdCB7XG4gICBOT05FID0gJycsXG4gICBTVEFUID0gJy0tc3RhdCcsXG4gICBOVU1fU1RBVCA9ICctLW51bXN0YXQnLFxuICAgTkFNRV9PTkxZID0gJy0tbmFtZS1vbmx5JyxcbiAgIE5BTUVfU1RBVFVTID0gJy0tbmFtZS1zdGF0dXMnLFxufVxuXG5jb25zdCBsb2dGb3JtYXRSZWdleCA9IC9eLS0oc3RhdHxudW1zdGF0fG5hbWUtb25seXxuYW1lLXN0YXR1cykoPXwkKS87XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2dGb3JtYXRGcm9tQ29tbWFuZChjdXN0b21BcmdzOiBzdHJpbmdbXSkge1xuICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXN0b21BcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBmb3JtYXQgPSBsb2dGb3JtYXRSZWdleC5leGVjKGN1c3RvbUFyZ3NbaV0pO1xuICAgICAgaWYgKGZvcm1hdCkge1xuICAgICAgICAgcmV0dXJuIGAtLSR7Zm9ybWF0WzFdfWAgYXMgTG9nRm9ybWF0O1xuICAgICAgfVxuICAgfVxuXG4gICByZXR1cm4gTG9nRm9ybWF0Lk5PTkU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0xvZ0Zvcm1hdChjdXN0b21Bcmc6IHN0cmluZyB8IHVua25vd24pIHtcbiAgIHJldHVybiBsb2dGb3JtYXRSZWdleC50ZXN0KGN1c3RvbUFyZyBhcyBzdHJpbmcpO1xufVxuIiwgImltcG9ydCB7IERpZmZSZXN1bHQsIERpZmZSZXN1bHRCaW5hcnlGaWxlLCBEaWZmUmVzdWx0VGV4dEZpbGUgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcblxuLyoqKlxuICogVGhlIERpZmZTdW1tYXJ5IGlzIHJldHVybmVkIGFzIGEgcmVzcG9uc2UgdG8gZ2V0dGluZyBgZ2l0KCkuc3RhdHVzKClgXG4gKi9cbmV4cG9ydCBjbGFzcyBEaWZmU3VtbWFyeSBpbXBsZW1lbnRzIERpZmZSZXN1bHQge1xuICAgY2hhbmdlZCA9IDA7XG4gICBkZWxldGlvbnMgPSAwO1xuICAgaW5zZXJ0aW9ucyA9IDA7XG5cbiAgIGZpbGVzOiBBcnJheTxEaWZmUmVzdWx0VGV4dEZpbGUgfCBEaWZmUmVzdWx0QmluYXJ5RmlsZT4gPSBbXTtcbn1cbiIsICJpbXBvcnQgeyBEaWZmUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBMb2dGb3JtYXQgfSBmcm9tICcuLi9hcmdzL2xvZy1mb3JtYXQnO1xuaW1wb3J0IHsgRGlmZlN1bW1hcnkgfSBmcm9tICcuLi9yZXNwb25zZXMvRGlmZlN1bW1hcnknO1xuaW1wb3J0IHsgaXNEaWZmTmFtZVN0YXR1cyB9IGZyb20gJy4uL3Rhc2tzL2RpZmYtbmFtZS1zdGF0dXMnO1xuaW1wb3J0IHsgYXNOdW1iZXIsIExpbmVQYXJzZXIsIG9yVm9pZCwgcGFyc2VTdHJpbmdSZXNwb25zZSB9IGZyb20gJy4uL3V0aWxzJztcblxuY29uc3Qgc3RhdFBhcnNlciA9IFtcbiAgIG5ldyBMaW5lUGFyc2VyPERpZmZSZXN1bHQ+KFxuICAgICAgLyguKylcXHMrXFx8XFxzKyhcXGQrKShcXHMrWytcXC1dKyk/JC8sXG4gICAgICAocmVzdWx0LCBbZmlsZSwgY2hhbmdlcywgYWx0ZXJhdGlvbnMgPSAnJ10pID0+IHtcbiAgICAgICAgIHJlc3VsdC5maWxlcy5wdXNoKHtcbiAgICAgICAgICAgIGZpbGU6IGZpbGUudHJpbSgpLFxuICAgICAgICAgICAgY2hhbmdlczogYXNOdW1iZXIoY2hhbmdlcyksXG4gICAgICAgICAgICBpbnNlcnRpb25zOiBhbHRlcmF0aW9ucy5yZXBsYWNlKC9bXitdL2csICcnKS5sZW5ndGgsXG4gICAgICAgICAgICBkZWxldGlvbnM6IGFsdGVyYXRpb25zLnJlcGxhY2UoL1teLV0vZywgJycpLmxlbmd0aCxcbiAgICAgICAgICAgIGJpbmFyeTogZmFsc2UsXG4gICAgICAgICB9KTtcbiAgICAgIH1cbiAgICksXG4gICBuZXcgTGluZVBhcnNlcjxEaWZmUmVzdWx0PihcbiAgICAgIC8oLispIFxcfFxccytCaW4gKFswLTkuXSspIC0+IChbMC05Ll0rKSAoW2Etel0rKS8sXG4gICAgICAocmVzdWx0LCBbZmlsZSwgYmVmb3JlLCBhZnRlcl0pID0+IHtcbiAgICAgICAgIHJlc3VsdC5maWxlcy5wdXNoKHtcbiAgICAgICAgICAgIGZpbGU6IGZpbGUudHJpbSgpLFxuICAgICAgICAgICAgYmVmb3JlOiBhc051bWJlcihiZWZvcmUpLFxuICAgICAgICAgICAgYWZ0ZXI6IGFzTnVtYmVyKGFmdGVyKSxcbiAgICAgICAgICAgIGJpbmFyeTogdHJ1ZSxcbiAgICAgICAgIH0pO1xuICAgICAgfVxuICAgKSxcbiAgIG5ldyBMaW5lUGFyc2VyPERpZmZSZXN1bHQ+KFxuICAgICAgLyhcXGQrKSBmaWxlcz8gY2hhbmdlZFxccyooKD86LCBcXGQrIFteLF0rKXswLDJ9KS8sXG4gICAgICAocmVzdWx0LCBbY2hhbmdlZCwgc3VtbWFyeV0pID0+IHtcbiAgICAgICAgIGNvbnN0IGluc2VydGVkID0gLyhcXGQrKSBpLy5leGVjKHN1bW1hcnkpO1xuICAgICAgICAgY29uc3QgZGVsZXRlZCA9IC8oXFxkKykgZC8uZXhlYyhzdW1tYXJ5KTtcblxuICAgICAgICAgcmVzdWx0LmNoYW5nZWQgPSBhc051bWJlcihjaGFuZ2VkKTtcbiAgICAgICAgIHJlc3VsdC5pbnNlcnRpb25zID0gYXNOdW1iZXIoaW5zZXJ0ZWQ/LlsxXSk7XG4gICAgICAgICByZXN1bHQuZGVsZXRpb25zID0gYXNOdW1iZXIoZGVsZXRlZD8uWzFdKTtcbiAgICAgIH1cbiAgICksXG5dO1xuXG5jb25zdCBudW1TdGF0UGFyc2VyID0gW1xuICAgbmV3IExpbmVQYXJzZXI8RGlmZlJlc3VsdD4oXG4gICAgICAvKFxcZCspXFx0KFxcZCspXFx0KC4rKSQvLFxuICAgICAgKHJlc3VsdCwgW2NoYW5nZXNJbnNlcnQsIGNoYW5nZXNEZWxldGUsIGZpbGVdKSA9PiB7XG4gICAgICAgICBjb25zdCBpbnNlcnRpb25zID0gYXNOdW1iZXIoY2hhbmdlc0luc2VydCk7XG4gICAgICAgICBjb25zdCBkZWxldGlvbnMgPSBhc051bWJlcihjaGFuZ2VzRGVsZXRlKTtcblxuICAgICAgICAgcmVzdWx0LmNoYW5nZWQrKztcbiAgICAgICAgIHJlc3VsdC5pbnNlcnRpb25zICs9IGluc2VydGlvbnM7XG4gICAgICAgICByZXN1bHQuZGVsZXRpb25zICs9IGRlbGV0aW9ucztcblxuICAgICAgICAgcmVzdWx0LmZpbGVzLnB1c2goe1xuICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgIGNoYW5nZXM6IGluc2VydGlvbnMgKyBkZWxldGlvbnMsXG4gICAgICAgICAgICBpbnNlcnRpb25zLFxuICAgICAgICAgICAgZGVsZXRpb25zLFxuICAgICAgICAgICAgYmluYXJ5OiBmYWxzZSxcbiAgICAgICAgIH0pO1xuICAgICAgfVxuICAgKSxcbiAgIG5ldyBMaW5lUGFyc2VyPERpZmZSZXN1bHQ+KC8tXFx0LVxcdCguKykkLywgKHJlc3VsdCwgW2ZpbGVdKSA9PiB7XG4gICAgICByZXN1bHQuY2hhbmdlZCsrO1xuXG4gICAgICByZXN1bHQuZmlsZXMucHVzaCh7XG4gICAgICAgICBmaWxlLFxuICAgICAgICAgYWZ0ZXI6IDAsXG4gICAgICAgICBiZWZvcmU6IDAsXG4gICAgICAgICBiaW5hcnk6IHRydWUsXG4gICAgICB9KTtcbiAgIH0pLFxuXTtcblxuY29uc3QgbmFtZU9ubHlQYXJzZXIgPSBbXG4gICBuZXcgTGluZVBhcnNlcjxEaWZmUmVzdWx0PigvKC4rKSQvLCAocmVzdWx0LCBbZmlsZV0pID0+IHtcbiAgICAgIHJlc3VsdC5jaGFuZ2VkKys7XG4gICAgICByZXN1bHQuZmlsZXMucHVzaCh7XG4gICAgICAgICBmaWxlLFxuICAgICAgICAgY2hhbmdlczogMCxcbiAgICAgICAgIGluc2VydGlvbnM6IDAsXG4gICAgICAgICBkZWxldGlvbnM6IDAsXG4gICAgICAgICBiaW5hcnk6IGZhbHNlLFxuICAgICAgfSk7XG4gICB9KSxcbl07XG5cbmNvbnN0IG5hbWVTdGF0dXNQYXJzZXIgPSBbXG4gICBuZXcgTGluZVBhcnNlcjxEaWZmUmVzdWx0PihcbiAgICAgIC8oW0FDRE1SVFVYQl0pKFswLTldezAsM30pXFx0KC5bXlxcdF0qKShcXHQoLlteXFx0XSopKT8kLyxcbiAgICAgIChyZXN1bHQsIFtzdGF0dXMsIF9zaW1pbGFyaXR5LCBmcm9tLCBfdG8sIHRvXSkgPT4ge1xuICAgICAgICAgcmVzdWx0LmNoYW5nZWQrKztcbiAgICAgICAgIHJlc3VsdC5maWxlcy5wdXNoKHtcbiAgICAgICAgICAgIGZpbGU6IHRvID8/IGZyb20sXG4gICAgICAgICAgICBjaGFuZ2VzOiAwLFxuICAgICAgICAgICAgc3RhdHVzOiBvclZvaWQoaXNEaWZmTmFtZVN0YXR1cyhzdGF0dXMpICYmIHN0YXR1cyksXG4gICAgICAgICAgICBpbnNlcnRpb25zOiAwLFxuICAgICAgICAgICAgZGVsZXRpb25zOiAwLFxuICAgICAgICAgICAgYmluYXJ5OiBmYWxzZSxcbiAgICAgICAgIH0pO1xuICAgICAgfVxuICAgKSxcbl07XG5cbmNvbnN0IGRpZmZTdW1tYXJ5UGFyc2VyczogUmVjb3JkPExvZ0Zvcm1hdCwgTGluZVBhcnNlcjxEaWZmUmVzdWx0PltdPiA9IHtcbiAgIFtMb2dGb3JtYXQuTk9ORV06IHN0YXRQYXJzZXIsXG4gICBbTG9nRm9ybWF0LlNUQVRdOiBzdGF0UGFyc2VyLFxuICAgW0xvZ0Zvcm1hdC5OVU1fU1RBVF06IG51bVN0YXRQYXJzZXIsXG4gICBbTG9nRm9ybWF0Lk5BTUVfU1RBVFVTXTogbmFtZVN0YXR1c1BhcnNlcixcbiAgIFtMb2dGb3JtYXQuTkFNRV9PTkxZXTogbmFtZU9ubHlQYXJzZXIsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlmZlBhcnNlcihmb3JtYXQgPSBMb2dGb3JtYXQuTk9ORSkge1xuICAgY29uc3QgcGFyc2VyID0gZGlmZlN1bW1hcnlQYXJzZXJzW2Zvcm1hdF07XG5cbiAgIHJldHVybiAoc3RkT3V0OiBzdHJpbmcpID0+IHBhcnNlU3RyaW5nUmVzcG9uc2UobmV3IERpZmZTdW1tYXJ5KCksIHBhcnNlciwgc3RkT3V0LCBmYWxzZSk7XG59XG4iLCAiaW1wb3J0IHsgTGlzdExvZ0xpbmUsIExvZ1Jlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgdG9MaW5lc1dpdGhDb250ZW50IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgZ2V0RGlmZlBhcnNlciB9IGZyb20gJy4vcGFyc2UtZGlmZi1zdW1tYXJ5JztcbmltcG9ydCB7IExvZ0Zvcm1hdCB9IGZyb20gJy4uL2FyZ3MvbG9nLWZvcm1hdCc7XG5cbmV4cG9ydCBjb25zdCBTVEFSVF9CT1VOREFSWSA9ICdcdTAwRjJcdTAwRjJcdTAwRjJcdTAwRjJcdTAwRjJcdTAwRjIgJztcblxuZXhwb3J0IGNvbnN0IENPTU1JVF9CT1VOREFSWSA9ICcgXHUwMEYyXHUwMEYyJztcblxuZXhwb3J0IGNvbnN0IFNQTElUVEVSID0gJyBcdTAwRjIgJztcblxuY29uc3QgZGVmYXVsdEZpZWxkTmFtZXMgPSBbJ2hhc2gnLCAnZGF0ZScsICdtZXNzYWdlJywgJ3JlZnMnLCAnYXV0aG9yX25hbWUnLCAnYXV0aG9yX2VtYWlsJ107XG5cbmZ1bmN0aW9uIGxpbmVCdWlsZGVyKHRva2Vuczogc3RyaW5nW10sIGZpZWxkczogc3RyaW5nW10pOiBhbnkge1xuICAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoXG4gICAgICAobGluZSwgZmllbGQsIGluZGV4KSA9PiB7XG4gICAgICAgICBsaW5lW2ZpZWxkXSA9IHRva2Vuc1tpbmRleF0gfHwgJyc7XG4gICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgIH0sXG4gICAgICBPYmplY3QuY3JlYXRlKHsgZGlmZjogbnVsbCB9KSBhcyBhbnlcbiAgICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMaXN0TG9nU3VtbWFyeVBhcnNlcjxUID0gYW55PihcbiAgIHNwbGl0dGVyID0gU1BMSVRURVIsXG4gICBmaWVsZHMgPSBkZWZhdWx0RmllbGROYW1lcyxcbiAgIGxvZ0Zvcm1hdCA9IExvZ0Zvcm1hdC5OT05FXG4pIHtcbiAgIGNvbnN0IHBhcnNlRGlmZlJlc3VsdCA9IGdldERpZmZQYXJzZXIobG9nRm9ybWF0KTtcblxuICAgcmV0dXJuIGZ1bmN0aW9uIChzdGRPdXQ6IHN0cmluZyk6IExvZ1Jlc3VsdDxUPiB7XG4gICAgICBjb25zdCBhbGw6IFJlYWRvbmx5QXJyYXk8VCAmIExpc3RMb2dMaW5lPiA9IHRvTGluZXNXaXRoQ29udGVudChcbiAgICAgICAgIHN0ZE91dCxcbiAgICAgICAgIHRydWUsXG4gICAgICAgICBTVEFSVF9CT1VOREFSWVxuICAgICAgKS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgIGNvbnN0IGxpbmVEZXRhaWwgPSBpdGVtLnRyaW0oKS5zcGxpdChDT01NSVRfQk9VTkRBUlkpO1xuICAgICAgICAgY29uc3QgbGlzdExvZ0xpbmU6IFQgJiBMaXN0TG9nTGluZSA9IGxpbmVCdWlsZGVyKFxuICAgICAgICAgICAgbGluZURldGFpbFswXS50cmltKCkuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgICAgICAgZmllbGRzXG4gICAgICAgICApO1xuXG4gICAgICAgICBpZiAobGluZURldGFpbC5sZW5ndGggPiAxICYmICEhbGluZURldGFpbFsxXS50cmltKCkpIHtcbiAgICAgICAgICAgIGxpc3RMb2dMaW5lLmRpZmYgPSBwYXJzZURpZmZSZXN1bHQobGluZURldGFpbFsxXSk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHJldHVybiBsaXN0TG9nTGluZTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgYWxsLFxuICAgICAgICAgbGF0ZXN0OiAoYWxsLmxlbmd0aCAmJiBhbGxbMF0pIHx8IG51bGwsXG4gICAgICAgICB0b3RhbDogYWxsLmxlbmd0aCxcbiAgICAgIH07XG4gICB9O1xufVxuIiwgImltcG9ydCB7IFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBEaWZmUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBpc0xvZ0Zvcm1hdCwgTG9nRm9ybWF0LCBsb2dGb3JtYXRGcm9tQ29tbWFuZCB9IGZyb20gJy4uL2FyZ3MvbG9nLWZvcm1hdCc7XG5pbXBvcnQgeyBnZXREaWZmUGFyc2VyIH0gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZS1kaWZmLXN1bW1hcnknO1xuaW1wb3J0IHsgY29uZmlndXJhdGlvbkVycm9yVGFzaywgRW1wdHlUYXNrIH0gZnJvbSAnLi90YXNrJztcblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZTdW1tYXJ5VGFzayhjdXN0b21BcmdzOiBzdHJpbmdbXSk6IFN0cmluZ1Rhc2s8RGlmZlJlc3VsdD4gfCBFbXB0eVRhc2sge1xuICAgbGV0IGxvZ0Zvcm1hdCA9IGxvZ0Zvcm1hdEZyb21Db21tYW5kKGN1c3RvbUFyZ3MpO1xuXG4gICBjb25zdCBjb21tYW5kcyA9IFsnZGlmZiddO1xuXG4gICBpZiAobG9nRm9ybWF0ID09PSBMb2dGb3JtYXQuTk9ORSkge1xuICAgICAgbG9nRm9ybWF0ID0gTG9nRm9ybWF0LlNUQVQ7XG4gICAgICBjb21tYW5kcy5wdXNoKCctLXN0YXQ9NDA5NicpO1xuICAgfVxuXG4gICBjb21tYW5kcy5wdXNoKC4uLmN1c3RvbUFyZ3MpO1xuXG4gICByZXR1cm4gKFxuICAgICAgdmFsaWRhdGVMb2dGb3JtYXRDb25maWcoY29tbWFuZHMpIHx8IHtcbiAgICAgICAgIGNvbW1hbmRzLFxuICAgICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgICAgcGFyc2VyOiBnZXREaWZmUGFyc2VyKGxvZ0Zvcm1hdCksXG4gICAgICB9XG4gICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVMb2dGb3JtYXRDb25maWcoY3VzdG9tQXJnczogdW5rbm93bltdKTogRW1wdHlUYXNrIHwgdm9pZCB7XG4gICBjb25zdCBmbGFncyA9IGN1c3RvbUFyZ3MuZmlsdGVyKGlzTG9nRm9ybWF0KTtcblxuICAgaWYgKGZsYWdzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKFxuICAgICAgICAgYFN1bW1hcnkgZmxhZ3MgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSAtIHBpY2sgb25lIG9mICR7ZmxhZ3Muam9pbignLCcpfWBcbiAgICAgICk7XG4gICB9XG5cbiAgIGlmIChmbGFncy5sZW5ndGggJiYgY3VzdG9tQXJncy5pbmNsdWRlcygnLXonKSkge1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soXG4gICAgICAgICBgU3VtbWFyeSBmbGFnICR7ZmxhZ3N9IHBhcnNpbmcgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBudWxsIHRlcm1pbmF0aW9uIG9wdGlvbiAnLXonYFxuICAgICAgKTtcbiAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IE9wdGlvbnMsIFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgdHlwZSB7IExvZ1Jlc3VsdCwgU2ltcGxlR2l0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBsb2dGb3JtYXRGcm9tQ29tbWFuZCB9IGZyb20gJy4uL2FyZ3MvbG9nLWZvcm1hdCc7XG5pbXBvcnQgeyBwYXRoc3BlYyB9IGZyb20gJy4uL2FyZ3MvcGF0aHNwZWMnO1xuaW1wb3J0IHtcbiAgIENPTU1JVF9CT1VOREFSWSxcbiAgIGNyZWF0ZUxpc3RMb2dTdW1tYXJ5UGFyc2VyLFxuICAgU1BMSVRURVIsXG4gICBTVEFSVF9CT1VOREFSWSxcbn0gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZS1saXN0LWxvZy1zdW1tYXJ5JztcbmltcG9ydCB7XG4gICBhcHBlbmRUYXNrT3B0aW9ucyxcbiAgIGZpbHRlckFycmF5LFxuICAgZmlsdGVyUHJpbWl0aXZlcyxcbiAgIGZpbHRlclN0cmluZyxcbiAgIGZpbHRlclR5cGUsXG4gICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQsXG4gICB0cmFpbGluZ09wdGlvbnNBcmd1bWVudCxcbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgU2ltcGxlR2l0QXBpIH0gZnJvbSAnLi4vc2ltcGxlLWdpdC1hcGknO1xuaW1wb3J0IHsgY29uZmlndXJhdGlvbkVycm9yVGFzayB9IGZyb20gJy4vdGFzayc7XG5pbXBvcnQgeyB2YWxpZGF0ZUxvZ0Zvcm1hdENvbmZpZyB9IGZyb20gJy4vZGlmZic7XG5cbmVudW0gZXhjbHVkZU9wdGlvbnMge1xuICAgJy0tcHJldHR5JyxcbiAgICdtYXgtY291bnQnLFxuICAgJ21heENvdW50JyxcbiAgICduJyxcbiAgICdmaWxlJyxcbiAgICdmb3JtYXQnLFxuICAgJ2Zyb20nLFxuICAgJ3RvJyxcbiAgICdzcGxpdHRlcicsXG4gICAnc3ltbWV0cmljJyxcbiAgICdtYWlsTWFwJyxcbiAgICdtdWx0aUxpbmUnLFxuICAgJ3N0cmljdERhdGUnLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlZmF1bHRMb2dGaWVsZHMge1xuICAgaGFzaDogc3RyaW5nO1xuICAgZGF0ZTogc3RyaW5nO1xuICAgbWVzc2FnZTogc3RyaW5nO1xuICAgcmVmczogc3RyaW5nO1xuICAgYm9keTogc3RyaW5nO1xuICAgYXV0aG9yX25hbWU6IHN0cmluZztcbiAgIGF1dGhvcl9lbWFpbDogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBMb2dPcHRpb25zPFQgPSBEZWZhdWx0TG9nRmllbGRzPiA9IHtcbiAgIGZpbGU/OiBzdHJpbmc7XG4gICBmb3JtYXQ/OiBUO1xuICAgZnJvbT86IHN0cmluZztcbiAgIG1haWxNYXA/OiBib29sZWFuO1xuICAgbWF4Q291bnQ/OiBudW1iZXI7XG4gICBtdWx0aUxpbmU/OiBib29sZWFuO1xuICAgc3BsaXR0ZXI/OiBzdHJpbmc7XG4gICBzdHJpY3REYXRlPzogYm9vbGVhbjtcbiAgIHN5bW1ldHJpYz86IGJvb2xlYW47XG4gICB0bz86IHN0cmluZztcbn07XG5cbmludGVyZmFjZSBQYXJzZWRMb2dPcHRpb25zIHtcbiAgIGZpZWxkczogc3RyaW5nW107XG4gICBzcGxpdHRlcjogc3RyaW5nO1xuICAgY29tbWFuZHM6IHN0cmluZ1tdO1xufVxuXG5mdW5jdGlvbiBwcmV0dHlGb3JtYXQoXG4gICBmb3JtYXQ6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVua25vd24+LFxuICAgc3BsaXR0ZXI6IHN0cmluZ1xuKTogW3N0cmluZ1tdLCBzdHJpbmddIHtcbiAgIGNvbnN0IGZpZWxkczogc3RyaW5nW10gPSBbXTtcbiAgIGNvbnN0IGZvcm1hdFN0cjogc3RyaW5nW10gPSBbXTtcblxuICAgT2JqZWN0LmtleXMoZm9ybWF0KS5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgZmllbGRzLnB1c2goZmllbGQpO1xuICAgICAgZm9ybWF0U3RyLnB1c2goU3RyaW5nKGZvcm1hdFtmaWVsZF0pKTtcbiAgIH0pO1xuXG4gICByZXR1cm4gW2ZpZWxkcywgZm9ybWF0U3RyLmpvaW4oc3BsaXR0ZXIpXTtcbn1cblxuZnVuY3Rpb24gdXNlck9wdGlvbnM8VCBleHRlbmRzIE9wdGlvbnM+KGlucHV0OiBUKTogT3B0aW9ucyB7XG4gICByZXR1cm4gT2JqZWN0LmtleXMoaW5wdXQpLnJlZHVjZSgob3V0LCBrZXkpID0+IHtcbiAgICAgIGlmICghKGtleSBpbiBleGNsdWRlT3B0aW9ucykpIHtcbiAgICAgICAgIG91dFtrZXldID0gaW5wdXRba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICB9LCB7fSBhcyBPcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTG9nT3B0aW9uczxUIGV4dGVuZHMgT3B0aW9ucz4oXG4gICBvcHQ6IE9wdGlvbnMgfCBMb2dPcHRpb25zPFQ+ID0ge30sXG4gICBjdXN0b21BcmdzOiBzdHJpbmdbXSA9IFtdXG4pOiBQYXJzZWRMb2dPcHRpb25zIHtcbiAgIGNvbnN0IHNwbGl0dGVyID0gZmlsdGVyVHlwZShvcHQuc3BsaXR0ZXIsIGZpbHRlclN0cmluZywgU1BMSVRURVIpO1xuICAgY29uc3QgZm9ybWF0ID1cbiAgICAgICFmaWx0ZXJQcmltaXRpdmVzKG9wdC5mb3JtYXQpICYmIG9wdC5mb3JtYXRcbiAgICAgICAgID8gb3B0LmZvcm1hdFxuICAgICAgICAgOiB7XG4gICAgICAgICAgICAgIGhhc2g6ICclSCcsXG4gICAgICAgICAgICAgIGRhdGU6IG9wdC5zdHJpY3REYXRlID09PSBmYWxzZSA/ICclYWknIDogJyVhSScsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICclcycsXG4gICAgICAgICAgICAgIHJlZnM6ICclRCcsXG4gICAgICAgICAgICAgIGJvZHk6IG9wdC5tdWx0aUxpbmUgPyAnJUInIDogJyViJyxcbiAgICAgICAgICAgICAgYXV0aG9yX25hbWU6IG9wdC5tYWlsTWFwICE9PSBmYWxzZSA/ICclYU4nIDogJyVhbicsXG4gICAgICAgICAgICAgIGF1dGhvcl9lbWFpbDogb3B0Lm1haWxNYXAgIT09IGZhbHNlID8gJyVhRScgOiAnJWFlJyxcbiAgICAgICAgICAgfTtcblxuICAgY29uc3QgW2ZpZWxkcywgZm9ybWF0U3RyXSA9IHByZXR0eUZvcm1hdChmb3JtYXQsIHNwbGl0dGVyKTtcblxuICAgY29uc3Qgc3VmZml4OiBzdHJpbmdbXSA9IFtdO1xuICAgY29uc3QgY29tbWFuZDogc3RyaW5nW10gPSBbXG4gICAgICBgLS1wcmV0dHk9Zm9ybWF0OiR7U1RBUlRfQk9VTkRBUll9JHtmb3JtYXRTdHJ9JHtDT01NSVRfQk9VTkRBUll9YCxcbiAgICAgIC4uLmN1c3RvbUFyZ3MsXG4gICBdO1xuXG4gICBjb25zdCBtYXhDb3VudDogbnVtYmVyIHwgdW5kZWZpbmVkID0gKG9wdCBhcyBhbnkpLm4gfHwgKG9wdCBhcyBhbnkpWydtYXgtY291bnQnXSB8fCBvcHQubWF4Q291bnQ7XG4gICBpZiAobWF4Q291bnQpIHtcbiAgICAgIGNvbW1hbmQucHVzaChgLS1tYXgtY291bnQ9JHttYXhDb3VudH1gKTtcbiAgIH1cblxuICAgaWYgKG9wdC5mcm9tIHx8IG9wdC50bykge1xuICAgICAgY29uc3QgcmFuZ2VPcGVyYXRvciA9IG9wdC5zeW1tZXRyaWMgIT09IGZhbHNlID8gJy4uLicgOiAnLi4nO1xuICAgICAgc3VmZml4LnB1c2goYCR7b3B0LmZyb20gfHwgJyd9JHtyYW5nZU9wZXJhdG9yfSR7b3B0LnRvIHx8ICcnfWApO1xuICAgfVxuXG4gICBpZiAoZmlsdGVyU3RyaW5nKG9wdC5maWxlKSkge1xuICAgICAgY29tbWFuZC5wdXNoKCctLWZvbGxvdycsIHBhdGhzcGVjKG9wdC5maWxlKSk7XG4gICB9XG5cbiAgIGFwcGVuZFRhc2tPcHRpb25zKHVzZXJPcHRpb25zKG9wdCBhcyBPcHRpb25zKSwgY29tbWFuZCk7XG5cbiAgIHJldHVybiB7XG4gICAgICBmaWVsZHMsXG4gICAgICBzcGxpdHRlcixcbiAgICAgIGNvbW1hbmRzOiBbLi4uY29tbWFuZCwgLi4uc3VmZml4XSxcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2dUYXNrPFQ+KFxuICAgc3BsaXR0ZXI6IHN0cmluZyxcbiAgIGZpZWxkczogc3RyaW5nW10sXG4gICBjdXN0b21BcmdzOiBzdHJpbmdbXVxuKTogU3RyaW5nVGFzazxMb2dSZXN1bHQ8VD4+IHtcbiAgIGNvbnN0IHBhcnNlciA9IGNyZWF0ZUxpc3RMb2dTdW1tYXJ5UGFyc2VyKHNwbGl0dGVyLCBmaWVsZHMsIGxvZ0Zvcm1hdEZyb21Db21tYW5kKGN1c3RvbUFyZ3MpKTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzOiBbJ2xvZycsIC4uLmN1c3RvbUFyZ3NdLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgcGFyc2VyLFxuICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCk6IFBpY2s8U2ltcGxlR2l0LCAnbG9nJz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIGxvZzxUIGV4dGVuZHMgT3B0aW9ucz4odGhpczogU2ltcGxlR2l0QXBpLCAuLi5yZXN0OiB1bmtub3duW10pIHtcbiAgICAgICAgIGNvbnN0IG5leHQgPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKTtcbiAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBwYXJzZUxvZ09wdGlvbnM8VD4oXG4gICAgICAgICAgICB0cmFpbGluZ09wdGlvbnNBcmd1bWVudChhcmd1bWVudHMpLFxuICAgICAgICAgICAgZmlsdGVyVHlwZShhcmd1bWVudHNbMF0sIGZpbHRlckFycmF5KVxuICAgICAgICAgKTtcbiAgICAgICAgIGNvbnN0IHRhc2sgPVxuICAgICAgICAgICAgcmVqZWN0RGVwcmVjYXRlZFNpZ25hdHVyZXMoLi4ucmVzdCkgfHxcbiAgICAgICAgICAgIHZhbGlkYXRlTG9nRm9ybWF0Q29uZmlnKG9wdGlvbnMuY29tbWFuZHMpIHx8XG4gICAgICAgICAgICBjcmVhdGVMb2dUYXNrKG9wdGlvbnMpO1xuXG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCBuZXh0KTtcbiAgICAgIH0sXG4gICB9O1xuXG4gICBmdW5jdGlvbiBjcmVhdGVMb2dUYXNrKG9wdGlvbnM6IFBhcnNlZExvZ09wdGlvbnMpIHtcbiAgICAgIHJldHVybiBsb2dUYXNrKG9wdGlvbnMuc3BsaXR0ZXIsIG9wdGlvbnMuZmllbGRzLCBvcHRpb25zLmNvbW1hbmRzKTtcbiAgIH1cblxuICAgZnVuY3Rpb24gcmVqZWN0RGVwcmVjYXRlZFNpZ25hdHVyZXMoZnJvbT86IHVua25vd24sIHRvPzogdW5rbm93bikge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgIGZpbHRlclN0cmluZyhmcm9tKSAmJlxuICAgICAgICAgZmlsdGVyU3RyaW5nKHRvKSAmJlxuICAgICAgICAgY29uZmlndXJhdGlvbkVycm9yVGFzayhcbiAgICAgICAgICAgIGBnaXQubG9nKHN0cmluZywgc3RyaW5nKSBzaG91bGQgYmUgcmVwbGFjZWQgd2l0aCBnaXQubG9nKHsgZnJvbTogc3RyaW5nLCB0bzogc3RyaW5nIH0pYFxuICAgICAgICAgKVxuICAgICAgKTtcbiAgIH1cbn1cbiIsICJpbXBvcnQge1xuICAgTWVyZ2VDb25mbGljdCxcbiAgIE1lcmdlQ29uZmxpY3REZWxldGlvbixcbiAgIE1lcmdlRGV0YWlsLFxuICAgTWVyZ2VSZXN1bHRTdGF0dXMsXG59IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuXG5leHBvcnQgY2xhc3MgTWVyZ2VTdW1tYXJ5Q29uZmxpY3QgaW1wbGVtZW50cyBNZXJnZUNvbmZsaWN0IHtcbiAgIGNvbnN0cnVjdG9yKFxuICAgICAgcHVibGljIHJlYWRvbmx5IHJlYXNvbjogc3RyaW5nLFxuICAgICAgcHVibGljIHJlYWRvbmx5IGZpbGU6IHN0cmluZyB8IG51bGwgPSBudWxsLFxuICAgICAgcHVibGljIHJlYWRvbmx5IG1ldGE/OiBNZXJnZUNvbmZsaWN0RGVsZXRpb25cbiAgICkge31cblxuICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5maWxlfToke3RoaXMucmVhc29ufWA7XG4gICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNZXJnZVN1bW1hcnlEZXRhaWwgaW1wbGVtZW50cyBNZXJnZURldGFpbCB7XG4gICBwdWJsaWMgY29uZmxpY3RzOiBNZXJnZUNvbmZsaWN0W10gPSBbXTtcbiAgIHB1YmxpYyBtZXJnZXM6IHN0cmluZ1tdID0gW107XG4gICBwdWJsaWMgcmVzdWx0OiBNZXJnZVJlc3VsdFN0YXR1cyA9ICdzdWNjZXNzJztcblxuICAgZ2V0IGZhaWxlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZsaWN0cy5sZW5ndGggPiAwO1xuICAgfVxuXG4gICBnZXQgcmVhc29uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgfVxuXG4gICB0b1N0cmluZygpIHtcbiAgICAgIGlmICh0aGlzLmNvbmZsaWN0cy5sZW5ndGgpIHtcbiAgICAgICAgIHJldHVybiBgQ09ORkxJQ1RTOiAke3RoaXMuY29uZmxpY3RzLmpvaW4oJywgJyl9YDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdPSyc7XG4gICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgIFB1bGxEZXRhaWxGaWxlQ2hhbmdlcyxcbiAgIFB1bGxEZXRhaWxTdW1tYXJ5LFxuICAgUHVsbEZhaWxlZFJlc3VsdCxcbiAgIFB1bGxSZXN1bHQsXG59IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuXG5leHBvcnQgY2xhc3MgUHVsbFN1bW1hcnkgaW1wbGVtZW50cyBQdWxsUmVzdWx0IHtcbiAgIHB1YmxpYyByZW1vdGVNZXNzYWdlcyA9IHtcbiAgICAgIGFsbDogW10sXG4gICB9O1xuICAgcHVibGljIGNyZWF0ZWQgPSBbXTtcbiAgIHB1YmxpYyBkZWxldGVkOiBzdHJpbmdbXSA9IFtdO1xuICAgcHVibGljIGZpbGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgcHVibGljIGRlbGV0aW9uczogUHVsbERldGFpbEZpbGVDaGFuZ2VzID0ge307XG4gICBwdWJsaWMgaW5zZXJ0aW9uczogUHVsbERldGFpbEZpbGVDaGFuZ2VzID0ge307XG4gICBwdWJsaWMgc3VtbWFyeTogUHVsbERldGFpbFN1bW1hcnkgPSB7XG4gICAgICBjaGFuZ2VzOiAwLFxuICAgICAgZGVsZXRpb25zOiAwLFxuICAgICAgaW5zZXJ0aW9uczogMCxcbiAgIH07XG59XG5cbmV4cG9ydCBjbGFzcyBQdWxsRmFpbGVkU3VtbWFyeSBpbXBsZW1lbnRzIFB1bGxGYWlsZWRSZXN1bHQge1xuICAgcmVtb3RlID0gJyc7XG4gICBoYXNoID0ge1xuICAgICAgbG9jYWw6ICcnLFxuICAgICAgcmVtb3RlOiAnJyxcbiAgIH07XG4gICBicmFuY2ggPSB7XG4gICAgICBsb2NhbDogJycsXG4gICAgICByZW1vdGU6ICcnLFxuICAgfTtcbiAgIG1lc3NhZ2UgPSAnJztcblxuICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgfVxufVxuIiwgImltcG9ydCB7XG4gICBSZW1vdGVNZXNzYWdlUmVzdWx0LFxuICAgUmVtb3RlTWVzc2FnZXMsXG4gICBSZW1vdGVNZXNzYWdlc09iamVjdEVudW1lcmF0aW9uLFxufSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IGFzTnVtYmVyLCBSZW1vdGVMaW5lUGFyc2VyIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5mdW5jdGlvbiBvYmplY3RFbnVtZXJhdGlvblJlc3VsdDxUIGV4dGVuZHMgUmVtb3RlTWVzc2FnZXMgPSBSZW1vdGVNZXNzYWdlcz4oXG4gICByZW1vdGVNZXNzYWdlczogVFxuKTogUmVtb3RlTWVzc2FnZXNPYmplY3RFbnVtZXJhdGlvbiB7XG4gICByZXR1cm4gKHJlbW90ZU1lc3NhZ2VzLm9iamVjdHMgPSByZW1vdGVNZXNzYWdlcy5vYmplY3RzIHx8IHtcbiAgICAgIGNvbXByZXNzaW5nOiAwLFxuICAgICAgY291bnRpbmc6IDAsXG4gICAgICBlbnVtZXJhdGluZzogMCxcbiAgICAgIHBhY2tSZXVzZWQ6IDAsXG4gICAgICByZXVzZWQ6IHsgY291bnQ6IDAsIGRlbHRhOiAwIH0sXG4gICAgICB0b3RhbDogeyBjb3VudDogMCwgZGVsdGE6IDAgfSxcbiAgIH0pO1xufVxuXG5mdW5jdGlvbiBhc09iamVjdENvdW50KHNvdXJjZTogc3RyaW5nKSB7XG4gICBjb25zdCBjb3VudCA9IC9eXFxzKihcXGQrKS8uZXhlYyhzb3VyY2UpO1xuICAgY29uc3QgZGVsdGEgPSAvZGVsdGEgKFxcZCspL2kuZXhlYyhzb3VyY2UpO1xuXG4gICByZXR1cm4ge1xuICAgICAgY291bnQ6IGFzTnVtYmVyKChjb3VudCAmJiBjb3VudFsxXSkgfHwgJzAnKSxcbiAgICAgIGRlbHRhOiBhc051bWJlcigoZGVsdGEgJiYgZGVsdGFbMV0pIHx8ICcwJyksXG4gICB9O1xufVxuXG5leHBvcnQgY29uc3QgcmVtb3RlTWVzc2FnZXNPYmplY3RQYXJzZXJzOiBSZW1vdGVMaW5lUGFyc2VyPFJlbW90ZU1lc3NhZ2VSZXN1bHQ8UmVtb3RlTWVzc2FnZXM+PltdID1cbiAgIFtcbiAgICAgIG5ldyBSZW1vdGVMaW5lUGFyc2VyKFxuICAgICAgICAgL15yZW1vdGU6XFxzKihlbnVtZXJhdGluZ3xjb3VudGluZ3xjb21wcmVzc2luZykgb2JqZWN0czogKFxcZCspLC9pLFxuICAgICAgICAgKHJlc3VsdCwgW2FjdGlvbiwgY291bnRdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBhY3Rpb24udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGVudW1lcmF0aW9uID0gb2JqZWN0RW51bWVyYXRpb25SZXN1bHQocmVzdWx0LnJlbW90ZU1lc3NhZ2VzKTtcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihlbnVtZXJhdGlvbiwgeyBba2V5XTogYXNOdW1iZXIoY291bnQpIH0pO1xuICAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIG5ldyBSZW1vdGVMaW5lUGFyc2VyKFxuICAgICAgICAgL15yZW1vdGU6XFxzKihlbnVtZXJhdGluZ3xjb3VudGluZ3xjb21wcmVzc2luZykgb2JqZWN0czogXFxkKyUgXFwoXFxkK1xcLyhcXGQrKVxcKSwvaSxcbiAgICAgICAgIChyZXN1bHQsIFthY3Rpb24sIGNvdW50XSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYWN0aW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCBlbnVtZXJhdGlvbiA9IG9iamVjdEVudW1lcmF0aW9uUmVzdWx0KHJlc3VsdC5yZW1vdGVNZXNzYWdlcyk7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZW51bWVyYXRpb24sIHsgW2tleV06IGFzTnVtYmVyKGNvdW50KSB9KTtcbiAgICAgICAgIH1cbiAgICAgICksXG4gICAgICBuZXcgUmVtb3RlTGluZVBhcnNlcihcbiAgICAgICAgIC90b3RhbCAoW14sXSspLCByZXVzZWQgKFteLF0rKSwgcGFjay1yZXVzZWQgKFxcZCspL2ksXG4gICAgICAgICAocmVzdWx0LCBbdG90YWwsIHJldXNlZCwgcGFja1JldXNlZF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdHMgPSBvYmplY3RFbnVtZXJhdGlvblJlc3VsdChyZXN1bHQucmVtb3RlTWVzc2FnZXMpO1xuICAgICAgICAgICAgb2JqZWN0cy50b3RhbCA9IGFzT2JqZWN0Q291bnQodG90YWwpO1xuICAgICAgICAgICAgb2JqZWN0cy5yZXVzZWQgPSBhc09iamVjdENvdW50KHJldXNlZCk7XG4gICAgICAgICAgICBvYmplY3RzLnBhY2tSZXVzZWQgPSBhc051bWJlcihwYWNrUmV1c2VkKTtcbiAgICAgICAgIH1cbiAgICAgICksXG4gICBdO1xuIiwgImltcG9ydCB7IFB1c2hSZXN1bHRSZW1vdGVNZXNzYWdlcywgUmVtb3RlTWVzc2FnZVJlc3VsdCwgUmVtb3RlTWVzc2FnZXMgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IGFzTnVtYmVyLCBwYXJzZVN0cmluZ1Jlc3BvbnNlLCBSZW1vdGVMaW5lUGFyc2VyIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgcmVtb3RlTWVzc2FnZXNPYmplY3RQYXJzZXJzIH0gZnJvbSAnLi9wYXJzZS1yZW1vdGUtb2JqZWN0cyc7XG5cbmNvbnN0IHBhcnNlcnM6IFJlbW90ZUxpbmVQYXJzZXI8UmVtb3RlTWVzc2FnZVJlc3VsdDxQdXNoUmVzdWx0UmVtb3RlTWVzc2FnZXMgfCBSZW1vdGVNZXNzYWdlcz4+W10gPVxuICAgW1xuICAgICAgbmV3IFJlbW90ZUxpbmVQYXJzZXIoL15yZW1vdGU6XFxzKiguKykkLywgKHJlc3VsdCwgW3RleHRdKSA9PiB7XG4gICAgICAgICByZXN1bHQucmVtb3RlTWVzc2FnZXMuYWxsLnB1c2godGV4dC50cmltKCkpO1xuICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSksXG4gICAgICAuLi5yZW1vdGVNZXNzYWdlc09iamVjdFBhcnNlcnMsXG4gICAgICBuZXcgUmVtb3RlTGluZVBhcnNlcihcbiAgICAgICAgIFsvY3JlYXRlIGEgKD86cHVsbHxtZXJnZSkgcmVxdWVzdC9pLCAvXFxzKGh0dHBzPzpcXC9cXC9cXFMrKSQvXSxcbiAgICAgICAgIChyZXN1bHQsIFtwdWxsUmVxdWVzdFVybF0pID0+IHtcbiAgICAgICAgICAgIChyZXN1bHQucmVtb3RlTWVzc2FnZXMgYXMgUHVzaFJlc3VsdFJlbW90ZU1lc3NhZ2VzKS5wdWxsUmVxdWVzdFVybCA9IHB1bGxSZXF1ZXN0VXJsO1xuICAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIG5ldyBSZW1vdGVMaW5lUGFyc2VyKFxuICAgICAgICAgWy9mb3VuZCAoXFxkKykgdnVsbmVyYWJpbGl0aWVzLitcXCgoW14pXSspXFwpL2ksIC9cXHMoaHR0cHM/OlxcL1xcL1xcUyspJC9dLFxuICAgICAgICAgKHJlc3VsdCwgW2NvdW50LCBzdW1tYXJ5LCB1cmxdKSA9PiB7XG4gICAgICAgICAgICAocmVzdWx0LnJlbW90ZU1lc3NhZ2VzIGFzIFB1c2hSZXN1bHRSZW1vdGVNZXNzYWdlcykudnVsbmVyYWJpbGl0aWVzID0ge1xuICAgICAgICAgICAgICAgY291bnQ6IGFzTnVtYmVyKGNvdW50KSxcbiAgICAgICAgICAgICAgIHN1bW1hcnksXG4gICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgfVxuICAgICAgKSxcbiAgIF07XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJlbW90ZU1lc3NhZ2VzPFQgZXh0ZW5kcyBSZW1vdGVNZXNzYWdlcyA9IFJlbW90ZU1lc3NhZ2VzPihcbiAgIF9zdGRPdXQ6IHN0cmluZyxcbiAgIHN0ZEVycjogc3RyaW5nXG4pOiBSZW1vdGVNZXNzYWdlUmVzdWx0IHtcbiAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKHsgcmVtb3RlTWVzc2FnZXM6IG5ldyBSZW1vdGVNZXNzYWdlU3VtbWFyeSgpIGFzIFQgfSwgcGFyc2Vycywgc3RkRXJyKTtcbn1cblxuZXhwb3J0IGNsYXNzIFJlbW90ZU1lc3NhZ2VTdW1tYXJ5IGltcGxlbWVudHMgUmVtb3RlTWVzc2FnZXMge1xuICAgcHVibGljIHJlYWRvbmx5IGFsbDogc3RyaW5nW10gPSBbXTtcbn1cbiIsICJpbXBvcnQgeyBQdWxsRGV0YWlsLCBQdWxsRmFpbGVkUmVzdWx0LCBQdWxsUmVzdWx0LCBSZW1vdGVNZXNzYWdlcyB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgUHVsbEZhaWxlZFN1bW1hcnksIFB1bGxTdW1tYXJ5IH0gZnJvbSAnLi4vcmVzcG9uc2VzL1B1bGxTdW1tYXJ5JztcbmltcG9ydCB7IFRhc2tQYXJzZXIgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBhcHBlbmQsIExpbmVQYXJzZXIsIHBhcnNlU3RyaW5nUmVzcG9uc2UgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBwYXJzZVJlbW90ZU1lc3NhZ2VzIH0gZnJvbSAnLi9wYXJzZS1yZW1vdGUtbWVzc2FnZXMnO1xuXG5jb25zdCBGSUxFX1VQREFURV9SRUdFWCA9IC9eXFxzKiguKz8pXFxzK1xcfFxccytcXGQrXFxzKihcXCsqKSgtKikvO1xuY29uc3QgU1VNTUFSWV9SRUdFWCA9IC8oXFxkKylcXEQrKChcXGQrKVxcRCtcXChcXCtcXCkpPyhcXEQrKFxcZCspXFxEK1xcKC1cXCkpPy87XG5jb25zdCBBQ1RJT05fUkVHRVggPSAvXihjcmVhdGV8ZGVsZXRlKSBtb2RlIFxcZCsgKC4rKS87XG5cbmNvbnN0IHBhcnNlcnM6IExpbmVQYXJzZXI8UHVsbFJlc3VsdD5bXSA9IFtcbiAgIG5ldyBMaW5lUGFyc2VyKEZJTEVfVVBEQVRFX1JFR0VYLCAocmVzdWx0LCBbZmlsZSwgaW5zZXJ0aW9ucywgZGVsZXRpb25zXSkgPT4ge1xuICAgICAgcmVzdWx0LmZpbGVzLnB1c2goZmlsZSk7XG5cbiAgICAgIGlmIChpbnNlcnRpb25zKSB7XG4gICAgICAgICByZXN1bHQuaW5zZXJ0aW9uc1tmaWxlXSA9IGluc2VydGlvbnMubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVsZXRpb25zKSB7XG4gICAgICAgICByZXN1bHQuZGVsZXRpb25zW2ZpbGVdID0gZGVsZXRpb25zLmxlbmd0aDtcbiAgICAgIH1cbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoU1VNTUFSWV9SRUdFWCwgKHJlc3VsdCwgW2NoYW5nZXMsICwgaW5zZXJ0aW9ucywgLCBkZWxldGlvbnNdKSA9PiB7XG4gICAgICBpZiAoaW5zZXJ0aW9ucyAhPT0gdW5kZWZpbmVkIHx8IGRlbGV0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICByZXN1bHQuc3VtbWFyeS5jaGFuZ2VzID0gK2NoYW5nZXMgfHwgMDtcbiAgICAgICAgIHJlc3VsdC5zdW1tYXJ5Lmluc2VydGlvbnMgPSAraW5zZXJ0aW9ucyB8fCAwO1xuICAgICAgICAgcmVzdWx0LnN1bW1hcnkuZGVsZXRpb25zID0gK2RlbGV0aW9ucyB8fCAwO1xuICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKEFDVElPTl9SRUdFWCwgKHJlc3VsdCwgW2FjdGlvbiwgZmlsZV0pID0+IHtcbiAgICAgIGFwcGVuZChyZXN1bHQuZmlsZXMsIGZpbGUpO1xuICAgICAgYXBwZW5kKGFjdGlvbiA9PT0gJ2NyZWF0ZScgPyByZXN1bHQuY3JlYXRlZCA6IHJlc3VsdC5kZWxldGVkLCBmaWxlKTtcbiAgIH0pLFxuXTtcblxuY29uc3QgZXJyb3JQYXJzZXJzOiBMaW5lUGFyc2VyPFB1bGxGYWlsZWRSZXN1bHQ+W10gPSBbXG4gICBuZXcgTGluZVBhcnNlcigvXmZyb21cXHMoLispJC9pLCAocmVzdWx0LCBbcmVtb3RlXSkgPT4gdm9pZCAocmVzdWx0LnJlbW90ZSA9IHJlbW90ZSkpLFxuICAgbmV3IExpbmVQYXJzZXIoL15mYXRhbDpcXHMoLispJC8sIChyZXN1bHQsIFttZXNzYWdlXSkgPT4gdm9pZCAocmVzdWx0Lm1lc3NhZ2UgPSBtZXNzYWdlKSksXG4gICBuZXcgTGluZVBhcnNlcihcbiAgICAgIC8oW2EtejAtOV0rKVxcLlxcLihbYS16MC05XSspXFxzKyhcXFMrKVxccystPlxccysoXFxTKykkLyxcbiAgICAgIChyZXN1bHQsIFtoYXNoTG9jYWwsIGhhc2hSZW1vdGUsIGJyYW5jaExvY2FsLCBicmFuY2hSZW1vdGVdKSA9PiB7XG4gICAgICAgICByZXN1bHQuYnJhbmNoLmxvY2FsID0gYnJhbmNoTG9jYWw7XG4gICAgICAgICByZXN1bHQuaGFzaC5sb2NhbCA9IGhhc2hMb2NhbDtcbiAgICAgICAgIHJlc3VsdC5icmFuY2gucmVtb3RlID0gYnJhbmNoUmVtb3RlO1xuICAgICAgICAgcmVzdWx0Lmhhc2gucmVtb3RlID0gaGFzaFJlbW90ZTtcbiAgICAgIH1cbiAgICksXG5dO1xuXG5leHBvcnQgY29uc3QgcGFyc2VQdWxsRGV0YWlsOiBUYXNrUGFyc2VyPHN0cmluZywgUHVsbERldGFpbD4gPSAoc3RkT3V0LCBzdGRFcnIpID0+IHtcbiAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKG5ldyBQdWxsU3VtbWFyeSgpLCBwYXJzZXJzLCBbc3RkT3V0LCBzdGRFcnJdKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVB1bGxSZXN1bHQ6IFRhc2tQYXJzZXI8c3RyaW5nLCBQdWxsUmVzdWx0PiA9IChzdGRPdXQsIHN0ZEVycikgPT4ge1xuICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICBuZXcgUHVsbFN1bW1hcnkoKSxcbiAgICAgIHBhcnNlUHVsbERldGFpbChzdGRPdXQsIHN0ZEVyciksXG4gICAgICBwYXJzZVJlbW90ZU1lc3NhZ2VzPFJlbW90ZU1lc3NhZ2VzPihzdGRPdXQsIHN0ZEVycilcbiAgICk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQdWxsRXJyb3JSZXN1bHQoc3RkT3V0OiBzdHJpbmcsIHN0ZEVycjogc3RyaW5nKSB7XG4gICBjb25zdCBwdWxsRXJyb3IgPSBwYXJzZVN0cmluZ1Jlc3BvbnNlKG5ldyBQdWxsRmFpbGVkU3VtbWFyeSgpLCBlcnJvclBhcnNlcnMsIFtzdGRPdXQsIHN0ZEVycl0pO1xuXG4gICByZXR1cm4gcHVsbEVycm9yLm1lc3NhZ2UgJiYgcHVsbEVycm9yO1xufVxuIiwgImltcG9ydCB7IE1lcmdlRGV0YWlsLCBNZXJnZVJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgTWVyZ2VTdW1tYXJ5Q29uZmxpY3QsIE1lcmdlU3VtbWFyeURldGFpbCB9IGZyb20gJy4uL3Jlc3BvbnNlcy9NZXJnZVN1bW1hcnknO1xuaW1wb3J0IHsgVGFza1BhcnNlciB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IExpbmVQYXJzZXIsIHBhcnNlU3RyaW5nUmVzcG9uc2UgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBwYXJzZVB1bGxSZXN1bHQgfSBmcm9tICcuL3BhcnNlLXB1bGwnO1xuXG5jb25zdCBwYXJzZXJzOiBMaW5lUGFyc2VyPE1lcmdlRGV0YWlsPltdID0gW1xuICAgbmV3IExpbmVQYXJzZXIoL15BdXRvLW1lcmdpbmdcXHMrKC4rKSQvLCAoc3VtbWFyeSwgW2F1dG9NZXJnZV0pID0+IHtcbiAgICAgIHN1bW1hcnkubWVyZ2VzLnB1c2goYXV0b01lcmdlKTtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoL15DT05GTElDVFxccytcXCgoLispXFwpOiBNZXJnZSBjb25mbGljdCBpbiAoLispJC8sIChzdW1tYXJ5LCBbcmVhc29uLCBmaWxlXSkgPT4ge1xuICAgICAgc3VtbWFyeS5jb25mbGljdHMucHVzaChuZXcgTWVyZ2VTdW1tYXJ5Q29uZmxpY3QocmVhc29uLCBmaWxlKSk7XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgL15DT05GTElDVFxccytcXCgoLitcXC9kZWxldGUpXFwpOiAoLispIGRlbGV0ZWQgaW4gKC4rKSBhbmQvLFxuICAgICAgKHN1bW1hcnksIFtyZWFzb24sIGZpbGUsIGRlbGV0ZVJlZl0pID0+IHtcbiAgICAgICAgIHN1bW1hcnkuY29uZmxpY3RzLnB1c2gobmV3IE1lcmdlU3VtbWFyeUNvbmZsaWN0KHJlYXNvbiwgZmlsZSwgeyBkZWxldGVSZWYgfSkpO1xuICAgICAgfVxuICAgKSxcbiAgIG5ldyBMaW5lUGFyc2VyKC9eQ09ORkxJQ1RcXHMrXFwoKC4rKVxcKTovLCAoc3VtbWFyeSwgW3JlYXNvbl0pID0+IHtcbiAgICAgIHN1bW1hcnkuY29uZmxpY3RzLnB1c2gobmV3IE1lcmdlU3VtbWFyeUNvbmZsaWN0KHJlYXNvbiwgbnVsbCkpO1xuICAgfSksXG4gICBuZXcgTGluZVBhcnNlcigvXkF1dG9tYXRpYyBtZXJnZSBmYWlsZWQ7XFxzKyguKykkLywgKHN1bW1hcnksIFtyZXN1bHRdKSA9PiB7XG4gICAgICBzdW1tYXJ5LnJlc3VsdCA9IHJlc3VsdDtcbiAgIH0pLFxuXTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgY29tcGxldGUgcmVzcG9uc2UgZnJvbSBgZ2l0Lm1lcmdlYFxuICovXG5leHBvcnQgY29uc3QgcGFyc2VNZXJnZVJlc3VsdDogVGFza1BhcnNlcjxzdHJpbmcsIE1lcmdlUmVzdWx0PiA9IChzdGRPdXQsIHN0ZEVycikgPT4ge1xuICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocGFyc2VNZXJnZURldGFpbChzdGRPdXQsIHN0ZEVyciksIHBhcnNlUHVsbFJlc3VsdChzdGRPdXQsIHN0ZEVycikpO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgbWVyZ2Ugc3BlY2lmaWMgZGV0YWlsIChpZTogbm90IHRoZSBjb250ZW50IGFsc28gYXZhaWxhYmxlIGluIHRoZSBwdWxsIGRldGFpbCkgZnJvbSBgZ2l0Lm1uZXJnZWBcbiAqIEBwYXJhbSBzdGRPdXRcbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlTWVyZ2VEZXRhaWw6IFRhc2tQYXJzZXI8c3RyaW5nLCBNZXJnZURldGFpbD4gPSAoc3RkT3V0KSA9PiB7XG4gICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZShuZXcgTWVyZ2VTdW1tYXJ5RGV0YWlsKCksIHBhcnNlcnMsIHN0ZE91dCk7XG59O1xuIiwgImltcG9ydCB7IE1lcmdlUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBHaXRSZXNwb25zZUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2dpdC1yZXNwb25zZS1lcnJvcic7XG5pbXBvcnQgeyBwYXJzZU1lcmdlUmVzdWx0IH0gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZS1tZXJnZSc7XG5pbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgY29uZmlndXJhdGlvbkVycm9yVGFzaywgRW1wdHlUYXNrIH0gZnJvbSAnLi90YXNrJztcblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlVGFzayhjdXN0b21BcmdzOiBzdHJpbmdbXSk6IEVtcHR5VGFzayB8IFN0cmluZ1Rhc2s8TWVyZ2VSZXN1bHQ+IHtcbiAgIGlmICghY3VzdG9tQXJncy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKCdHaXQubWVyZ2UgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIG9wdGlvbicpO1xuICAgfVxuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHM6IFsnbWVyZ2UnLCAuLi5jdXN0b21BcmdzXSxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcihzdGRPdXQsIHN0ZEVycik6IE1lcmdlUmVzdWx0IHtcbiAgICAgICAgIGNvbnN0IG1lcmdlID0gcGFyc2VNZXJnZVJlc3VsdChzdGRPdXQsIHN0ZEVycik7XG4gICAgICAgICBpZiAobWVyZ2UuZmFpbGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR2l0UmVzcG9uc2VFcnJvcihtZXJnZSk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHJldHVybiBtZXJnZTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImltcG9ydCB7XG4gICBQdXNoRGV0YWlsLFxuICAgUHVzaFJlc3VsdCxcbiAgIFB1c2hSZXN1bHRQdXNoZWRJdGVtLFxuICAgUHVzaFJlc3VsdFJlbW90ZU1lc3NhZ2VzLFxufSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IFRhc2tQYXJzZXIgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBMaW5lUGFyc2VyLCBwYXJzZVN0cmluZ1Jlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgcGFyc2VSZW1vdGVNZXNzYWdlcyB9IGZyb20gJy4vcGFyc2UtcmVtb3RlLW1lc3NhZ2VzJztcblxuZnVuY3Rpb24gcHVzaFJlc3VsdFB1c2hlZEl0ZW0obG9jYWw6IHN0cmluZywgcmVtb3RlOiBzdHJpbmcsIHN0YXR1czogc3RyaW5nKTogUHVzaFJlc3VsdFB1c2hlZEl0ZW0ge1xuICAgY29uc3QgZGVsZXRlZCA9IHN0YXR1cy5pbmNsdWRlcygnZGVsZXRlZCcpO1xuICAgY29uc3QgdGFnID0gc3RhdHVzLmluY2x1ZGVzKCd0YWcnKSB8fCAvXnJlZnNcXC90YWdzLy50ZXN0KGxvY2FsKTtcbiAgIGNvbnN0IGFscmVhZHlVcGRhdGVkID0gIXN0YXR1cy5pbmNsdWRlcygnbmV3Jyk7XG5cbiAgIHJldHVybiB7XG4gICAgICBkZWxldGVkLFxuICAgICAgdGFnLFxuICAgICAgYnJhbmNoOiAhdGFnLFxuICAgICAgbmV3OiAhYWxyZWFkeVVwZGF0ZWQsXG4gICAgICBhbHJlYWR5VXBkYXRlZCxcbiAgICAgIGxvY2FsLFxuICAgICAgcmVtb3RlLFxuICAgfTtcbn1cblxuY29uc3QgcGFyc2VyczogTGluZVBhcnNlcjxQdXNoRGV0YWlsPltdID0gW1xuICAgbmV3IExpbmVQYXJzZXIoL15QdXNoaW5nIHRvICguKykkLywgKHJlc3VsdCwgW3JlcG9dKSA9PiB7XG4gICAgICByZXN1bHQucmVwbyA9IHJlcG87XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKC9edXBkYXRpbmcgbG9jYWwgdHJhY2tpbmcgcmVmICcoLispJy8sIChyZXN1bHQsIFtsb2NhbF0pID0+IHtcbiAgICAgIHJlc3VsdC5yZWYgPSB7XG4gICAgICAgICAuLi4ocmVzdWx0LnJlZiB8fCB7fSksXG4gICAgICAgICBsb2NhbCxcbiAgICAgIH07XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKC9eWz0qLV1cXHMrKFteOl0rKTooXFxTKylcXHMrXFxbKC4rKV0kLywgKHJlc3VsdCwgW2xvY2FsLCByZW1vdGUsIHR5cGVdKSA9PiB7XG4gICAgICByZXN1bHQucHVzaGVkLnB1c2gocHVzaFJlc3VsdFB1c2hlZEl0ZW0obG9jYWwsIHJlbW90ZSwgdHlwZSkpO1xuICAgfSksXG4gICBuZXcgTGluZVBhcnNlcihcbiAgICAgIC9eQnJhbmNoICcoW14nXSspJyBzZXQgdXAgdG8gdHJhY2sgcmVtb3RlIGJyYW5jaCAnKFteJ10rKScgZnJvbSAnKFteJ10rKScvLFxuICAgICAgKHJlc3VsdCwgW2xvY2FsLCByZW1vdGUsIHJlbW90ZU5hbWVdKSA9PiB7XG4gICAgICAgICByZXN1bHQuYnJhbmNoID0ge1xuICAgICAgICAgICAgLi4uKHJlc3VsdC5icmFuY2ggfHwge30pLFxuICAgICAgICAgICAgbG9jYWwsXG4gICAgICAgICAgICByZW1vdGUsXG4gICAgICAgICAgICByZW1vdGVOYW1lLFxuICAgICAgICAgfTtcbiAgICAgIH1cbiAgICksXG4gICBuZXcgTGluZVBhcnNlcihcbiAgICAgIC9eKFteOl0rKTooXFxTKylcXHMrKFthLXowLTldKylcXC5cXC4oW2EtejAtOV0rKSQvLFxuICAgICAgKHJlc3VsdCwgW2xvY2FsLCByZW1vdGUsIGZyb20sIHRvXSkgPT4ge1xuICAgICAgICAgcmVzdWx0LnVwZGF0ZSA9IHtcbiAgICAgICAgICAgIGhlYWQ6IHtcbiAgICAgICAgICAgICAgIGxvY2FsLFxuICAgICAgICAgICAgICAgcmVtb3RlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhc2g6IHtcbiAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICB9O1xuICAgICAgfVxuICAgKSxcbl07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVB1c2hSZXN1bHQ6IFRhc2tQYXJzZXI8c3RyaW5nLCBQdXNoUmVzdWx0PiA9IChzdGRPdXQsIHN0ZEVycikgPT4ge1xuICAgY29uc3QgcHVzaERldGFpbCA9IHBhcnNlUHVzaERldGFpbChzdGRPdXQsIHN0ZEVycik7XG4gICBjb25zdCByZXNwb25zZURldGFpbCA9IHBhcnNlUmVtb3RlTWVzc2FnZXM8UHVzaFJlc3VsdFJlbW90ZU1lc3NhZ2VzPihzdGRPdXQsIHN0ZEVycik7XG5cbiAgIHJldHVybiB7XG4gICAgICAuLi5wdXNoRGV0YWlsLFxuICAgICAgLi4ucmVzcG9uc2VEZXRhaWwsXG4gICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlUHVzaERldGFpbDogVGFza1BhcnNlcjxzdHJpbmcsIFB1c2hEZXRhaWw+ID0gKHN0ZE91dCwgc3RkRXJyKSA9PiB7XG4gICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZSh7IHB1c2hlZDogW10gfSwgcGFyc2VycywgW3N0ZE91dCwgc3RkRXJyXSk7XG59O1xuIiwgImltcG9ydCB7IFB1c2hSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IHBhcnNlUHVzaFJlc3VsdCBhcyBwYXJzZXIgfSBmcm9tICcuLi9wYXJzZXJzL3BhcnNlLXB1c2gnO1xuaW1wb3J0IHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGFwcGVuZCwgcmVtb3ZlIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG50eXBlIFB1c2hSZWYgPSB7IHJlbW90ZT86IHN0cmluZzsgYnJhbmNoPzogc3RyaW5nIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBwdXNoVGFnc1Rhc2socmVmOiBQdXNoUmVmID0ge30sIGN1c3RvbUFyZ3M6IHN0cmluZ1tdKTogU3RyaW5nVGFzazxQdXNoUmVzdWx0PiB7XG4gICBhcHBlbmQoY3VzdG9tQXJncywgJy0tdGFncycpO1xuICAgcmV0dXJuIHB1c2hUYXNrKHJlZiwgY3VzdG9tQXJncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwdXNoVGFzayhyZWY6IFB1c2hSZWYgPSB7fSwgY3VzdG9tQXJnczogc3RyaW5nW10pOiBTdHJpbmdUYXNrPFB1c2hSZXN1bHQ+IHtcbiAgIGNvbnN0IGNvbW1hbmRzID0gWydwdXNoJywgLi4uY3VzdG9tQXJnc107XG4gICBpZiAocmVmLmJyYW5jaCkge1xuICAgICAgY29tbWFuZHMuc3BsaWNlKDEsIDAsIHJlZi5icmFuY2gpO1xuICAgfVxuICAgaWYgKHJlZi5yZW1vdGUpIHtcbiAgICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCByZWYucmVtb3RlKTtcbiAgIH1cblxuICAgcmVtb3ZlKGNvbW1hbmRzLCAnLXYnKTtcbiAgIGFwcGVuZChjb21tYW5kcywgJy0tdmVyYm9zZScpO1xuICAgYXBwZW5kKGNvbW1hbmRzLCAnLS1wb3JjZWxhaW4nKTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgcGFyc2VyLFxuICAgfTtcbn1cbiIsICJpbXBvcnQgeyBTaW1wbGVHaXQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IFNpbXBsZUdpdEFwaSB9IGZyb20gJy4uL3NpbXBsZS1naXQtYXBpJztcbmltcG9ydCB7IGdldFRyYWlsaW5nT3B0aW9ucywgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgc3RyYWlnaHRUaHJvdWdoQnVmZmVyVGFzaywgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpOiBQaWNrPFNpbXBsZUdpdCwgJ3Nob3dCdWZmZXInIHwgJ3Nob3cnPiB7XG4gICByZXR1cm4ge1xuICAgICAgc2hvd0J1ZmZlcih0aGlzOiBTaW1wbGVHaXRBcGkpIHtcbiAgICAgICAgIGNvbnN0IGNvbW1hbmRzID0gWydzaG93JywgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgMSldO1xuICAgICAgICAgaWYgKCFjb21tYW5kcy5pbmNsdWRlcygnLS1iaW5hcnknKSkge1xuICAgICAgICAgICAgY29tbWFuZHMuc3BsaWNlKDEsIDAsICctLWJpbmFyeScpO1xuICAgICAgICAgfVxuXG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2soY29tbWFuZHMpLFxuICAgICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICAgICk7XG4gICAgICB9LFxuXG4gICAgICBzaG93KHRoaXM6IFNpbXBsZUdpdEFwaSkge1xuICAgICAgICAgY29uc3QgY29tbWFuZHMgPSBbJ3Nob3cnLCAuLi5nZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzLCAxKV07XG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpLFxuICAgICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICAgICk7XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJpbXBvcnQgeyBGaWxlU3RhdHVzUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5cbmV4cG9ydCBjb25zdCBmcm9tUGF0aFJlZ2V4ID0gL14oLispIC0+ICguKykkLztcblxuZXhwb3J0IGNsYXNzIEZpbGVTdGF0dXNTdW1tYXJ5IGltcGxlbWVudHMgRmlsZVN0YXR1c1Jlc3VsdCB7XG4gICBwdWJsaWMgcmVhZG9ubHkgZnJvbTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyBwYXRoOiBzdHJpbmcsXG4gICAgICBwdWJsaWMgaW5kZXg6IHN0cmluZyxcbiAgICAgIHB1YmxpYyB3b3JraW5nX2Rpcjogc3RyaW5nXG4gICApIHtcbiAgICAgIGlmICgnUicgPT09IGluZGV4ICsgd29ya2luZ19kaXIpIHtcbiAgICAgICAgIGNvbnN0IGRldGFpbCA9IGZyb21QYXRoUmVnZXguZXhlYyhwYXRoKSB8fCBbbnVsbCwgcGF0aCwgcGF0aF07XG4gICAgICAgICB0aGlzLmZyb20gPSBkZXRhaWxbMV0gfHwgJyc7XG4gICAgICAgICB0aGlzLnBhdGggPSBkZXRhaWxbMl0gfHwgJyc7XG4gICAgICB9XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgU3RhdHVzUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBhcHBlbmQsIE5VTEwgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBGaWxlU3RhdHVzU3VtbWFyeSB9IGZyb20gJy4vRmlsZVN0YXR1c1N1bW1hcnknO1xuXG50eXBlIFN0YXR1c0xpbmVQYXJzZXIgPSAocmVzdWx0OiBTdGF0dXNSZXN1bHQsIGZpbGU6IHN0cmluZykgPT4gdm9pZDtcblxuZXhwb3J0IGNsYXNzIFN0YXR1c1N1bW1hcnkgaW1wbGVtZW50cyBTdGF0dXNSZXN1bHQge1xuICAgcHVibGljIG5vdF9hZGRlZCA9IFtdO1xuICAgcHVibGljIGNvbmZsaWN0ZWQgPSBbXTtcbiAgIHB1YmxpYyBjcmVhdGVkID0gW107XG4gICBwdWJsaWMgZGVsZXRlZCA9IFtdO1xuICAgcHVibGljIGlnbm9yZWQgPSB1bmRlZmluZWQ7XG4gICBwdWJsaWMgbW9kaWZpZWQgPSBbXTtcbiAgIHB1YmxpYyByZW5hbWVkID0gW107XG4gICBwdWJsaWMgZmlsZXMgPSBbXTtcbiAgIHB1YmxpYyBzdGFnZWQgPSBbXTtcbiAgIHB1YmxpYyBhaGVhZCA9IDA7XG4gICBwdWJsaWMgYmVoaW5kID0gMDtcbiAgIHB1YmxpYyBjdXJyZW50ID0gbnVsbDtcbiAgIHB1YmxpYyB0cmFja2luZyA9IG51bGw7XG4gICBwdWJsaWMgZGV0YWNoZWQgPSBmYWxzZTtcblxuICAgcHVibGljIGlzQ2xlYW4gPSAoKSA9PiB7XG4gICAgICByZXR1cm4gIXRoaXMuZmlsZXMubGVuZ3RoO1xuICAgfTtcbn1cblxuZW51bSBQb3JjZWxhaW5GaWxlU3RhdHVzIHtcbiAgIEFEREVEID0gJ0EnLFxuICAgREVMRVRFRCA9ICdEJyxcbiAgIE1PRElGSUVEID0gJ00nLFxuICAgUkVOQU1FRCA9ICdSJyxcbiAgIENPUElFRCA9ICdDJyxcbiAgIFVOTUVSR0VEID0gJ1UnLFxuICAgVU5UUkFDS0VEID0gJz8nLFxuICAgSUdOT1JFRCA9ICchJyxcbiAgIE5PTkUgPSAnICcsXG59XG5cbmZ1bmN0aW9uIHJlbmFtZWRGaWxlKGxpbmU6IHN0cmluZykge1xuICAgY29uc3QgW3RvLCBmcm9tXSA9IGxpbmUuc3BsaXQoTlVMTCk7XG5cbiAgIHJldHVybiB7XG4gICAgICBmcm9tOiBmcm9tIHx8IHRvLFxuICAgICAgdG8sXG4gICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZXIoXG4gICBpbmRleFg6IFBvcmNlbGFpbkZpbGVTdGF0dXMsXG4gICBpbmRleFk6IFBvcmNlbGFpbkZpbGVTdGF0dXMsXG4gICBoYW5kbGVyOiBTdGF0dXNMaW5lUGFyc2VyXG4pOiBbc3RyaW5nLCBTdGF0dXNMaW5lUGFyc2VyXSB7XG4gICByZXR1cm4gW2Ake2luZGV4WH0ke2luZGV4WX1gLCBoYW5kbGVyXTtcbn1cblxuZnVuY3Rpb24gY29uZmxpY3RzKGluZGV4WDogUG9yY2VsYWluRmlsZVN0YXR1cywgLi4uaW5kZXhZOiBQb3JjZWxhaW5GaWxlU3RhdHVzW10pIHtcbiAgIHJldHVybiBpbmRleFkubWFwKCh5KSA9PiBwYXJzZXIoaW5kZXhYLCB5LCAocmVzdWx0LCBmaWxlKSA9PiBhcHBlbmQocmVzdWx0LmNvbmZsaWN0ZWQsIGZpbGUpKSk7XG59XG5cbmNvbnN0IHBhcnNlcnM6IE1hcDxzdHJpbmcsIFN0YXR1c0xpbmVQYXJzZXI+ID0gbmV3IE1hcChbXG4gICBwYXJzZXIoUG9yY2VsYWluRmlsZVN0YXR1cy5OT05FLCBQb3JjZWxhaW5GaWxlU3RhdHVzLkFEREVELCAocmVzdWx0LCBmaWxlKSA9PlxuICAgICAgYXBwZW5kKHJlc3VsdC5jcmVhdGVkLCBmaWxlKVxuICAgKSxcbiAgIHBhcnNlcihQb3JjZWxhaW5GaWxlU3RhdHVzLk5PTkUsIFBvcmNlbGFpbkZpbGVTdGF0dXMuREVMRVRFRCwgKHJlc3VsdCwgZmlsZSkgPT5cbiAgICAgIGFwcGVuZChyZXN1bHQuZGVsZXRlZCwgZmlsZSlcbiAgICksXG4gICBwYXJzZXIoUG9yY2VsYWluRmlsZVN0YXR1cy5OT05FLCBQb3JjZWxhaW5GaWxlU3RhdHVzLk1PRElGSUVELCAocmVzdWx0LCBmaWxlKSA9PlxuICAgICAgYXBwZW5kKHJlc3VsdC5tb2RpZmllZCwgZmlsZSlcbiAgICksXG5cbiAgIHBhcnNlcihcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuQURERUQsXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLk5PTkUsXG4gICAgICAocmVzdWx0LCBmaWxlKSA9PiBhcHBlbmQocmVzdWx0LmNyZWF0ZWQsIGZpbGUpICYmIGFwcGVuZChyZXN1bHQuc3RhZ2VkLCBmaWxlKVxuICAgKSxcbiAgIHBhcnNlcihcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuQURERUQsXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLk1PRElGSUVELFxuICAgICAgKHJlc3VsdCwgZmlsZSkgPT5cbiAgICAgICAgIGFwcGVuZChyZXN1bHQuY3JlYXRlZCwgZmlsZSkgJiZcbiAgICAgICAgIGFwcGVuZChyZXN1bHQuc3RhZ2VkLCBmaWxlKSAmJlxuICAgICAgICAgYXBwZW5kKHJlc3VsdC5tb2RpZmllZCwgZmlsZSlcbiAgICksXG5cbiAgIHBhcnNlcihcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuREVMRVRFRCxcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuTk9ORSxcbiAgICAgIChyZXN1bHQsIGZpbGUpID0+IGFwcGVuZChyZXN1bHQuZGVsZXRlZCwgZmlsZSkgJiYgYXBwZW5kKHJlc3VsdC5zdGFnZWQsIGZpbGUpXG4gICApLFxuXG4gICBwYXJzZXIoXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLk1PRElGSUVELFxuICAgICAgUG9yY2VsYWluRmlsZVN0YXR1cy5OT05FLFxuICAgICAgKHJlc3VsdCwgZmlsZSkgPT4gYXBwZW5kKHJlc3VsdC5tb2RpZmllZCwgZmlsZSkgJiYgYXBwZW5kKHJlc3VsdC5zdGFnZWQsIGZpbGUpXG4gICApLFxuICAgcGFyc2VyKFxuICAgICAgUG9yY2VsYWluRmlsZVN0YXR1cy5NT0RJRklFRCxcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuTU9ESUZJRUQsXG4gICAgICAocmVzdWx0LCBmaWxlKSA9PiBhcHBlbmQocmVzdWx0Lm1vZGlmaWVkLCBmaWxlKSAmJiBhcHBlbmQocmVzdWx0LnN0YWdlZCwgZmlsZSlcbiAgICksXG5cbiAgIHBhcnNlcihQb3JjZWxhaW5GaWxlU3RhdHVzLlJFTkFNRUQsIFBvcmNlbGFpbkZpbGVTdGF0dXMuTk9ORSwgKHJlc3VsdCwgZmlsZSkgPT4ge1xuICAgICAgYXBwZW5kKHJlc3VsdC5yZW5hbWVkLCByZW5hbWVkRmlsZShmaWxlKSk7XG4gICB9KSxcbiAgIHBhcnNlcihQb3JjZWxhaW5GaWxlU3RhdHVzLlJFTkFNRUQsIFBvcmNlbGFpbkZpbGVTdGF0dXMuTU9ESUZJRUQsIChyZXN1bHQsIGZpbGUpID0+IHtcbiAgICAgIGNvbnN0IHJlbmFtZWQgPSByZW5hbWVkRmlsZShmaWxlKTtcbiAgICAgIGFwcGVuZChyZXN1bHQucmVuYW1lZCwgcmVuYW1lZCk7XG4gICAgICBhcHBlbmQocmVzdWx0Lm1vZGlmaWVkLCByZW5hbWVkLnRvKTtcbiAgIH0pLFxuICAgcGFyc2VyKFBvcmNlbGFpbkZpbGVTdGF0dXMuSUdOT1JFRCwgUG9yY2VsYWluRmlsZVN0YXR1cy5JR05PUkVELCAoX3Jlc3VsdCwgX2ZpbGUpID0+IHtcbiAgICAgIGFwcGVuZCgoX3Jlc3VsdC5pZ25vcmVkID0gX3Jlc3VsdC5pZ25vcmVkIHx8IFtdKSwgX2ZpbGUpO1xuICAgfSksXG5cbiAgIHBhcnNlcihQb3JjZWxhaW5GaWxlU3RhdHVzLlVOVFJBQ0tFRCwgUG9yY2VsYWluRmlsZVN0YXR1cy5VTlRSQUNLRUQsIChyZXN1bHQsIGZpbGUpID0+XG4gICAgICBhcHBlbmQocmVzdWx0Lm5vdF9hZGRlZCwgZmlsZSlcbiAgICksXG5cbiAgIC4uLmNvbmZsaWN0cyhQb3JjZWxhaW5GaWxlU3RhdHVzLkFEREVELCBQb3JjZWxhaW5GaWxlU3RhdHVzLkFEREVELCBQb3JjZWxhaW5GaWxlU3RhdHVzLlVOTUVSR0VEKSxcbiAgIC4uLmNvbmZsaWN0cyhcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuREVMRVRFRCxcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuREVMRVRFRCxcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuVU5NRVJHRURcbiAgICksXG4gICAuLi5jb25mbGljdHMoXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLlVOTUVSR0VELFxuICAgICAgUG9yY2VsYWluRmlsZVN0YXR1cy5BRERFRCxcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuREVMRVRFRCxcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuVU5NRVJHRURcbiAgICksXG5cbiAgIFtcbiAgICAgICcjIycsXG4gICAgICAocmVzdWx0LCBsaW5lKSA9PiB7XG4gICAgICAgICBjb25zdCBhaGVhZFJlZyA9IC9haGVhZCAoXFxkKykvO1xuICAgICAgICAgY29uc3QgYmVoaW5kUmVnID0gL2JlaGluZCAoXFxkKykvO1xuICAgICAgICAgY29uc3QgY3VycmVudFJlZyA9IC9eKC4rPyg/PSg/OlxcLnszfXxcXHN8JCkpKS87XG4gICAgICAgICBjb25zdCB0cmFja2luZ1JlZyA9IC9cXC57M30oXFxTKikvO1xuICAgICAgICAgY29uc3Qgb25FbXB0eUJyYW5jaFJlZyA9IC9cXHNvblxccyhbXFxTXSspJC87XG4gICAgICAgICBsZXQgcmVnZXhSZXN1bHQ7XG5cbiAgICAgICAgIHJlZ2V4UmVzdWx0ID0gYWhlYWRSZWcuZXhlYyhsaW5lKTtcbiAgICAgICAgIHJlc3VsdC5haGVhZCA9IChyZWdleFJlc3VsdCAmJiArcmVnZXhSZXN1bHRbMV0pIHx8IDA7XG5cbiAgICAgICAgIHJlZ2V4UmVzdWx0ID0gYmVoaW5kUmVnLmV4ZWMobGluZSk7XG4gICAgICAgICByZXN1bHQuYmVoaW5kID0gKHJlZ2V4UmVzdWx0ICYmICtyZWdleFJlc3VsdFsxXSkgfHwgMDtcblxuICAgICAgICAgcmVnZXhSZXN1bHQgPSBjdXJyZW50UmVnLmV4ZWMobGluZSk7XG4gICAgICAgICByZXN1bHQuY3VycmVudCA9IHJlZ2V4UmVzdWx0ICYmIHJlZ2V4UmVzdWx0WzFdO1xuXG4gICAgICAgICByZWdleFJlc3VsdCA9IHRyYWNraW5nUmVnLmV4ZWMobGluZSk7XG4gICAgICAgICByZXN1bHQudHJhY2tpbmcgPSByZWdleFJlc3VsdCAmJiByZWdleFJlc3VsdFsxXTtcblxuICAgICAgICAgcmVnZXhSZXN1bHQgPSBvbkVtcHR5QnJhbmNoUmVnLmV4ZWMobGluZSk7XG4gICAgICAgICByZXN1bHQuY3VycmVudCA9IChyZWdleFJlc3VsdCAmJiByZWdleFJlc3VsdFsxXSkgfHwgcmVzdWx0LmN1cnJlbnQ7XG5cbiAgICAgICAgIHJlc3VsdC5kZXRhY2hlZCA9IC9cXChubyBicmFuY2hcXCkvLnRlc3QobGluZSk7XG4gICAgICB9LFxuICAgXSxcbl0pO1xuXG5leHBvcnQgY29uc3QgcGFyc2VTdGF0dXNTdW1tYXJ5ID0gZnVuY3Rpb24gKHRleHQ6IHN0cmluZyk6IFN0YXR1c1Jlc3VsdCB7XG4gICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoTlVMTCk7XG4gICBjb25zdCBzdGF0dXMgPSBuZXcgU3RhdHVzU3VtbWFyeSgpO1xuXG4gICBmb3IgKGxldCBpID0gMCwgbCA9IGxpbmVzLmxlbmd0aDsgaSA8IGw7ICkge1xuICAgICAgbGV0IGxpbmUgPSBsaW5lc1tpKytdLnRyaW0oKTtcblxuICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpbmUuY2hhckF0KDApID09PSBQb3JjZWxhaW5GaWxlU3RhdHVzLlJFTkFNRUQpIHtcbiAgICAgICAgIGxpbmUgKz0gTlVMTCArIChsaW5lc1tpKytdIHx8ICcnKTtcbiAgICAgIH1cblxuICAgICAgc3BsaXRMaW5lKHN0YXR1cywgbGluZSk7XG4gICB9XG5cbiAgIHJldHVybiBzdGF0dXM7XG59O1xuXG5mdW5jdGlvbiBzcGxpdExpbmUocmVzdWx0OiBTdGF0dXNSZXN1bHQsIGxpbmVTdHI6IHN0cmluZykge1xuICAgY29uc3QgdHJpbW1lZCA9IGxpbmVTdHIudHJpbSgpO1xuICAgc3dpdGNoICgnICcpIHtcbiAgICAgIGNhc2UgdHJpbW1lZC5jaGFyQXQoMik6XG4gICAgICAgICByZXR1cm4gZGF0YSh0cmltbWVkLmNoYXJBdCgwKSwgdHJpbW1lZC5jaGFyQXQoMSksIHRyaW1tZWQuc3Vic3RyKDMpKTtcbiAgICAgIGNhc2UgdHJpbW1lZC5jaGFyQXQoMSk6XG4gICAgICAgICByZXR1cm4gZGF0YShQb3JjZWxhaW5GaWxlU3RhdHVzLk5PTkUsIHRyaW1tZWQuY2hhckF0KDApLCB0cmltbWVkLnN1YnN0cigyKSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAgcmV0dXJuO1xuICAgfVxuXG4gICBmdW5jdGlvbiBkYXRhKGluZGV4OiBzdHJpbmcsIHdvcmtpbmdEaXI6IHN0cmluZywgcGF0aDogc3RyaW5nKSB7XG4gICAgICBjb25zdCByYXcgPSBgJHtpbmRleH0ke3dvcmtpbmdEaXJ9YDtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBwYXJzZXJzLmdldChyYXcpO1xuXG4gICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgaGFuZGxlcihyZXN1bHQsIHBhdGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmF3ICE9PSAnIyMnICYmIHJhdyAhPT0gJyEhJykge1xuICAgICAgICAgcmVzdWx0LmZpbGVzLnB1c2gobmV3IEZpbGVTdGF0dXNTdW1tYXJ5KHBhdGgucmVwbGFjZSgvXFwwLiskLywgJycpLCBpbmRleCwgd29ya2luZ0RpcikpO1xuICAgICAgfVxuICAgfVxufVxuIiwgImltcG9ydCB7IFN0YXR1c1Jlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgcGFyc2VTdGF0dXNTdW1tYXJ5IH0gZnJvbSAnLi4vcmVzcG9uc2VzL1N0YXR1c1N1bW1hcnknO1xuaW1wb3J0IHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcblxuY29uc3QgaWdub3JlZE9wdGlvbnMgPSBbJy0tbnVsbCcsICcteiddO1xuXG5leHBvcnQgZnVuY3Rpb24gc3RhdHVzVGFzayhjdXN0b21BcmdzOiBzdHJpbmdbXSk6IFN0cmluZ1Rhc2s8U3RhdHVzUmVzdWx0PiB7XG4gICBjb25zdCBjb21tYW5kcyA9IFtcbiAgICAgICdzdGF0dXMnLFxuICAgICAgJy0tcG9yY2VsYWluJyxcbiAgICAgICctYicsXG4gICAgICAnLXUnLFxuICAgICAgJy0tbnVsbCcsXG4gICAgICAuLi5jdXN0b21BcmdzLmZpbHRlcigoYXJnKSA9PiAhaWdub3JlZE9wdGlvbnMuaW5jbHVkZXMoYXJnKSksXG4gICBdO1xuXG4gICByZXR1cm4ge1xuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgY29tbWFuZHMsXG4gICAgICBwYXJzZXIodGV4dDogc3RyaW5nKSB7XG4gICAgICAgICByZXR1cm4gcGFyc2VTdGF0dXNTdW1tYXJ5KHRleHQpO1xuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBTaW1wbGVHaXRBcGkgfSBmcm9tICcuLi9zaW1wbGUtZ2l0LWFwaSc7XG5pbXBvcnQgdHlwZSB7IFNpbXBsZUdpdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgYXNOdW1iZXIsIEV4aXRDb2RlcywgTGluZVBhcnNlciwgcGFyc2VTdHJpbmdSZXNwb25zZSB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGludGVyZmFjZSBWZXJzaW9uUmVzdWx0IHtcbiAgIG1ham9yOiBudW1iZXI7XG4gICBtaW5vcjogbnVtYmVyO1xuICAgcGF0Y2g6IG51bWJlciB8IHN0cmluZztcbiAgIGFnZW50OiBzdHJpbmc7XG4gICBpbnN0YWxsZWQ6IGJvb2xlYW47XG59XG5cbmNvbnN0IE5PVF9JTlNUQUxMRUQgPSAnaW5zdGFsbGVkPWZhbHNlJztcblxuZnVuY3Rpb24gdmVyc2lvblJlc3BvbnNlKFxuICAgbWFqb3IgPSAwLFxuICAgbWlub3IgPSAwLFxuICAgcGF0Y2g6IHN0cmluZyB8IG51bWJlciA9IDAsXG4gICBhZ2VudCA9ICcnLFxuICAgaW5zdGFsbGVkID0gdHJ1ZVxuKTogVmVyc2lvblJlc3VsdCB7XG4gICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAge1xuICAgICAgICAgbWFqb3IsXG4gICAgICAgICBtaW5vcixcbiAgICAgICAgIHBhdGNoLFxuICAgICAgICAgYWdlbnQsXG4gICAgICAgICBpbnN0YWxsZWQsXG4gICAgICB9LFxuICAgICAgJ3RvU3RyaW5nJyxcbiAgICAgIHtcbiAgICAgICAgIHZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMubWFqb3J9LiR7dGhpcy5taW5vcn0uJHt0aGlzLnBhdGNofWA7XG4gICAgICAgICB9LFxuICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgfVxuICAgKTtcbn1cblxuZnVuY3Rpb24gbm90SW5zdGFsbGVkUmVzcG9uc2UoKSB7XG4gICByZXR1cm4gdmVyc2lvblJlc3BvbnNlKDAsIDAsIDAsICcnLCBmYWxzZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpOiBQaWNrPFNpbXBsZUdpdCwgJ3ZlcnNpb24nPiB7XG4gICByZXR1cm4ge1xuICAgICAgdmVyc2lvbih0aGlzOiBTaW1wbGVHaXRBcGkpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHtcbiAgICAgICAgICAgIGNvbW1hbmRzOiBbJy0tdmVyc2lvbiddLFxuICAgICAgICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgICAgICAgcGFyc2VyOiB2ZXJzaW9uUGFyc2VyLFxuICAgICAgICAgICAgb25FcnJvcihyZXN1bHQsIGVycm9yLCBkb25lLCBmYWlsKSB7XG4gICAgICAgICAgICAgICBpZiAocmVzdWx0LmV4aXRDb2RlID09PSBFeGl0Q29kZXMuTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZG9uZShCdWZmZXIuZnJvbShOT1RfSU5TVEFMTEVEKSk7XG4gICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgIGZhaWwoZXJyb3IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgIH0pO1xuICAgICAgfSxcbiAgIH07XG59XG5cbmNvbnN0IHBhcnNlcnM6IExpbmVQYXJzZXI8VmVyc2lvblJlc3VsdD5bXSA9IFtcbiAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgL3ZlcnNpb24gKFxcZCspXFwuKFxcZCspXFwuKFxcZCspKD86XFxzKlxcKCguKylcXCkpPy8sXG4gICAgICAocmVzdWx0LCBbbWFqb3IsIG1pbm9yLCBwYXRjaCwgYWdlbnQgPSAnJ10pID0+IHtcbiAgICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICB2ZXJzaW9uUmVzcG9uc2UoYXNOdW1iZXIobWFqb3IpLCBhc051bWJlcihtaW5vciksIGFzTnVtYmVyKHBhdGNoKSwgYWdlbnQpXG4gICAgICAgICApO1xuICAgICAgfVxuICAgKSxcbiAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgL3ZlcnNpb24gKFxcZCspXFwuKFxcZCspXFwuKFxcRCspKC4rKT8kLyxcbiAgICAgIChyZXN1bHQsIFttYWpvciwgbWlub3IsIHBhdGNoLCBhZ2VudCA9ICcnXSkgPT4ge1xuICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHZlcnNpb25SZXNwb25zZShhc051bWJlcihtYWpvciksIGFzTnVtYmVyKG1pbm9yKSwgcGF0Y2gsIGFnZW50KSk7XG4gICAgICB9XG4gICApLFxuXTtcblxuZnVuY3Rpb24gdmVyc2lvblBhcnNlcihzdGRPdXQ6IHN0cmluZykge1xuICAgaWYgKHN0ZE91dCA9PT0gTk9UX0lOU1RBTExFRCkge1xuICAgICAgcmV0dXJuIG5vdEluc3RhbGxlZFJlc3BvbnNlKCk7XG4gICB9XG5cbiAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKHZlcnNpb25SZXNwb25zZSgwLCAwLCAwLCBzdGRPdXQpLCBwYXJzZXJzLCBzdGRPdXQpO1xufVxuIiwgImltcG9ydCB7IFNpbXBsZUdpdEJhc2UgfSBmcm9tICcuLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IHRhc2tDYWxsYmFjayB9IGZyb20gJy4vdGFzay1jYWxsYmFjayc7XG5pbXBvcnQgeyBjaGFuZ2VXb3JraW5nRGlyZWN0b3J5VGFzayB9IGZyb20gJy4vdGFza3MvY2hhbmdlLXdvcmtpbmctZGlyZWN0b3J5JztcbmltcG9ydCBjaGVja291dCBmcm9tICcuL3Rhc2tzL2NoZWNrb3V0JztcbmltcG9ydCBjb21taXQgZnJvbSAnLi90YXNrcy9jb21taXQnO1xuaW1wb3J0IGNvbmZpZyBmcm9tICcuL3Rhc2tzL2NvbmZpZyc7XG5pbXBvcnQgZmlyc3RDb21taXQgZnJvbSAnLi90YXNrcy9maXJzdC1jb21taXQnO1xuaW1wb3J0IGdyZXAgZnJvbSAnLi90YXNrcy9ncmVwJztcbmltcG9ydCB7IGhhc2hPYmplY3RUYXNrIH0gZnJvbSAnLi90YXNrcy9oYXNoLW9iamVjdCc7XG5pbXBvcnQgeyBpbml0VGFzayB9IGZyb20gJy4vdGFza3MvaW5pdCc7XG5pbXBvcnQgbG9nIGZyb20gJy4vdGFza3MvbG9nJztcbmltcG9ydCB7IG1lcmdlVGFzayB9IGZyb20gJy4vdGFza3MvbWVyZ2UnO1xuaW1wb3J0IHsgcHVzaFRhc2sgfSBmcm9tICcuL3Rhc2tzL3B1c2gnO1xuaW1wb3J0IHNob3cgZnJvbSAnLi90YXNrcy9zaG93JztcbmltcG9ydCB7IHN0YXR1c1Rhc2sgfSBmcm9tICcuL3Rhc2tzL3N0YXR1cyc7XG5pbXBvcnQgeyBjb25maWd1cmF0aW9uRXJyb3JUYXNrLCBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrIH0gZnJvbSAnLi90YXNrcy90YXNrJztcbmltcG9ydCB2ZXJzaW9uIGZyb20gJy4vdGFza3MvdmVyc2lvbic7XG5pbXBvcnQgeyBvdXRwdXRIYW5kbGVyLCBTaW1wbGVHaXRFeGVjdXRvciwgU2ltcGxlR2l0VGFzaywgU2ltcGxlR2l0VGFza0NhbGxiYWNrIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge1xuICAgYXNBcnJheSxcbiAgIGZpbHRlclN0cmluZyxcbiAgIGZpbHRlclR5cGUsXG4gICBnZXRUcmFpbGluZ09wdGlvbnMsXG4gICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQsXG59IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgY2xhc3MgU2ltcGxlR2l0QXBpIGltcGxlbWVudHMgU2ltcGxlR2l0QmFzZSB7XG4gICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9leGVjdXRvcjogU2ltcGxlR2l0RXhlY3V0b3IpIHt9XG5cbiAgIHByb3RlY3RlZCBfcnVuVGFzazxUPih0YXNrOiBTaW1wbGVHaXRUYXNrPFQ+LCB0aGVuPzogU2ltcGxlR2l0VGFza0NhbGxiYWNrPFQ+KSB7XG4gICAgICBjb25zdCBjaGFpbiA9IHRoaXMuX2V4ZWN1dG9yLmNoYWluKCk7XG4gICAgICBjb25zdCBwcm9taXNlID0gY2hhaW4ucHVzaCh0YXNrKTtcblxuICAgICAgaWYgKHRoZW4pIHtcbiAgICAgICAgIHRhc2tDYWxsYmFjayh0YXNrLCBwcm9taXNlLCB0aGVuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUodGhpcywge1xuICAgICAgICAgdGhlbjogeyB2YWx1ZTogcHJvbWlzZS50aGVuLmJpbmQocHJvbWlzZSkgfSxcbiAgICAgICAgIGNhdGNoOiB7IHZhbHVlOiBwcm9taXNlLmNhdGNoLmJpbmQocHJvbWlzZSkgfSxcbiAgICAgICAgIF9leGVjdXRvcjogeyB2YWx1ZTogY2hhaW4gfSxcbiAgICAgIH0pO1xuICAgfVxuXG4gICBhZGQoZmlsZXM6IHN0cmluZyB8IHN0cmluZ1tdKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soWydhZGQnLCAuLi5hc0FycmF5KGZpbGVzKV0pLFxuICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICk7XG4gICB9XG5cbiAgIGN3ZChkaXJlY3Rvcnk6IHN0cmluZyB8IHsgcGF0aDogc3RyaW5nOyByb290PzogYm9vbGVhbiB9KSB7XG4gICAgICBjb25zdCBuZXh0ID0gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cyk7XG5cbiAgICAgIGlmICh0eXBlb2YgZGlyZWN0b3J5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soY2hhbmdlV29ya2luZ0RpcmVjdG9yeVRhc2soZGlyZWN0b3J5LCB0aGlzLl9leGVjdXRvciksIG5leHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGRpcmVjdG9yeT8ucGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgICAgY2hhbmdlV29ya2luZ0RpcmVjdG9yeVRhc2soXG4gICAgICAgICAgICAgICBkaXJlY3RvcnkucGF0aCxcbiAgICAgICAgICAgICAgIChkaXJlY3Rvcnkucm9vdCAmJiB0aGlzLl9leGVjdXRvcikgfHwgdW5kZWZpbmVkXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbmV4dFxuICAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICBjb25maWd1cmF0aW9uRXJyb3JUYXNrKCdHaXQuY3dkOiB3b3JraW5nRGlyZWN0b3J5IG11c3QgYmUgc3VwcGxpZWQgYXMgYSBzdHJpbmcnKSxcbiAgICAgICAgIG5leHRcbiAgICAgICk7XG4gICB9XG5cbiAgIGhhc2hPYmplY3QocGF0aDogc3RyaW5nLCB3cml0ZTogYm9vbGVhbiB8IHVua25vd24pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgaGFzaE9iamVjdFRhc2socGF0aCwgd3JpdGUgPT09IHRydWUpLFxuICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICk7XG4gICB9XG5cbiAgIGluaXQoYmFyZT86IGJvb2xlYW4gfCB1bmtub3duKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgIGluaXRUYXNrKGJhcmUgPT09IHRydWUsIHRoaXMuX2V4ZWN1dG9yLmN3ZCwgZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cykpLFxuICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICk7XG4gICB9XG5cbiAgIG1lcmdlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICBtZXJnZVRhc2soZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cykpLFxuICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICk7XG4gICB9XG5cbiAgIG1lcmdlRnJvbVRvKHJlbW90ZTogc3RyaW5nLCBicmFuY2g6IHN0cmluZykge1xuICAgICAgaWYgKCEoZmlsdGVyU3RyaW5nKHJlbW90ZSkgJiYgZmlsdGVyU3RyaW5nKGJyYW5jaCkpKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soXG4gICAgICAgICAgICAgICBgR2l0Lm1lcmdlRnJvbVRvIHJlcXVpcmVzIHRoYXQgdGhlICdyZW1vdGUnIGFuZCAnYnJhbmNoJyBhcmd1bWVudHMgYXJlIHN1cHBsaWVkIGFzIHN0cmluZ3NgXG4gICAgICAgICAgICApXG4gICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgIG1lcmdlVGFzayhbcmVtb3RlLCBicmFuY2gsIC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXSksXG4gICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzLCBmYWxzZSlcbiAgICAgICk7XG4gICB9XG5cbiAgIG91dHB1dEhhbmRsZXIoaGFuZGxlcjogb3V0cHV0SGFuZGxlcikge1xuICAgICAgdGhpcy5fZXhlY3V0b3Iub3V0cHV0SGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgIH1cblxuICAgcHVzaCgpIHtcbiAgICAgIGNvbnN0IHRhc2sgPSBwdXNoVGFzayhcbiAgICAgICAgIHtcbiAgICAgICAgICAgIHJlbW90ZTogZmlsdGVyVHlwZShhcmd1bWVudHNbMF0sIGZpbHRlclN0cmluZyksXG4gICAgICAgICAgICBicmFuY2g6IGZpbHRlclR5cGUoYXJndW1lbnRzWzFdLCBmaWx0ZXJTdHJpbmcpLFxuICAgICAgICAgfSxcbiAgICAgICAgIGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKSk7XG4gICB9XG5cbiAgIHN0YXNoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFsnc3Rhc2gnLCAuLi5nZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKV0pLFxuICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICk7XG4gICB9XG5cbiAgIHN0YXR1cygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgc3RhdHVzVGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSksXG4gICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgIH1cbn1cblxuT2JqZWN0LmFzc2lnbihcbiAgIFNpbXBsZUdpdEFwaS5wcm90b3R5cGUsXG4gICBjaGVja291dCgpLFxuICAgY29tbWl0KCksXG4gICBjb25maWcoKSxcbiAgIGZpcnN0Q29tbWl0KCksXG4gICBncmVwKCksXG4gICBsb2coKSxcbiAgIHNob3coKSxcbiAgIHZlcnNpb24oKVxuKTtcbiIsICJpbXBvcnQgeyBhcHBlbmQsIHJlbW92ZSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IGNyZWF0ZURlZmVycmVkLCBEZWZlcnJlZFByb21pc2UgfSBmcm9tICdAa3dzaXRlcy9wcm9taXNlLWRlZmVycmVkJztcbmltcG9ydCB7IGNyZWF0ZUxvZ2dlciB9IGZyb20gJy4uL2dpdC1sb2dnZXInO1xuXG50eXBlIFNjaGVkdWxlQ29tcGxldGVDYWxsYmFjayA9ICgpID0+IHZvaWQ7XG50eXBlIFNjaGVkdWxlZFRhc2sgPSBQaWNrPERlZmVycmVkUHJvbWlzZTxTY2hlZHVsZUNvbXBsZXRlQ2FsbGJhY2s+LCAncHJvbWlzZScgfCAnZG9uZSc+ICYge1xuICAgaWQ6IG51bWJlcjtcbn07XG5cbmNvbnN0IGNyZWF0ZVNjaGVkdWxlZFRhc2s6ICgpID0+IFNjaGVkdWxlZFRhc2sgPSAoKCkgPT4ge1xuICAgbGV0IGlkID0gMDtcbiAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZCsrO1xuICAgICAgY29uc3QgeyBwcm9taXNlLCBkb25lIH0gPSBjcmVhdGVEZWZlcnJlZDxTY2hlZHVsZUNvbXBsZXRlQ2FsbGJhY2s+KCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICBwcm9taXNlLFxuICAgICAgICAgZG9uZSxcbiAgICAgICAgIGlkLFxuICAgICAgfTtcbiAgIH07XG59KSgpO1xuXG5leHBvcnQgY2xhc3MgU2NoZWR1bGVyIHtcbiAgIHByaXZhdGUgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKCcnLCAnc2NoZWR1bGVyJyk7XG4gICBwcml2YXRlIHBlbmRpbmc6IFNjaGVkdWxlZFRhc2tbXSA9IFtdO1xuICAgcHJpdmF0ZSBydW5uaW5nOiBTY2hlZHVsZWRUYXNrW10gPSBbXTtcblxuICAgY29uc3RydWN0b3IocHJpdmF0ZSBjb25jdXJyZW5jeSA9IDIpIHtcbiAgICAgIHRoaXMubG9nZ2VyKGBDb25zdHJ1Y3RlZCwgY29uY3VycmVuY3k9JXNgLCBjb25jdXJyZW5jeSk7XG4gICB9XG5cbiAgIHByaXZhdGUgc2NoZWR1bGUoKSB7XG4gICAgICBpZiAoIXRoaXMucGVuZGluZy5sZW5ndGggfHwgdGhpcy5ydW5uaW5nLmxlbmd0aCA+PSB0aGlzLmNvbmN1cnJlbmN5KSB7XG4gICAgICAgICB0aGlzLmxvZ2dlcihcbiAgICAgICAgICAgIGBTY2hlZHVsZSBhdHRlbXB0IGlnbm9yZWQsIHBlbmRpbmc9JXMgcnVubmluZz0lcyBjb25jdXJyZW5jeT0lc2AsXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmcubGVuZ3RoLFxuICAgICAgICAgICAgdGhpcy5ydW5uaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRoaXMuY29uY3VycmVuY3lcbiAgICAgICAgICk7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRhc2sgPSBhcHBlbmQodGhpcy5ydW5uaW5nLCB0aGlzLnBlbmRpbmcuc2hpZnQoKSEpO1xuICAgICAgdGhpcy5sb2dnZXIoYEF0dGVtcHRpbmcgaWQ9JXNgLCB0YXNrLmlkKTtcbiAgICAgIHRhc2suZG9uZSgoKSA9PiB7XG4gICAgICAgICB0aGlzLmxvZ2dlcihgQ29tcGxldGluZyBpZD1gLCB0YXNrLmlkKTtcbiAgICAgICAgIHJlbW92ZSh0aGlzLnJ1bm5pbmcsIHRhc2spO1xuICAgICAgICAgdGhpcy5zY2hlZHVsZSgpO1xuICAgICAgfSk7XG4gICB9XG5cbiAgIG5leHQoKTogUHJvbWlzZTxTY2hlZHVsZUNvbXBsZXRlQ2FsbGJhY2s+IHtcbiAgICAgIGNvbnN0IHsgcHJvbWlzZSwgaWQgfSA9IGFwcGVuZCh0aGlzLnBlbmRpbmcsIGNyZWF0ZVNjaGVkdWxlZFRhc2soKSk7XG4gICAgICB0aGlzLmxvZ2dlcihgU2NoZWR1bGluZyBpZD0lc2AsIGlkKTtcblxuICAgICAgdGhpcy5zY2hlZHVsZSgpO1xuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrIH0gZnJvbSAnLi90YXNrJztcbmltcG9ydCB7IE9wdGlvbkZsYWdzLCBPcHRpb25zLCBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgdHlwZSBBcHBseU9wdGlvbnMgPSBPcHRpb25zICZcbiAgIE9wdGlvbkZsYWdzPFxuICAgICAgfCAnLS1zdGF0J1xuICAgICAgfCAnLS1udW1zdGF0J1xuICAgICAgfCAnLS1zdW1tYXJ5J1xuICAgICAgfCAnLS1jaGVjaydcbiAgICAgIHwgJy0taW5kZXgnXG4gICAgICB8ICctLWludGVudC10by1hZGQnXG4gICAgICB8ICctLTN3YXknXG4gICAgICB8ICctLWFwcGx5J1xuICAgICAgfCAnLS1uby1hZGQnXG4gICAgICB8ICctUidcbiAgICAgIHwgJy0tcmV2ZXJzZSdcbiAgICAgIHwgJy0tYWxsb3ctYmluYXJ5LXJlcGxhY2VtZW50J1xuICAgICAgfCAnLS1iaW5hcnknXG4gICAgICB8ICctLXJlamVjdCdcbiAgICAgIHwgJy16J1xuICAgICAgfCAnLS1pbmFjY3VyYXRlLWVvZidcbiAgICAgIHwgJy0tcmVjb3VudCdcbiAgICAgIHwgJy0tY2FjaGVkJ1xuICAgICAgfCAnLS1pZ25vcmUtc3BhY2UtY2hhbmdlJ1xuICAgICAgfCAnLS1pZ25vcmUtd2hpdGVzcGFjZSdcbiAgICAgIHwgJy0tdmVyYm9zZSdcbiAgICAgIHwgJy0tdW5zYWZlLXBhdGhzJ1xuICAgPiAmXG4gICBPcHRpb25GbGFnczwnLS13aGl0ZXNwYWNlJywgJ25vd2FybicgfCAnd2FybicgfCAnZml4JyB8ICdlcnJvcicgfCAnZXJyb3ItYWxsJz4gJlxuICAgT3B0aW9uRmxhZ3M8Jy0tYnVpbGQtZmFrZS1hbmNlc3RvcicgfCAnLS1leGNsdWRlJyB8ICctLWluY2x1ZGUnIHwgJy0tZGlyZWN0b3J5Jywgc3RyaW5nPiAmXG4gICBPcHRpb25GbGFnczwnLXAnIHwgJy1DJywgbnVtYmVyPjtcblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UGF0Y2hUYXNrKHBhdGNoZXM6IHN0cmluZ1tdLCBjdXN0b21BcmdzOiBzdHJpbmdbXSk6IFN0cmluZ1Rhc2s8c3RyaW5nPiB7XG4gICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbJ2FwcGx5JywgLi4uY3VzdG9tQXJncywgLi4ucGF0Y2hlc10pO1xufVxuIiwgImltcG9ydCB7XG4gICBCcmFuY2hNdWx0aURlbGV0ZVJlc3VsdCxcbiAgIEJyYW5jaFNpbmdsZURlbGV0ZUZhaWx1cmUsXG4gICBCcmFuY2hTaW5nbGVEZWxldGVSZXN1bHQsXG4gICBCcmFuY2hTaW5nbGVEZWxldGVTdWNjZXNzLFxufSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcblxuZXhwb3J0IGNsYXNzIEJyYW5jaERlbGV0aW9uQmF0Y2ggaW1wbGVtZW50cyBCcmFuY2hNdWx0aURlbGV0ZVJlc3VsdCB7XG4gICBhbGw6IEJyYW5jaFNpbmdsZURlbGV0ZVJlc3VsdFtdID0gW107XG4gICBicmFuY2hlczogeyBbYnJhbmNoTmFtZTogc3RyaW5nXTogQnJhbmNoU2luZ2xlRGVsZXRlUmVzdWx0IH0gPSB7fTtcbiAgIGVycm9yczogQnJhbmNoU2luZ2xlRGVsZXRlUmVzdWx0W10gPSBbXTtcblxuICAgZ2V0IHN1Y2Nlc3MoKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gIXRoaXMuZXJyb3JzLmxlbmd0aDtcbiAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJyYW5jaERlbGV0aW9uU3VjY2VzcyhicmFuY2g6IHN0cmluZywgaGFzaDogc3RyaW5nKTogQnJhbmNoU2luZ2xlRGVsZXRlU3VjY2VzcyB7XG4gICByZXR1cm4ge1xuICAgICAgYnJhbmNoLFxuICAgICAgaGFzaCxcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnJhbmNoRGVsZXRpb25GYWlsdXJlKGJyYW5jaDogc3RyaW5nKTogQnJhbmNoU2luZ2xlRGVsZXRlRmFpbHVyZSB7XG4gICByZXR1cm4ge1xuICAgICAgYnJhbmNoLFxuICAgICAgaGFzaDogbnVsbCxcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2luZ2xlQnJhbmNoRGVsZXRlRmFpbHVyZShcbiAgIHRlc3Q6IEJyYW5jaFNpbmdsZURlbGV0ZVJlc3VsdFxuKTogdGVzdCBpcyBCcmFuY2hTaW5nbGVEZWxldGVTdWNjZXNzIHtcbiAgIHJldHVybiB0ZXN0LnN1Y2Nlc3M7XG59XG4iLCAiaW1wb3J0IHsgQnJhbmNoTXVsdGlEZWxldGVSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7XG4gICBCcmFuY2hEZWxldGlvbkJhdGNoLFxuICAgYnJhbmNoRGVsZXRpb25GYWlsdXJlLFxuICAgYnJhbmNoRGVsZXRpb25TdWNjZXNzLFxufSBmcm9tICcuLi9yZXNwb25zZXMvQnJhbmNoRGVsZXRlU3VtbWFyeSc7XG5pbXBvcnQgeyBUYXNrUGFyc2VyIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgRXhpdENvZGVzLCBMaW5lUGFyc2VyLCBwYXJzZVN0cmluZ1Jlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jb25zdCBkZWxldGVTdWNjZXNzUmVnZXggPSAvKFxcUyspXFxzK1xcKFxcUytcXHMoW14pXSspXFwpLztcbmNvbnN0IGRlbGV0ZUVycm9yUmVnZXggPSAvXmVycm9yW14nXSsnKFteJ10rKScvbTtcblxuY29uc3QgcGFyc2VyczogTGluZVBhcnNlcjxCcmFuY2hNdWx0aURlbGV0ZVJlc3VsdD5bXSA9IFtcbiAgIG5ldyBMaW5lUGFyc2VyKGRlbGV0ZVN1Y2Nlc3NSZWdleCwgKHJlc3VsdCwgW2JyYW5jaCwgaGFzaF0pID0+IHtcbiAgICAgIGNvbnN0IGRlbGV0aW9uID0gYnJhbmNoRGVsZXRpb25TdWNjZXNzKGJyYW5jaCwgaGFzaCk7XG5cbiAgICAgIHJlc3VsdC5hbGwucHVzaChkZWxldGlvbik7XG4gICAgICByZXN1bHQuYnJhbmNoZXNbYnJhbmNoXSA9IGRlbGV0aW9uO1xuICAgfSksXG4gICBuZXcgTGluZVBhcnNlcihkZWxldGVFcnJvclJlZ2V4LCAocmVzdWx0LCBbYnJhbmNoXSkgPT4ge1xuICAgICAgY29uc3QgZGVsZXRpb24gPSBicmFuY2hEZWxldGlvbkZhaWx1cmUoYnJhbmNoKTtcblxuICAgICAgcmVzdWx0LmVycm9ycy5wdXNoKGRlbGV0aW9uKTtcbiAgICAgIHJlc3VsdC5hbGwucHVzaChkZWxldGlvbik7XG4gICAgICByZXN1bHQuYnJhbmNoZXNbYnJhbmNoXSA9IGRlbGV0aW9uO1xuICAgfSksXG5dO1xuXG5leHBvcnQgY29uc3QgcGFyc2VCcmFuY2hEZWxldGlvbnM6IFRhc2tQYXJzZXI8c3RyaW5nLCBCcmFuY2hNdWx0aURlbGV0ZVJlc3VsdD4gPSAoXG4gICBzdGRPdXQsXG4gICBzdGRFcnJcbikgPT4ge1xuICAgcmV0dXJuIHBhcnNlU3RyaW5nUmVzcG9uc2UobmV3IEJyYW5jaERlbGV0aW9uQmF0Y2goKSwgcGFyc2VycywgW3N0ZE91dCwgc3RkRXJyXSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gaGFzQnJhbmNoRGVsZXRpb25FcnJvcihkYXRhOiBzdHJpbmcsIHByb2Nlc3NFeGl0Q29kZTogRXhpdENvZGVzKTogYm9vbGVhbiB7XG4gICByZXR1cm4gcHJvY2Vzc0V4aXRDb2RlID09PSBFeGl0Q29kZXMuRVJST1IgJiYgZGVsZXRlRXJyb3JSZWdleC50ZXN0KGRhdGEpO1xufVxuIiwgImltcG9ydCB0eXBlIHsgQnJhbmNoU3VtbWFyeSwgQnJhbmNoU3VtbWFyeUJyYW5jaCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuXG5leHBvcnQgZW51bSBCcmFuY2hTdGF0dXNJZGVudGlmaWVyIHtcbiAgIENVUlJFTlQgPSAnKicsXG4gICBMSU5LRUQgPSAnKycsXG59XG5cbmV4cG9ydCBjbGFzcyBCcmFuY2hTdW1tYXJ5UmVzdWx0IGltcGxlbWVudHMgQnJhbmNoU3VtbWFyeSB7XG4gICBwdWJsaWMgYWxsOiBzdHJpbmdbXSA9IFtdO1xuICAgcHVibGljIGJyYW5jaGVzOiB7IFtwOiBzdHJpbmddOiBCcmFuY2hTdW1tYXJ5QnJhbmNoIH0gPSB7fTtcbiAgIHB1YmxpYyBjdXJyZW50OiBzdHJpbmcgPSAnJztcbiAgIHB1YmxpYyBkZXRhY2hlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICBwdXNoKFxuICAgICAgc3RhdHVzOiBCcmFuY2hTdGF0dXNJZGVudGlmaWVyIHwgdW5rbm93bixcbiAgICAgIGRldGFjaGVkOiBib29sZWFuLFxuICAgICAgbmFtZTogc3RyaW5nLFxuICAgICAgY29tbWl0OiBzdHJpbmcsXG4gICAgICBsYWJlbDogc3RyaW5nXG4gICApIHtcbiAgICAgIGlmIChzdGF0dXMgPT09IEJyYW5jaFN0YXR1c0lkZW50aWZpZXIuQ1VSUkVOVCkge1xuICAgICAgICAgdGhpcy5kZXRhY2hlZCA9IGRldGFjaGVkO1xuICAgICAgICAgdGhpcy5jdXJyZW50ID0gbmFtZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hbGwucHVzaChuYW1lKTtcbiAgICAgIHRoaXMuYnJhbmNoZXNbbmFtZV0gPSB7XG4gICAgICAgICBjdXJyZW50OiBzdGF0dXMgPT09IEJyYW5jaFN0YXR1c0lkZW50aWZpZXIuQ1VSUkVOVCxcbiAgICAgICAgIGxpbmtlZFdvcmtUcmVlOiBzdGF0dXMgPT09IEJyYW5jaFN0YXR1c0lkZW50aWZpZXIuTElOS0VELFxuICAgICAgICAgbmFtZSxcbiAgICAgICAgIGNvbW1pdCxcbiAgICAgICAgIGxhYmVsLFxuICAgICAgfTtcbiAgIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IEJyYW5jaFN1bW1hcnkgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IEJyYW5jaFN1bW1hcnlSZXN1bHQgfSBmcm9tICcuLi9yZXNwb25zZXMvQnJhbmNoU3VtbWFyeSc7XG5pbXBvcnQgeyBMaW5lUGFyc2VyLCBwYXJzZVN0cmluZ1Jlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jb25zdCBwYXJzZXJzOiBMaW5lUGFyc2VyPEJyYW5jaFN1bW1hcnlSZXN1bHQ+W10gPSBbXG4gICBuZXcgTGluZVBhcnNlcihcbiAgICAgIC9eKFsqK11cXHMpP1xcKCg/OkhFQUQgKT9kZXRhY2hlZCAoPzpmcm9tfGF0KSAoXFxTKylcXClcXHMrKFthLXowLTldKylcXHMoLiopJC8sXG4gICAgICAocmVzdWx0LCBbY3VycmVudCwgbmFtZSwgY29tbWl0LCBsYWJlbF0pID0+IHtcbiAgICAgICAgIHJlc3VsdC5wdXNoKGJyYW5jaFN0YXR1cyhjdXJyZW50KSwgdHJ1ZSwgbmFtZSwgY29tbWl0LCBsYWJlbCk7XG4gICAgICB9XG4gICApLFxuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvXihbKitdXFxzKT8oXFxTKylcXHMrKFthLXowLTldKylcXHM/KC4qKSQvcyxcbiAgICAgIChyZXN1bHQsIFtjdXJyZW50LCBuYW1lLCBjb21taXQsIGxhYmVsXSkgPT4ge1xuICAgICAgICAgcmVzdWx0LnB1c2goYnJhbmNoU3RhdHVzKGN1cnJlbnQpLCBmYWxzZSwgbmFtZSwgY29tbWl0LCBsYWJlbCk7XG4gICAgICB9XG4gICApLFxuXTtcblxuZnVuY3Rpb24gYnJhbmNoU3RhdHVzKGlucHV0Pzogc3RyaW5nKSB7XG4gICByZXR1cm4gaW5wdXQgPyBpbnB1dC5jaGFyQXQoMCkgOiAnJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQnJhbmNoU3VtbWFyeShzdGRPdXQ6IHN0cmluZyk6IEJyYW5jaFN1bW1hcnkge1xuICAgcmV0dXJuIHBhcnNlU3RyaW5nUmVzcG9uc2UobmV3IEJyYW5jaFN1bW1hcnlSZXN1bHQoKSwgcGFyc2Vycywgc3RkT3V0KTtcbn1cbiIsICJpbXBvcnQgeyBCcmFuY2hNdWx0aURlbGV0ZVJlc3VsdCwgQnJhbmNoU2luZ2xlRGVsZXRlUmVzdWx0LCBCcmFuY2hTdW1tYXJ5IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgR2l0UmVzcG9uc2VFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9naXQtcmVzcG9uc2UtZXJyb3InO1xuaW1wb3J0IHsgaGFzQnJhbmNoRGVsZXRpb25FcnJvciwgcGFyc2VCcmFuY2hEZWxldGlvbnMgfSBmcm9tICcuLi9wYXJzZXJzL3BhcnNlLWJyYW5jaC1kZWxldGUnO1xuaW1wb3J0IHsgcGFyc2VCcmFuY2hTdW1tYXJ5IH0gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZS1icmFuY2gnO1xuaW1wb3J0IHsgYnVmZmVyVG9TdHJpbmcgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc0RlbGV0ZUJyYW5jaENvbW1hbmQoY29tbWFuZHM6IHN0cmluZ1tdKSB7XG4gICBjb25zdCBkZWxldGVDb21tYW5kcyA9IFsnLWQnLCAnLUQnLCAnLS1kZWxldGUnXTtcbiAgIHJldHVybiBjb21tYW5kcy5zb21lKChjb21tYW5kKSA9PiBkZWxldGVDb21tYW5kcy5pbmNsdWRlcyhjb21tYW5kKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBicmFuY2hUYXNrKFxuICAgY3VzdG9tQXJnczogc3RyaW5nW11cbik6IFN0cmluZ1Rhc2s8QnJhbmNoU3VtbWFyeSB8IEJyYW5jaFNpbmdsZURlbGV0ZVJlc3VsdD4ge1xuICAgY29uc3QgaXNEZWxldGUgPSBjb250YWluc0RlbGV0ZUJyYW5jaENvbW1hbmQoY3VzdG9tQXJncyk7XG4gICBjb25zdCBjb21tYW5kcyA9IFsnYnJhbmNoJywgLi4uY3VzdG9tQXJnc107XG5cbiAgIGlmIChjb21tYW5kcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goJy1hJyk7XG4gICB9XG5cbiAgIGlmICghY29tbWFuZHMuaW5jbHVkZXMoJy12JykpIHtcbiAgICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCAnLXYnKTtcbiAgIH1cblxuICAgcmV0dXJuIHtcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgcGFyc2VyKHN0ZE91dCwgc3RkRXJyKSB7XG4gICAgICAgICBpZiAoaXNEZWxldGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUJyYW5jaERlbGV0aW9ucyhzdGRPdXQsIHN0ZEVycikuYWxsWzBdO1xuICAgICAgICAgfVxuXG4gICAgICAgICByZXR1cm4gcGFyc2VCcmFuY2hTdW1tYXJ5KHN0ZE91dCk7XG4gICAgICB9LFxuICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJyYW5jaExvY2FsVGFzaygpOiBTdHJpbmdUYXNrPEJyYW5jaFN1bW1hcnk+IHtcbiAgIGNvbnN0IHBhcnNlciA9IHBhcnNlQnJhbmNoU3VtbWFyeTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIGNvbW1hbmRzOiBbJ2JyYW5jaCcsICctdiddLFxuICAgICAgcGFyc2VyLFxuICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZUJyYW5jaGVzVGFzayhcbiAgIGJyYW5jaGVzOiBzdHJpbmdbXSxcbiAgIGZvcmNlRGVsZXRlID0gZmFsc2Vcbik6IFN0cmluZ1Rhc2s8QnJhbmNoTXVsdGlEZWxldGVSZXN1bHQ+IHtcbiAgIHJldHVybiB7XG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBjb21tYW5kczogWydicmFuY2gnLCAnLXYnLCBmb3JjZURlbGV0ZSA/ICctRCcgOiAnLWQnLCAuLi5icmFuY2hlc10sXG4gICAgICBwYXJzZXIoc3RkT3V0LCBzdGRFcnIpIHtcbiAgICAgICAgIHJldHVybiBwYXJzZUJyYW5jaERlbGV0aW9ucyhzdGRPdXQsIHN0ZEVycik7XG4gICAgICB9LFxuICAgICAgb25FcnJvcih7IGV4aXRDb2RlLCBzdGRPdXQgfSwgZXJyb3IsIGRvbmUsIGZhaWwpIHtcbiAgICAgICAgIGlmICghaGFzQnJhbmNoRGVsZXRpb25FcnJvcihTdHJpbmcoZXJyb3IpLCBleGl0Q29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsKGVycm9yKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgZG9uZShzdGRPdXQpO1xuICAgICAgfSxcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVCcmFuY2hUYXNrKFxuICAgYnJhbmNoOiBzdHJpbmcsXG4gICBmb3JjZURlbGV0ZSA9IGZhbHNlXG4pOiBTdHJpbmdUYXNrPEJyYW5jaFNpbmdsZURlbGV0ZVJlc3VsdD4ge1xuICAgY29uc3QgdGFzazogU3RyaW5nVGFzazxCcmFuY2hTaW5nbGVEZWxldGVSZXN1bHQ+ID0ge1xuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgY29tbWFuZHM6IFsnYnJhbmNoJywgJy12JywgZm9yY2VEZWxldGUgPyAnLUQnIDogJy1kJywgYnJhbmNoXSxcbiAgICAgIHBhcnNlcihzdGRPdXQsIHN0ZEVycikge1xuICAgICAgICAgcmV0dXJuIHBhcnNlQnJhbmNoRGVsZXRpb25zKHN0ZE91dCwgc3RkRXJyKS5icmFuY2hlc1ticmFuY2hdITtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yKHsgZXhpdENvZGUsIHN0ZEVyciwgc3RkT3V0IH0sIGVycm9yLCBfLCBmYWlsKSB7XG4gICAgICAgICBpZiAoIWhhc0JyYW5jaERlbGV0aW9uRXJyb3IoU3RyaW5nKGVycm9yKSwgZXhpdENvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbChlcnJvcik7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRocm93IG5ldyBHaXRSZXNwb25zZUVycm9yKFxuICAgICAgICAgICAgdGFzay5wYXJzZXIoYnVmZmVyVG9TdHJpbmcoc3RkT3V0KSwgYnVmZmVyVG9TdHJpbmcoc3RkRXJyKSksXG4gICAgICAgICAgICBTdHJpbmcoZXJyb3IpXG4gICAgICAgICApO1xuICAgICAgfSxcbiAgIH07XG5cbiAgIHJldHVybiB0YXNrO1xufVxuIiwgIi8qKlxuICogUGFyc2VyIGZvciB0aGUgYGNoZWNrLWlnbm9yZWAgY29tbWFuZCAtIHJldHVybnMgZWFjaCBmaWxlIGFzIGEgc3RyaW5nIGFycmF5XG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZUNoZWNrSWdub3JlID0gKHRleHQ6IHN0cmluZyk6IHN0cmluZ1tdID0+IHtcbiAgIHJldHVybiB0ZXh0XG4gICAgICAuc3BsaXQoL1xcbi9nKVxuICAgICAgLm1hcCgobGluZSkgPT4gbGluZS50cmltKCkpXG4gICAgICAuZmlsdGVyKChmaWxlKSA9PiAhIWZpbGUpO1xufTtcbiIsICJpbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgcGFyc2VDaGVja0lnbm9yZSB9IGZyb20gJy4uL3Jlc3BvbnNlcy9DaGVja0lnbm9yZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0lnbm9yZVRhc2socGF0aHM6IHN0cmluZ1tdKTogU3RyaW5nVGFzazxzdHJpbmdbXT4ge1xuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzOiBbJ2NoZWNrLWlnbm9yZScsIC4uLnBhdGhzXSxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcjogcGFyc2VDaGVja0lnbm9yZSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgY29uZmlndXJhdGlvbkVycm9yVGFzaywgRW1wdHlUYXNrLCBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrIH0gZnJvbSAnLi90YXNrJztcbmltcG9ydCB7IE9wdGlvbkZsYWdzLCBPcHRpb25zLCBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgYXBwZW5kLCBmaWx0ZXJTdHJpbmcgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCB0eXBlIENsb25lT3B0aW9ucyA9IE9wdGlvbnMgJlxuICAgT3B0aW9uRmxhZ3M8XG4gICAgICB8ICctLWJhcmUnXG4gICAgICB8ICctLWRpc3NvY2lhdGUnXG4gICAgICB8ICctLW1pcnJvcidcbiAgICAgIHwgJy0tbm8tY2hlY2tvdXQnXG4gICAgICB8ICctLW5vLXJlbW90ZS1zdWJtb2R1bGVzJ1xuICAgICAgfCAnLS1uby1zaGFsbG93LXN1Ym1vZHVsZXMnXG4gICAgICB8ICctLW5vLXNpbmdsZS1icmFuY2gnXG4gICAgICB8ICctLW5vLXRhZ3MnXG4gICAgICB8ICctLXJlbW90ZS1zdWJtb2R1bGVzJ1xuICAgICAgfCAnLS1zaW5nbGUtYnJhbmNoJ1xuICAgICAgfCAnLS1zaGFsbG93LXN1Ym1vZHVsZXMnXG4gICAgICB8ICctLXZlcmJvc2UnXG4gICA+ICZcbiAgIE9wdGlvbkZsYWdzPCctLWRlcHRoJyB8ICctaicgfCAnLS1qb2JzJywgbnVtYmVyPiAmXG4gICBPcHRpb25GbGFnczxcbiAgICAgIHwgJy0tYnJhbmNoJ1xuICAgICAgfCAnLS1vcmlnaW4nXG4gICAgICB8ICctLXJlY3Vyc2Utc3VibW9kdWxlcydcbiAgICAgIHwgJy0tc2VwYXJhdGUtZ2l0LWRpcidcbiAgICAgIHwgJy0tc2hhbGxvdy1leGNsdWRlJ1xuICAgICAgfCAnLS1zaGFsbG93LXNpbmNlJ1xuICAgICAgfCAnLS10ZW1wbGF0ZScsXG4gICAgICBzdHJpbmdcbiAgID47XG5cbmZ1bmN0aW9uIGRpc2FsbG93ZWRDb21tYW5kKGNvbW1hbmQ6IHN0cmluZykge1xuICAgcmV0dXJuIC9eLS11cGxvYWQtcGFjayg9fCQpLy50ZXN0KGNvbW1hbmQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVUYXNrKFxuICAgcmVwbzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgZGlyZWN0b3J5OiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICBjdXN0b21BcmdzOiBzdHJpbmdbXVxuKTogU3RyaW5nVGFzazxzdHJpbmc+IHwgRW1wdHlUYXNrIHtcbiAgIGNvbnN0IGNvbW1hbmRzID0gWydjbG9uZScsIC4uLmN1c3RvbUFyZ3NdO1xuXG4gICBmaWx0ZXJTdHJpbmcocmVwbykgJiYgY29tbWFuZHMucHVzaChyZXBvKTtcbiAgIGZpbHRlclN0cmluZyhkaXJlY3RvcnkpICYmIGNvbW1hbmRzLnB1c2goZGlyZWN0b3J5KTtcblxuICAgY29uc3QgYmFubmVkID0gY29tbWFuZHMuZmluZChkaXNhbGxvd2VkQ29tbWFuZCk7XG4gICBpZiAoYmFubmVkKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhgZ2l0LmZldGNoOiBwb3RlbnRpYWwgZXhwbG9pdCBhcmd1bWVudCBibG9ja2VkLmApO1xuICAgfVxuXG4gICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZU1pcnJvclRhc2soXG4gICByZXBvOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICBkaXJlY3Rvcnk6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgIGN1c3RvbUFyZ3M6IHN0cmluZ1tdXG4pIHtcbiAgIGFwcGVuZChjdXN0b21BcmdzLCAnLS1taXJyb3InKTtcblxuICAgcmV0dXJuIGNsb25lVGFzayhyZXBvLCBkaXJlY3RvcnksIGN1c3RvbUFyZ3MpO1xufVxuIiwgImltcG9ydCB7IEZldGNoUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBMaW5lUGFyc2VyLCBwYXJzZVN0cmluZ1Jlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jb25zdCBwYXJzZXJzOiBMaW5lUGFyc2VyPEZldGNoUmVzdWx0PltdID0gW1xuICAgbmV3IExpbmVQYXJzZXIoL0Zyb20gKC4rKSQvLCAocmVzdWx0LCBbcmVtb3RlXSkgPT4ge1xuICAgICAgcmVzdWx0LnJlbW90ZSA9IHJlbW90ZTtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoL1xcKiBcXFtuZXcgYnJhbmNoXVxccysoXFxTKylcXHMqLT4gKC4rKSQvLCAocmVzdWx0LCBbbmFtZSwgdHJhY2tpbmddKSA9PiB7XG4gICAgICByZXN1bHQuYnJhbmNoZXMucHVzaCh7XG4gICAgICAgICBuYW1lLFxuICAgICAgICAgdHJhY2tpbmcsXG4gICAgICB9KTtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoL1xcKiBcXFtuZXcgdGFnXVxccysoXFxTKylcXHMqLT4gKC4rKSQvLCAocmVzdWx0LCBbbmFtZSwgdHJhY2tpbmddKSA9PiB7XG4gICAgICByZXN1bHQudGFncy5wdXNoKHtcbiAgICAgICAgIG5hbWUsXG4gICAgICAgICB0cmFja2luZyxcbiAgICAgIH0pO1xuICAgfSksXG4gICBuZXcgTGluZVBhcnNlcigvLSBcXFtkZWxldGVkXVxccytcXFMrXFxzKi0+ICguKykkLywgKHJlc3VsdCwgW3RyYWNraW5nXSkgPT4ge1xuICAgICAgcmVzdWx0LmRlbGV0ZWQucHVzaCh7XG4gICAgICAgICB0cmFja2luZyxcbiAgICAgIH0pO1xuICAgfSksXG4gICBuZXcgTGluZVBhcnNlcihcbiAgICAgIC9cXHMqKFteLl0rKVxcLlxcLihcXFMrKVxccysoXFxTKylcXHMqLT4gKC4rKSQvLFxuICAgICAgKHJlc3VsdCwgW2Zyb20sIHRvLCBuYW1lLCB0cmFja2luZ10pID0+IHtcbiAgICAgICAgIHJlc3VsdC51cGRhdGVkLnB1c2goe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHRyYWNraW5nLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgfSk7XG4gICAgICB9XG4gICApLFxuXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRmV0Y2hSZXN1bHQoc3RkT3V0OiBzdHJpbmcsIHN0ZEVycjogc3RyaW5nKTogRmV0Y2hSZXN1bHQge1xuICAgY29uc3QgcmVzdWx0OiBGZXRjaFJlc3VsdCA9IHtcbiAgICAgIHJhdzogc3RkT3V0LFxuICAgICAgcmVtb3RlOiBudWxsLFxuICAgICAgYnJhbmNoZXM6IFtdLFxuICAgICAgdGFnczogW10sXG4gICAgICB1cGRhdGVkOiBbXSxcbiAgICAgIGRlbGV0ZWQ6IFtdLFxuICAgfTtcbiAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKHJlc3VsdCwgcGFyc2VycywgW3N0ZE91dCwgc3RkRXJyXSk7XG59XG4iLCAiaW1wb3J0IHsgRmV0Y2hSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IHBhcnNlRmV0Y2hSZXN1bHQgfSBmcm9tICcuLi9wYXJzZXJzL3BhcnNlLWZldGNoJztcbmltcG9ydCB7IFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNvbmZpZ3VyYXRpb25FcnJvclRhc2ssIEVtcHR5VGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmZ1bmN0aW9uIGRpc2FsbG93ZWRDb21tYW5kKGNvbW1hbmQ6IHN0cmluZykge1xuICAgcmV0dXJuIC9eLS11cGxvYWQtcGFjayg9fCQpLy50ZXN0KGNvbW1hbmQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2hUYXNrKFxuICAgcmVtb3RlOiBzdHJpbmcsXG4gICBicmFuY2g6IHN0cmluZyxcbiAgIGN1c3RvbUFyZ3M6IHN0cmluZ1tdXG4pOiBTdHJpbmdUYXNrPEZldGNoUmVzdWx0PiB8IEVtcHR5VGFzayB7XG4gICBjb25zdCBjb21tYW5kcyA9IFsnZmV0Y2gnLCAuLi5jdXN0b21BcmdzXTtcbiAgIGlmIChyZW1vdGUgJiYgYnJhbmNoKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHJlbW90ZSwgYnJhbmNoKTtcbiAgIH1cblxuICAgY29uc3QgYmFubmVkID0gY29tbWFuZHMuZmluZChkaXNhbGxvd2VkQ29tbWFuZCk7XG4gICBpZiAoYmFubmVkKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhgZ2l0LmZldGNoOiBwb3RlbnRpYWwgZXhwbG9pdCBhcmd1bWVudCBibG9ja2VkLmApO1xuICAgfVxuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXI6IHBhcnNlRmV0Y2hSZXN1bHQsXG4gICB9O1xufVxuIiwgImltcG9ydCB7IE1vdmVSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IExpbmVQYXJzZXIsIHBhcnNlU3RyaW5nUmVzcG9uc2UgfSBmcm9tICcuLi91dGlscyc7XG5cbmNvbnN0IHBhcnNlcnM6IExpbmVQYXJzZXI8TW92ZVJlc3VsdD5bXSA9IFtcbiAgIG5ldyBMaW5lUGFyc2VyKC9eUmVuYW1pbmcgKC4rKSB0byAoLispJC8sIChyZXN1bHQsIFtmcm9tLCB0b10pID0+IHtcbiAgICAgIHJlc3VsdC5tb3Zlcy5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICB9KSxcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU1vdmVSZXN1bHQoc3RkT3V0OiBzdHJpbmcpOiBNb3ZlUmVzdWx0IHtcbiAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKHsgbW92ZXM6IFtdIH0sIHBhcnNlcnMsIHN0ZE91dCk7XG59XG4iLCAiaW1wb3J0IHsgTW92ZVJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgcGFyc2VNb3ZlUmVzdWx0IH0gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZS1tb3ZlJztcbmltcG9ydCB7IFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBhc0FycmF5IH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gbW92ZVRhc2soZnJvbTogc3RyaW5nIHwgc3RyaW5nW10sIHRvOiBzdHJpbmcpOiBTdHJpbmdUYXNrPE1vdmVSZXN1bHQ+IHtcbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kczogWydtdicsICctdicsIC4uLmFzQXJyYXkoZnJvbSksIHRvXSxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcjogcGFyc2VNb3ZlUmVzdWx0LFxuICAgfTtcbn1cbiIsICJpbXBvcnQgeyBQdWxsUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBHaXRSZXNwb25zZUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2dpdC1yZXNwb25zZS1lcnJvcic7XG5pbXBvcnQgeyBwYXJzZVB1bGxFcnJvclJlc3VsdCwgcGFyc2VQdWxsUmVzdWx0IH0gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZS1wdWxsJztcbmltcG9ydCB7IE1heWJlLCBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgYnVmZmVyVG9TdHJpbmcgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBwdWxsVGFzayhcbiAgIHJlbW90ZTogTWF5YmU8c3RyaW5nPixcbiAgIGJyYW5jaDogTWF5YmU8c3RyaW5nPixcbiAgIGN1c3RvbUFyZ3M6IHN0cmluZ1tdXG4pOiBTdHJpbmdUYXNrPFB1bGxSZXN1bHQ+IHtcbiAgIGNvbnN0IGNvbW1hbmRzOiBzdHJpbmdbXSA9IFsncHVsbCcsIC4uLmN1c3RvbUFyZ3NdO1xuICAgaWYgKHJlbW90ZSAmJiBicmFuY2gpIHtcbiAgICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCByZW1vdGUsIGJyYW5jaCk7XG4gICB9XG5cbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kcyxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcihzdGRPdXQsIHN0ZEVycik6IFB1bGxSZXN1bHQge1xuICAgICAgICAgcmV0dXJuIHBhcnNlUHVsbFJlc3VsdChzdGRPdXQsIHN0ZEVycik7XG4gICAgICB9LFxuICAgICAgb25FcnJvcihyZXN1bHQsIF9lcnJvciwgX2RvbmUsIGZhaWwpIHtcbiAgICAgICAgIGNvbnN0IHB1bGxFcnJvciA9IHBhcnNlUHVsbEVycm9yUmVzdWx0KFxuICAgICAgICAgICAgYnVmZmVyVG9TdHJpbmcocmVzdWx0LnN0ZE91dCksXG4gICAgICAgICAgICBidWZmZXJUb1N0cmluZyhyZXN1bHQuc3RkRXJyKVxuICAgICAgICAgKTtcbiAgICAgICAgIGlmIChwdWxsRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsKG5ldyBHaXRSZXNwb25zZUVycm9yKHB1bGxFcnJvcikpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBmYWlsKF9lcnJvcik7XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJpbXBvcnQgeyBmb3JFYWNoTGluZVdpdGhDb250ZW50IH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlbW90ZVdpdGhvdXRSZWZzIHtcbiAgIG5hbWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZW1vdGVXaXRoUmVmcyBleHRlbmRzIFJlbW90ZVdpdGhvdXRSZWZzIHtcbiAgIHJlZnM6IHtcbiAgICAgIGZldGNoOiBzdHJpbmc7XG4gICAgICBwdXNoOiBzdHJpbmc7XG4gICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VHZXRSZW1vdGVzKHRleHQ6IHN0cmluZyk6IFJlbW90ZVdpdGhvdXRSZWZzW10ge1xuICAgY29uc3QgcmVtb3RlczogeyBbbmFtZTogc3RyaW5nXTogUmVtb3RlV2l0aG91dFJlZnMgfSA9IHt9O1xuXG4gICBmb3JFYWNoKHRleHQsIChbbmFtZV0pID0+IChyZW1vdGVzW25hbWVdID0geyBuYW1lIH0pKTtcblxuICAgcmV0dXJuIE9iamVjdC52YWx1ZXMocmVtb3Rlcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUdldFJlbW90ZXNWZXJib3NlKHRleHQ6IHN0cmluZyk6IFJlbW90ZVdpdGhSZWZzW10ge1xuICAgY29uc3QgcmVtb3RlczogeyBbbmFtZTogc3RyaW5nXTogUmVtb3RlV2l0aFJlZnMgfSA9IHt9O1xuXG4gICBmb3JFYWNoKHRleHQsIChbbmFtZSwgdXJsLCBwdXJwb3NlXSkgPT4ge1xuICAgICAgaWYgKCFyZW1vdGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICByZW1vdGVzW25hbWVdID0ge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHJlZnM6IHsgZmV0Y2g6ICcnLCBwdXNoOiAnJyB9LFxuICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHB1cnBvc2UgJiYgdXJsKSB7XG4gICAgICAgICByZW1vdGVzW25hbWVdLnJlZnNbcHVycG9zZS5yZXBsYWNlKC9bXmEtel0vZywgJycpIGFzIGtleW9mIFJlbW90ZVdpdGhSZWZzWydyZWZzJ11dID0gdXJsO1xuICAgICAgfVxuICAgfSk7XG5cbiAgIHJldHVybiBPYmplY3QudmFsdWVzKHJlbW90ZXMpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoKHRleHQ6IHN0cmluZywgaGFuZGxlcjogKGxpbmU6IHN0cmluZ1tdKSA9PiB2b2lkKSB7XG4gICBmb3JFYWNoTGluZVdpdGhDb250ZW50KHRleHQsIChsaW5lKSA9PiBoYW5kbGVyKGxpbmUuc3BsaXQoL1xccysvKSkpO1xufVxuIiwgImltcG9ydCB7IHBhcnNlR2V0UmVtb3RlcywgcGFyc2VHZXRSZW1vdGVzVmVyYm9zZSB9IGZyb20gJy4uL3Jlc3BvbnNlcy9HZXRSZW1vdGVTdW1tYXJ5JztcbmltcG9ydCB7IFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrIH0gZnJvbSAnLi90YXNrJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFJlbW90ZVRhc2soXG4gICByZW1vdGVOYW1lOiBzdHJpbmcsXG4gICByZW1vdGVSZXBvOiBzdHJpbmcsXG4gICBjdXN0b21BcmdzOiBzdHJpbmdbXSA9IFtdXG4pOiBTdHJpbmdUYXNrPHN0cmluZz4ge1xuICAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soWydyZW1vdGUnLCAnYWRkJywgLi4uY3VzdG9tQXJncywgcmVtb3RlTmFtZSwgcmVtb3RlUmVwb10pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVtb3Rlc1Rhc2sodmVyYm9zZTogYm9vbGVhbik6IFN0cmluZ1Rhc2s8YW55PiB7XG4gICBjb25zdCBjb21tYW5kcyA9IFsncmVtb3RlJ107XG4gICBpZiAodmVyYm9zZSkge1xuICAgICAgY29tbWFuZHMucHVzaCgnLXYnKTtcbiAgIH1cblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgcGFyc2VyOiB2ZXJib3NlID8gcGFyc2VHZXRSZW1vdGVzVmVyYm9zZSA6IHBhcnNlR2V0UmVtb3RlcyxcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaXN0UmVtb3Rlc1Rhc2soY3VzdG9tQXJnczogc3RyaW5nW10gPSBbXSk6IFN0cmluZ1Rhc2s8c3RyaW5nPiB7XG4gICBjb25zdCBjb21tYW5kcyA9IFsuLi5jdXN0b21BcmdzXTtcbiAgIGlmIChjb21tYW5kc1swXSAhPT0gJ2xzLXJlbW90ZScpIHtcbiAgICAgIGNvbW1hbmRzLnVuc2hpZnQoJ2xzLXJlbW90ZScpO1xuICAgfVxuXG4gICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdGVUYXNrKGN1c3RvbUFyZ3M6IHN0cmluZ1tdID0gW10pOiBTdHJpbmdUYXNrPHN0cmluZz4ge1xuICAgY29uc3QgY29tbWFuZHMgPSBbLi4uY3VzdG9tQXJnc107XG4gICBpZiAoY29tbWFuZHNbMF0gIT09ICdyZW1vdGUnKSB7XG4gICAgICBjb21tYW5kcy51bnNoaWZ0KCdyZW1vdGUnKTtcbiAgIH1cblxuICAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlUmVtb3RlVGFzayhyZW1vdGVOYW1lOiBzdHJpbmcpIHtcbiAgIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFsncmVtb3RlJywgJ3JlbW92ZScsIHJlbW90ZU5hbWVdKTtcbn1cbiIsICJpbXBvcnQgeyBMb2dPcHRpb25zLCBMb2dSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IGxvZ0Zvcm1hdEZyb21Db21tYW5kIH0gZnJvbSAnLi4vYXJncy9sb2ctZm9ybWF0JztcbmltcG9ydCB7IGNyZWF0ZUxpc3RMb2dTdW1tYXJ5UGFyc2VyIH0gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZS1saXN0LWxvZy1zdW1tYXJ5JztcbmltcG9ydCB0eXBlIHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IHZhbGlkYXRlTG9nRm9ybWF0Q29uZmlnIH0gZnJvbSAnLi9kaWZmJztcbmltcG9ydCB7IHBhcnNlTG9nT3B0aW9ucyB9IGZyb20gJy4vbG9nJztcbmltcG9ydCB0eXBlIHsgRW1wdHlUYXNrIH0gZnJvbSAnLi90YXNrJztcblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXNoTGlzdFRhc2soXG4gICBvcHQ6IExvZ09wdGlvbnMgPSB7fSxcbiAgIGN1c3RvbUFyZ3M6IHN0cmluZ1tdXG4pOiBFbXB0eVRhc2sgfCBTdHJpbmdUYXNrPExvZ1Jlc3VsdD4ge1xuICAgY29uc3Qgb3B0aW9ucyA9IHBhcnNlTG9nT3B0aW9uczxhbnk+KG9wdCk7XG4gICBjb25zdCBjb21tYW5kcyA9IFsnc3Rhc2gnLCAnbGlzdCcsIC4uLm9wdGlvbnMuY29tbWFuZHMsIC4uLmN1c3RvbUFyZ3NdO1xuICAgY29uc3QgcGFyc2VyID0gY3JlYXRlTGlzdExvZ1N1bW1hcnlQYXJzZXIoXG4gICAgICBvcHRpb25zLnNwbGl0dGVyLFxuICAgICAgb3B0aW9ucy5maWVsZHMsXG4gICAgICBsb2dGb3JtYXRGcm9tQ29tbWFuZChjb21tYW5kcylcbiAgICk7XG5cbiAgIHJldHVybiAoXG4gICAgICB2YWxpZGF0ZUxvZ0Zvcm1hdENvbmZpZyhjb21tYW5kcykgfHwge1xuICAgICAgICAgY29tbWFuZHMsXG4gICAgICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICAgICBwYXJzZXIsXG4gICAgICB9XG4gICApO1xufVxuIiwgImltcG9ydCB7IFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrIH0gZnJvbSAnLi90YXNrJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFN1Yk1vZHVsZVRhc2socmVwbzogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiBTdHJpbmdUYXNrPHN0cmluZz4ge1xuICAgcmV0dXJuIHN1Yk1vZHVsZVRhc2soWydhZGQnLCByZXBvLCBwYXRoXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0U3ViTW9kdWxlVGFzayhjdXN0b21BcmdzOiBzdHJpbmdbXSk6IFN0cmluZ1Rhc2s8c3RyaW5nPiB7XG4gICByZXR1cm4gc3ViTW9kdWxlVGFzayhbJ2luaXQnLCAuLi5jdXN0b21BcmdzXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJNb2R1bGVUYXNrKGN1c3RvbUFyZ3M6IHN0cmluZ1tdKTogU3RyaW5nVGFzazxzdHJpbmc+IHtcbiAgIGNvbnN0IGNvbW1hbmRzID0gWy4uLmN1c3RvbUFyZ3NdO1xuICAgaWYgKGNvbW1hbmRzWzBdICE9PSAnc3VibW9kdWxlJykge1xuICAgICAgY29tbWFuZHMudW5zaGlmdCgnc3VibW9kdWxlJyk7XG4gICB9XG5cbiAgIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVN1Yk1vZHVsZVRhc2soY3VzdG9tQXJnczogc3RyaW5nW10pOiBTdHJpbmdUYXNrPHN0cmluZz4ge1xuICAgcmV0dXJuIHN1Yk1vZHVsZVRhc2soWyd1cGRhdGUnLCAuLi5jdXN0b21BcmdzXSk7XG59XG4iLCAiaW1wb3J0IHsgVGFnUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5cbmV4cG9ydCBjbGFzcyBUYWdMaXN0IGltcGxlbWVudHMgVGFnUmVzdWx0IHtcbiAgIGNvbnN0cnVjdG9yKFxuICAgICAgcHVibGljIHJlYWRvbmx5IGFsbDogc3RyaW5nW10sXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgbGF0ZXN0OiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICkge31cbn1cblxuZXhwb3J0IGNvbnN0IHBhcnNlVGFnTGlzdCA9IGZ1bmN0aW9uIChkYXRhOiBzdHJpbmcsIGN1c3RvbVNvcnQgPSBmYWxzZSkge1xuICAgY29uc3QgdGFncyA9IGRhdGEuc3BsaXQoJ1xcbicpLm1hcCh0cmltbWVkKS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgIGlmICghY3VzdG9tU29ydCkge1xuICAgICAgdGFncy5zb3J0KGZ1bmN0aW9uICh0YWdBLCB0YWdCKSB7XG4gICAgICAgICBjb25zdCBwYXJ0c0EgPSB0YWdBLnNwbGl0KCcuJyk7XG4gICAgICAgICBjb25zdCBwYXJ0c0IgPSB0YWdCLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgIGlmIChwYXJ0c0EubGVuZ3RoID09PSAxIHx8IHBhcnRzQi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBzaW5nbGVTb3J0ZWQodG9OdW1iZXIocGFydHNBWzBdKSwgdG9OdW1iZXIocGFydHNCWzBdKSk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gTWF0aC5tYXgocGFydHNBLmxlbmd0aCwgcGFydHNCLmxlbmd0aCk7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBzb3J0ZWQodG9OdW1iZXIocGFydHNBW2ldKSwgdG9OdW1iZXIocGFydHNCW2ldKSk7XG5cbiAgICAgICAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9KTtcbiAgIH1cblxuICAgY29uc3QgbGF0ZXN0ID0gY3VzdG9tU29ydCA/IHRhZ3NbMF0gOiBbLi4udGFnc10ucmV2ZXJzZSgpLmZpbmQoKHRhZykgPT4gdGFnLmluZGV4T2YoJy4nKSA+PSAwKTtcblxuICAgcmV0dXJuIG5ldyBUYWdMaXN0KHRhZ3MsIGxhdGVzdCk7XG59O1xuXG5mdW5jdGlvbiBzaW5nbGVTb3J0ZWQoYTogbnVtYmVyLCBiOiBudW1iZXIpOiBudW1iZXIge1xuICAgY29uc3QgYUlzTnVtID0gaXNOYU4oYSk7XG4gICBjb25zdCBiSXNOdW0gPSBpc05hTihiKTtcblxuICAgaWYgKGFJc051bSAhPT0gYklzTnVtKSB7XG4gICAgICByZXR1cm4gYUlzTnVtID8gMSA6IC0xO1xuICAgfVxuXG4gICByZXR1cm4gYUlzTnVtID8gc29ydGVkKGEsIGIpIDogMDtcbn1cblxuZnVuY3Rpb24gc29ydGVkKGE6IG51bWJlciwgYjogbnVtYmVyKSB7XG4gICByZXR1cm4gYSA9PT0gYiA/IDAgOiBhID4gYiA/IDEgOiAtMTtcbn1cblxuZnVuY3Rpb24gdHJpbW1lZChpbnB1dDogc3RyaW5nKSB7XG4gICByZXR1cm4gaW5wdXQudHJpbSgpO1xufVxuXG5mdW5jdGlvbiB0b051bWJlcihpbnB1dDogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LnJlcGxhY2UoL15cXEQrL2csICcnKSwgMTApIHx8IDA7XG4gICB9XG5cbiAgIHJldHVybiAwO1xufVxuIiwgImltcG9ydCB7IFRhZ1Jlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgcGFyc2VUYWdMaXN0IH0gZnJvbSAnLi4vcmVzcG9uc2VzL1RhZ0xpc3QnO1xuaW1wb3J0IHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcblxuLyoqXG4gKiBUYXNrIHVzZWQgYnkgYGdpdC50YWdzYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdGFnTGlzdFRhc2soY3VzdG9tQXJnczogc3RyaW5nW10gPSBbXSk6IFN0cmluZ1Rhc2s8VGFnUmVzdWx0PiB7XG4gICBjb25zdCBoYXNDdXN0b21Tb3J0ID0gY3VzdG9tQXJncy5zb21lKChvcHRpb24pID0+IC9eLS1zb3J0PS8udGVzdChvcHRpb24pKTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIGNvbW1hbmRzOiBbJ3RhZycsICctbCcsIC4uLmN1c3RvbUFyZ3NdLFxuICAgICAgcGFyc2VyKHRleHQ6IHN0cmluZykge1xuICAgICAgICAgcmV0dXJuIHBhcnNlVGFnTGlzdCh0ZXh0LCBoYXNDdXN0b21Tb3J0KTtcbiAgICAgIH0sXG4gICB9O1xufVxuXG4vKipcbiAqIFRhc2sgdXNlZCBieSBgZ2l0LmFkZFRhZ2BcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFRhZ1Rhc2sobmFtZTogc3RyaW5nKTogU3RyaW5nVGFzazx7IG5hbWU6IHN0cmluZyB9PiB7XG4gICByZXR1cm4ge1xuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgY29tbWFuZHM6IFsndGFnJywgbmFtZV0sXG4gICAgICBwYXJzZXIoKSB7XG4gICAgICAgICByZXR1cm4geyBuYW1lIH07XG4gICAgICB9LFxuICAgfTtcbn1cblxuLyoqXG4gKiBUYXNrIHVzZWQgYnkgYGdpdC5hZGRUYWdgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRBbm5vdGF0ZWRUYWdUYXNrKFxuICAgbmFtZTogc3RyaW5nLFxuICAgdGFnTWVzc2FnZTogc3RyaW5nXG4pOiBTdHJpbmdUYXNrPHsgbmFtZTogc3RyaW5nIH0+IHtcbiAgIHJldHVybiB7XG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBjb21tYW5kczogWyd0YWcnLCAnLWEnLCAnLW0nLCB0YWdNZXNzYWdlLCBuYW1lXSxcbiAgICAgIHBhcnNlcigpIHtcbiAgICAgICAgIHJldHVybiB7IG5hbWUgfTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImNvbnN0IHsgR2l0RXhlY3V0b3IgfSA9IHJlcXVpcmUoJy4vbGliL3J1bm5lcnMvZ2l0LWV4ZWN1dG9yJyk7XG5jb25zdCB7IFNpbXBsZUdpdEFwaSB9ID0gcmVxdWlyZSgnLi9saWIvc2ltcGxlLWdpdC1hcGknKTtcblxuY29uc3QgeyBTY2hlZHVsZXIgfSA9IHJlcXVpcmUoJy4vbGliL3J1bm5lcnMvc2NoZWR1bGVyJyk7XG5jb25zdCB7IGNvbmZpZ3VyYXRpb25FcnJvclRhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL3Rhc2snKTtcbmNvbnN0IHtcbiAgIGFzQXJyYXksXG4gICBmaWx0ZXJBcnJheSxcbiAgIGZpbHRlclByaW1pdGl2ZXMsXG4gICBmaWx0ZXJTdHJpbmcsXG4gICBmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5LFxuICAgZmlsdGVyVHlwZSxcbiAgIGdldFRyYWlsaW5nT3B0aW9ucyxcbiAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudCxcbiAgIHRyYWlsaW5nT3B0aW9uc0FyZ3VtZW50LFxufSA9IHJlcXVpcmUoJy4vbGliL3V0aWxzJyk7XG5jb25zdCB7IGFwcGx5UGF0Y2hUYXNrIH0gPSByZXF1aXJlKCcuL2xpYi90YXNrcy9hcHBseS1wYXRjaCcpO1xuY29uc3Qge1xuICAgYnJhbmNoVGFzayxcbiAgIGJyYW5jaExvY2FsVGFzayxcbiAgIGRlbGV0ZUJyYW5jaGVzVGFzayxcbiAgIGRlbGV0ZUJyYW5jaFRhc2ssXG59ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvYnJhbmNoJyk7XG5jb25zdCB7IGNoZWNrSWdub3JlVGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvY2hlY2staWdub3JlJyk7XG5jb25zdCB7IGNoZWNrSXNSZXBvVGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvY2hlY2staXMtcmVwbycpO1xuY29uc3QgeyBjbG9uZVRhc2ssIGNsb25lTWlycm9yVGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvY2xvbmUnKTtcbmNvbnN0IHsgY2xlYW5XaXRoT3B0aW9uc1Rhc2ssIGlzQ2xlYW5PcHRpb25zQXJyYXkgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL2NsZWFuJyk7XG5jb25zdCB7IGRpZmZTdW1tYXJ5VGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvZGlmZicpO1xuY29uc3QgeyBmZXRjaFRhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL2ZldGNoJyk7XG5jb25zdCB7IG1vdmVUYXNrIH0gPSByZXF1aXJlKCcuL2xpYi90YXNrcy9tb3ZlJyk7XG5jb25zdCB7IHB1bGxUYXNrIH0gPSByZXF1aXJlKCcuL2xpYi90YXNrcy9wdWxsJyk7XG5jb25zdCB7IHB1c2hUYWdzVGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvcHVzaCcpO1xuY29uc3Qge1xuICAgYWRkUmVtb3RlVGFzayxcbiAgIGdldFJlbW90ZXNUYXNrLFxuICAgbGlzdFJlbW90ZXNUYXNrLFxuICAgcmVtb3RlVGFzayxcbiAgIHJlbW92ZVJlbW90ZVRhc2ssXG59ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvcmVtb3RlJyk7XG5jb25zdCB7IGdldFJlc2V0TW9kZSwgcmVzZXRUYXNrIH0gPSByZXF1aXJlKCcuL2xpYi90YXNrcy9yZXNldCcpO1xuY29uc3QgeyBzdGFzaExpc3RUYXNrIH0gPSByZXF1aXJlKCcuL2xpYi90YXNrcy9zdGFzaC1saXN0Jyk7XG5jb25zdCB7XG4gICBhZGRTdWJNb2R1bGVUYXNrLFxuICAgaW5pdFN1Yk1vZHVsZVRhc2ssXG4gICBzdWJNb2R1bGVUYXNrLFxuICAgdXBkYXRlU3ViTW9kdWxlVGFzayxcbn0gPSByZXF1aXJlKCcuL2xpYi90YXNrcy9zdWItbW9kdWxlJyk7XG5jb25zdCB7IGFkZEFubm90YXRlZFRhZ1Rhc2ssIGFkZFRhZ1Rhc2ssIHRhZ0xpc3RUYXNrIH0gPSByZXF1aXJlKCcuL2xpYi90YXNrcy90YWcnKTtcbmNvbnN0IHsgc3RyYWlnaHRUaHJvdWdoQnVmZmVyVGFzaywgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvdGFzaycpO1xuXG5mdW5jdGlvbiBHaXQob3B0aW9ucywgcGx1Z2lucykge1xuICAgdGhpcy5fZXhlY3V0b3IgPSBuZXcgR2l0RXhlY3V0b3IoXG4gICAgICBvcHRpb25zLmJpbmFyeSxcbiAgICAgIG9wdGlvbnMuYmFzZURpcixcbiAgICAgIG5ldyBTY2hlZHVsZXIob3B0aW9ucy5tYXhDb25jdXJyZW50UHJvY2Vzc2VzKSxcbiAgICAgIHBsdWdpbnNcbiAgICk7XG5cbiAgIHRoaXMuX3RyaW1tZWQgPSBvcHRpb25zLnRyaW1tZWQ7XG59XG5cbihHaXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTaW1wbGVHaXRBcGkucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBHaXQ7XG5cbi8qKlxuICogU2V0cyB0aGUgcGF0aCB0byBhIGN1c3RvbSBnaXQgYmluYXJ5LCBzaG91bGQgZWl0aGVyIGJlIGBnaXRgIHdoZW4gdGhlcmUgaXMgYW4gaW5zdGFsbGF0aW9uIG9mIGdpdCBhdmFpbGFibGUgb25cbiAqIHRoZSBzeXN0ZW0gcGF0aCwgb3IgYSBmdWxseSBxdWFsaWZpZWQgcGF0aCB0byB0aGUgZXhlY3V0YWJsZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tbWFuZFxuICogQHJldHVybnMge0dpdH1cbiAqL1xuR2l0LnByb3RvdHlwZS5jdXN0b21CaW5hcnkgPSBmdW5jdGlvbiAoY29tbWFuZCkge1xuICAgdGhpcy5fZXhlY3V0b3IuYmluYXJ5ID0gY29tbWFuZDtcbiAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIGFuIGVudmlyb25tZW50IHZhcmlhYmxlIGZvciB0aGUgc3Bhd25lZCBjaGlsZCBwcm9jZXNzLCBlaXRoZXIgc3VwcGx5IGJvdGggYSBuYW1lIGFuZCB2YWx1ZSBhcyBzdHJpbmdzIG9yXG4gKiBhIHNpbmdsZSBvYmplY3QgdG8gZW50aXJlbHkgcmVwbGFjZSB0aGUgY3VycmVudCBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gW3ZhbHVlXVxuICogQHJldHVybnMge0dpdH1cbiAqL1xuR2l0LnByb3RvdHlwZS5lbnYgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgdGhpcy5fZXhlY3V0b3IuZW52ID0gbmFtZTtcbiAgIH0gZWxzZSB7XG4gICAgICAodGhpcy5fZXhlY3V0b3IuZW52ID0gdGhpcy5fZXhlY3V0b3IuZW52IHx8IHt9KVtuYW1lXSA9IHZhbHVlO1xuICAgfVxuXG4gICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTGlzdCB0aGUgc3Rhc2gocykgb2YgdGhlIGxvY2FsIHJlcG9cbiAqL1xuR2l0LnByb3RvdHlwZS5zdGFzaExpc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBzdGFzaExpc3RUYXNrKFxuICAgICAgICAgdHJhaWxpbmdPcHRpb25zQXJndW1lbnQoYXJndW1lbnRzKSB8fCB7fSxcbiAgICAgICAgIChmaWx0ZXJBcnJheShvcHRpb25zKSAmJiBvcHRpb25zKSB8fCBbXVxuICAgICAgKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlQ2xvbmVUYXNrKGFwaSwgdGFzaywgcmVwb1BhdGgsIGxvY2FsUGF0aCkge1xuICAgaWYgKHR5cGVvZiByZXBvUGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKGBnaXQuJHthcGl9KCkgcmVxdWlyZXMgYSBzdHJpbmcgJ3JlcG9QYXRoJ2ApO1xuICAgfVxuXG4gICByZXR1cm4gdGFzayhyZXBvUGF0aCwgZmlsdGVyVHlwZShsb2NhbFBhdGgsIGZpbHRlclN0cmluZyksIGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpKTtcbn1cblxuLyoqXG4gKiBDbG9uZSBhIGdpdCByZXBvXG4gKi9cbkdpdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIGNyZWF0ZUNsb25lVGFzaygnY2xvbmUnLCBjbG9uZVRhc2ssIC4uLmFyZ3VtZW50cyksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogTWlycm9yIGEgZ2l0IHJlcG9cbiAqL1xuR2l0LnByb3RvdHlwZS5taXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIGNyZWF0ZUNsb25lVGFzaygnbWlycm9yJywgY2xvbmVNaXJyb3JUYXNrLCAuLi5hcmd1bWVudHMpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIE1vdmVzIG9uZSBvciBtb3JlIGZpbGVzIHRvIGEgbmV3IGRlc3RpbmF0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdC1tdlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmcm9tXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9cbiAqL1xuR2l0LnByb3RvdHlwZS5tdiA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2sobW92ZVRhc2soZnJvbSwgdG8pLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKSk7XG59O1xuXG4vKipcbiAqIEludGVybmFsbHkgdXNlcyBwdWxsIGFuZCB0YWdzIHRvIGdldCB0aGUgbGlzdCBvZiB0YWdzIHRoZW4gY2hlY2tzIG91dCB0aGUgbGF0ZXN0IHRhZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbdGhlbl1cbiAqL1xuR2l0LnByb3RvdHlwZS5jaGVja291dExhdGVzdFRhZyA9IGZ1bmN0aW9uICh0aGVuKSB7XG4gICB2YXIgZ2l0ID0gdGhpcztcbiAgIHJldHVybiB0aGlzLnB1bGwoZnVuY3Rpb24gKCkge1xuICAgICAgZ2l0LnRhZ3MoZnVuY3Rpb24gKGVyciwgdGFncykge1xuICAgICAgICAgZ2l0LmNoZWNrb3V0KHRhZ3MubGF0ZXN0LCB0aGVuKTtcbiAgICAgIH0pO1xuICAgfSk7XG59O1xuXG4vKipcbiAqIFB1bGwgdGhlIHVwZGF0ZWQgY29udGVudHMgb2YgdGhlIGN1cnJlbnQgcmVwb1xuICovXG5HaXQucHJvdG90eXBlLnB1bGwgPSBmdW5jdGlvbiAocmVtb3RlLCBicmFuY2gsIG9wdGlvbnMsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgcHVsbFRhc2soXG4gICAgICAgICBmaWx0ZXJUeXBlKHJlbW90ZSwgZmlsdGVyU3RyaW5nKSxcbiAgICAgICAgIGZpbHRlclR5cGUoYnJhbmNoLCBmaWx0ZXJTdHJpbmcpLFxuICAgICAgICAgZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cylcbiAgICAgICksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogRmV0Y2ggdGhlIHVwZGF0ZWQgY29udGVudHMgb2YgdGhlIGN1cnJlbnQgcmVwby5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAuZmV0Y2goJ3Vwc3RyZWFtJywgJ21hc3RlcicpIC8vIGZldGNoZXMgZnJvbSBtYXN0ZXIgb24gcmVtb3RlIG5hbWVkIHVwc3RyZWFtXG4gKiAgIC5mZXRjaChmdW5jdGlvbiAoKSB7fSkgLy8gcnVucyBmZXRjaCBhZ2FpbnN0IGRlZmF1bHQgcmVtb3RlIGFuZCBicmFuY2ggYW5kIGNhbGxzIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtyZW1vdGVdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2JyYW5jaF1cbiAqL1xuR2l0LnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uIChyZW1vdGUsIGJyYW5jaCkge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBmZXRjaFRhc2soXG4gICAgICAgICBmaWx0ZXJUeXBlKHJlbW90ZSwgZmlsdGVyU3RyaW5nKSxcbiAgICAgICAgIGZpbHRlclR5cGUoYnJhbmNoLCBmaWx0ZXJTdHJpbmcpLFxuICAgICAgICAgZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cylcbiAgICAgICksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogRGlzYWJsZXMvZW5hYmxlcyB0aGUgdXNlIG9mIHRoZSBjb25zb2xlIGZvciBwcmludGluZyB3YXJuaW5ncyBhbmQgZXJyb3JzLCBieSBkZWZhdWx0IG1lc3NhZ2VzIGFyZSBub3Qgc2hvd24gaW5cbiAqIGEgcHJvZHVjdGlvbiBlbnZpcm9ubWVudC5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbGVuY2VcbiAqIEByZXR1cm5zIHtHaXR9XG4gKi9cbkdpdC5wcm90b3R5cGUuc2lsZW50ID0gZnVuY3Rpb24gKHNpbGVuY2UpIHtcbiAgIGNvbnNvbGUud2FybihcbiAgICAgICdzaW1wbGUtZ2l0IGRlcHJlY2F0aW9uIG5vdGljZTogZ2l0LnNpbGVudDogbG9nZ2luZyBzaG91bGQgYmUgY29uZmlndXJlZCB1c2luZyB0aGUgYGRlYnVnYCBsaWJyYXJ5IC8gYERFQlVHYCBlbnZpcm9ubWVudCB2YXJpYWJsZSwgdGhpcyB3aWxsIGJlIGFuIGVycm9yIGluIHZlcnNpb24gMydcbiAgICk7XG4gICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTGlzdCBhbGwgdGFncy4gV2hlbiB1c2luZyBnaXQgMi43LjAgb3IgYWJvdmUsIGluY2x1ZGUgYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCBgXCItLXNvcnRcIjogXCJwcm9wZXJ0eS1uYW1lXCJgIHRvXG4gKiBzb3J0IHRoZSB0YWdzIGJ5IHRoYXQgcHJvcGVydHkgaW5zdGVhZCBvZiB1c2luZyB0aGUgZGVmYXVsdCBzZW1hbnRpYyB2ZXJzaW9uaW5nIHNvcnQuXG4gKlxuICogTm90ZSwgc3VwcGx5aW5nIHRoaXMgb3B0aW9uIHdoZW4gaXQgaXMgbm90IHN1cHBvcnRlZCBieSB5b3VyIEdpdCB2ZXJzaW9uIHdpbGwgY2F1c2UgdGhlIG9wZXJhdGlvbiB0byBmYWlsLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFt0aGVuXVxuICovXG5HaXQucHJvdG90eXBlLnRhZ3MgPSBmdW5jdGlvbiAob3B0aW9ucywgdGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICB0YWdMaXN0VGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogUmViYXNlcyB0aGUgY3VycmVudCB3b3JraW5nIGNvcHkuIE9wdGlvbnMgY2FuIGJlIHN1cHBsaWVkIGVpdGhlciBhcyBhbiBhcnJheSBvZiBzdHJpbmcgcGFyYW1ldGVyc1xuICogdG8gYmUgc2VudCB0byB0aGUgYGdpdCByZWJhc2VgIGNvbW1hbmQsIG9yIGEgc3RhbmRhcmQgb3B0aW9ucyBvYmplY3QuXG4gKi9cbkdpdC5wcm90b3R5cGUucmViYXNlID0gZnVuY3Rpb24gKCkge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFsncmViYXNlJywgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cyldKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBSZXNldCBhIHJlcG9cbiAqL1xuR2l0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChtb2RlKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIHJlc2V0VGFzayhnZXRSZXNldE1vZGUobW9kZSksIGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBSZXZlcnQgb25lIG9yIG1vcmUgY29tbWl0cyBpbiB0aGUgbG9jYWwgd29ya2luZyBjb3B5XG4gKi9cbkdpdC5wcm90b3R5cGUucmV2ZXJ0ID0gZnVuY3Rpb24gKGNvbW1pdCkge1xuICAgY29uc3QgbmV4dCA9IHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpO1xuXG4gICBpZiAodHlwZW9mIGNvbW1pdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKGNvbmZpZ3VyYXRpb25FcnJvclRhc2soJ0NvbW1pdCBtdXN0IGJlIGEgc3RyaW5nJyksIG5leHQpO1xuICAgfVxuXG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soWydyZXZlcnQnLCAuLi5nZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzLCAwLCB0cnVlKSwgY29tbWl0XSksXG4gICAgICBuZXh0XG4gICApO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaWdodHdlaWdodCB0YWcgdG8gdGhlIGhlYWQgb2YgdGhlIGN1cnJlbnQgYnJhbmNoXG4gKi9cbkdpdC5wcm90b3R5cGUuYWRkVGFnID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgIGNvbnN0IHRhc2sgPVxuICAgICAgdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnXG4gICAgICAgICA/IGFkZFRhZ1Rhc2sobmFtZSlcbiAgICAgICAgIDogY29uZmlndXJhdGlvbkVycm9yVGFzaygnR2l0LmFkZFRhZyByZXF1aXJlcyBhIHRhZyBuYW1lJyk7XG5cbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHRhc2ssIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpKTtcbn07XG5cbi8qKlxuICogQWRkIGFuIGFubm90YXRlZCB0YWcgdG8gdGhlIGhlYWQgb2YgdGhlIGN1cnJlbnQgYnJhbmNoXG4gKi9cbkdpdC5wcm90b3R5cGUuYWRkQW5ub3RhdGVkVGFnID0gZnVuY3Rpb24gKHRhZ05hbWUsIHRhZ01lc3NhZ2UpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgYWRkQW5ub3RhdGVkVGFnVGFzayh0YWdOYW1lLCB0YWdNZXNzYWdlKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBEZWxldGUgYSBsb2NhbCBicmFuY2hcbiAqL1xuR2l0LnByb3RvdHlwZS5kZWxldGVMb2NhbEJyYW5jaCA9IGZ1bmN0aW9uIChicmFuY2hOYW1lLCBmb3JjZURlbGV0ZSwgdGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBkZWxldGVCcmFuY2hUYXNrKGJyYW5jaE5hbWUsIHR5cGVvZiBmb3JjZURlbGV0ZSA9PT0gJ2Jvb2xlYW4nID8gZm9yY2VEZWxldGUgOiBmYWxzZSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogRGVsZXRlIG9uZSBvciBtb3JlIGxvY2FsIGJyYW5jaGVzXG4gKi9cbkdpdC5wcm90b3R5cGUuZGVsZXRlTG9jYWxCcmFuY2hlcyA9IGZ1bmN0aW9uIChicmFuY2hOYW1lcywgZm9yY2VEZWxldGUsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgZGVsZXRlQnJhbmNoZXNUYXNrKGJyYW5jaE5hbWVzLCB0eXBlb2YgZm9yY2VEZWxldGUgPT09ICdib29sZWFuJyA/IGZvcmNlRGVsZXRlIDogZmFsc2UpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIExpc3QgYWxsIGJyYW5jaGVzXG4gKlxuICogQHBhcmFtIHtPYmplY3QgfCBzdHJpbmdbXX0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbdGhlbl1cbiAqL1xuR2l0LnByb3RvdHlwZS5icmFuY2ggPSBmdW5jdGlvbiAob3B0aW9ucywgdGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBicmFuY2hUYXNrKGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gbGlzdCBvZiBsb2NhbCBicmFuY2hlc1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFt0aGVuXVxuICovXG5HaXQucHJvdG90eXBlLmJyYW5jaExvY2FsID0gZnVuY3Rpb24gKHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKGJyYW5jaExvY2FsVGFzaygpLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKSk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGFueSBjb21tYW5kIGFnYWluc3QgdGhlIGdpdCBiaW5hcnkuXG4gKi9cbkdpdC5wcm90b3R5cGUucmF3ID0gZnVuY3Rpb24gKGNvbW1hbmRzKSB7XG4gICBjb25zdCBjcmVhdGVSZXN0Q29tbWFuZHMgPSAhQXJyYXkuaXNBcnJheShjb21tYW5kcyk7XG4gICBjb25zdCBjb21tYW5kID0gW10uc2xpY2UuY2FsbChjcmVhdGVSZXN0Q29tbWFuZHMgPyBhcmd1bWVudHMgOiBjb21tYW5kcywgMCk7XG5cbiAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tbWFuZC5sZW5ndGggJiYgY3JlYXRlUmVzdENvbW1hbmRzOyBpKyspIHtcbiAgICAgIGlmICghZmlsdGVyUHJpbWl0aXZlcyhjb21tYW5kW2ldKSkge1xuICAgICAgICAgY29tbWFuZC5zcGxpY2UoaSwgY29tbWFuZC5sZW5ndGggLSBpKTtcbiAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgfVxuXG4gICBjb21tYW5kLnB1c2goLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgMCwgdHJ1ZSkpO1xuXG4gICB2YXIgbmV4dCA9IHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpO1xuXG4gICBpZiAoIWNvbW1hbmQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soJ1JhdzogbXVzdCBzdXBwbHkgb25lIG9yIG1vcmUgY29tbWFuZCB0byBleGVjdXRlJyksXG4gICAgICAgICBuZXh0XG4gICAgICApO1xuICAgfVxuXG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmQsIHRoaXMuX3RyaW1tZWQpLCBuZXh0KTtcbn07XG5cbkdpdC5wcm90b3R5cGUuc3VibW9kdWxlQWRkID0gZnVuY3Rpb24gKHJlcG8sIHBhdGgsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKGFkZFN1Yk1vZHVsZVRhc2socmVwbywgcGF0aCksIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpKTtcbn07XG5cbkdpdC5wcm90b3R5cGUuc3VibW9kdWxlVXBkYXRlID0gZnVuY3Rpb24gKGFyZ3MsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgdXBkYXRlU3ViTW9kdWxlVGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzLCB0cnVlKSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbkdpdC5wcm90b3R5cGUuc3VibW9kdWxlSW5pdCA9IGZ1bmN0aW9uIChhcmdzLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIGluaXRTdWJNb2R1bGVUYXNrKGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMsIHRydWUpKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuR2l0LnByb3RvdHlwZS5zdWJNb2R1bGUgPSBmdW5jdGlvbiAob3B0aW9ucywgdGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBzdWJNb2R1bGVUYXNrKGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuR2l0LnByb3RvdHlwZS5saXN0UmVtb3RlID0gZnVuY3Rpb24gKCkge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBsaXN0UmVtb3Rlc1Rhc2soZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cykpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSByZW1vdGUgdG8gdGhlIGxpc3Qgb2YgcmVtb3Rlcy5cbiAqL1xuR2l0LnByb3RvdHlwZS5hZGRSZW1vdGUgPSBmdW5jdGlvbiAocmVtb3RlTmFtZSwgcmVtb3RlUmVwbywgdGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBhZGRSZW1vdGVUYXNrKHJlbW90ZU5hbWUsIHJlbW90ZVJlcG8sIGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFuIGVudHJ5IGJ5IG5hbWUgZnJvbSB0aGUgbGlzdCBvZiByZW1vdGVzLlxuICovXG5HaXQucHJvdG90eXBlLnJlbW92ZVJlbW90ZSA9IGZ1bmN0aW9uIChyZW1vdGVOYW1lLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhyZW1vdmVSZW1vdGVUYXNrKHJlbW90ZU5hbWUpLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKSk7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGN1cnJlbnRseSBhdmFpbGFibGUgcmVtb3Rlcywgc2V0dGluZyB0aGUgb3B0aW9uYWwgdmVyYm9zZSBhcmd1bWVudCB0byB0cnVlIGluY2x1ZGVzIGFkZGl0aW9uYWxcbiAqIGRldGFpbCBvbiB0aGUgcmVtb3RlcyB0aGVtc2VsdmVzLlxuICovXG5HaXQucHJvdG90eXBlLmdldFJlbW90ZXMgPSBmdW5jdGlvbiAodmVyYm9zZSwgdGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soZ2V0UmVtb3Rlc1Rhc2sodmVyYm9zZSA9PT0gdHJ1ZSksIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpKTtcbn07XG5cbi8qKlxuICogQ2FsbCBhbnkgYGdpdCByZW1vdGVgIGZ1bmN0aW9uIHdpdGggYXJndW1lbnRzIHBhc3NlZCBhcyBhbiBhcnJheSBvZiBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nW119IG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFt0aGVuXVxuICovXG5HaXQucHJvdG90eXBlLnJlbW90ZSA9IGZ1bmN0aW9uIChvcHRpb25zLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIHJlbW90ZVRhc2soZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cykpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIENhbGwgYW55IGBnaXQgdGFnYCBmdW5jdGlvbiB3aXRoIGFyZ3VtZW50cyBwYXNzZWQgYXMgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbdGhlbl1cbiAqL1xuR2l0LnByb3RvdHlwZS50YWcgPSBmdW5jdGlvbiAob3B0aW9ucywgdGhlbikge1xuICAgY29uc3QgY29tbWFuZCA9IGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpO1xuXG4gICBpZiAoY29tbWFuZFswXSAhPT0gJ3RhZycpIHtcbiAgICAgIGNvbW1hbmQudW5zaGlmdCgndGFnJyk7XG4gICB9XG5cbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZCksIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpKTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyByZXBvc2l0b3J5IHNlcnZlciBpbmZvXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3RoZW5dXG4gKi9cbkdpdC5wcm90b3R5cGUudXBkYXRlU2VydmVySW5mbyA9IGZ1bmN0aW9uICh0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soWyd1cGRhdGUtc2VydmVyLWluZm8nXSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogUHVzaGVzIHRoZSBjdXJyZW50IHRhZyBjaGFuZ2VzIHRvIGEgcmVtb3RlIHdoaWNoIGNhbiBiZSBlaXRoZXIgYSBVUkwgb3IgbmFtZWQgcmVtb3RlLiBXaGVuIG5vdCBzcGVjaWZpZWQgdXNlcyB0aGVcbiAqIGRlZmF1bHQgY29uZmlndXJlZCByZW1vdGUgc3BlYy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3JlbW90ZV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFt0aGVuXVxuICovXG5HaXQucHJvdG90eXBlLnB1c2hUYWdzID0gZnVuY3Rpb24gKHJlbW90ZSwgdGhlbikge1xuICAgY29uc3QgdGFzayA9IHB1c2hUYWdzVGFzayhcbiAgICAgIHsgcmVtb3RlOiBmaWx0ZXJUeXBlKHJlbW90ZSwgZmlsdGVyU3RyaW5nKSB9LFxuICAgICAgZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cylcbiAgICk7XG5cbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHRhc2ssIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgbmFtZWQgZmlsZXMgZnJvbSBzb3VyY2UgY29udHJvbC5cbiAqL1xuR2l0LnByb3RvdHlwZS5ybSA9IGZ1bmN0aW9uIChmaWxlcykge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFsncm0nLCAnLWYnLCAuLi5hc0FycmF5KGZpbGVzKV0pLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIG5hbWVkIGZpbGVzIGZyb20gc291cmNlIGNvbnRyb2wgYnV0IGtlZXBzIHRoZW0gb24gZGlzayByYXRoZXIgdGhhbiBkZWxldGluZyB0aGVtIGVudGlyZWx5LiBUb1xuICogY29tcGxldGVseSByZW1vdmUgdGhlIGZpbGVzLCB1c2UgYHJtYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZXNcbiAqL1xuR2l0LnByb3RvdHlwZS5ybUtlZXBMb2NhbCA9IGZ1bmN0aW9uIChmaWxlcykge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFsncm0nLCAnLS1jYWNoZWQnLCAuLi5hc0FycmF5KGZpbGVzKV0pLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIG9iamVjdHMgaW4gYSB0cmVlIGJhc2VkIG9uIGNvbW1pdCBoYXNoLiBQYXNzaW5nIGluIGFuIG9iamVjdCBoYXNoIHJldHVybnMgdGhlIG9iamVjdCdzIGNvbnRlbnQsXG4gKiBzaXplLCBhbmQgdHlwZS5cbiAqXG4gKiBQYXNzaW5nIFwiLXBcIiB3aWxsIGluc3RydWN0IGNhdC1maWxlIHRvIGRldGVybWluZSB0aGUgb2JqZWN0IHR5cGUsIGFuZCBkaXNwbGF5IGl0cyBmb3JtYXR0ZWQgY29udGVudHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbdGhlbl1cbiAqL1xuR2l0LnByb3RvdHlwZS5jYXRGaWxlID0gZnVuY3Rpb24gKG9wdGlvbnMsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9jYXRGaWxlKCd1dGYtOCcsIGFyZ3VtZW50cyk7XG59O1xuXG5HaXQucHJvdG90eXBlLmJpbmFyeUNhdEZpbGUgPSBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4gdGhpcy5fY2F0RmlsZSgnYnVmZmVyJywgYXJndW1lbnRzKTtcbn07XG5cbkdpdC5wcm90b3R5cGUuX2NhdEZpbGUgPSBmdW5jdGlvbiAoZm9ybWF0LCBhcmdzKSB7XG4gICB2YXIgaGFuZGxlciA9IHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmdzKTtcbiAgIHZhciBjb21tYW5kID0gWydjYXQtZmlsZSddO1xuICAgdmFyIG9wdGlvbnMgPSBhcmdzWzBdO1xuXG4gICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soJ0dpdC5jYXRGaWxlOiBvcHRpb25zIG11c3QgYmUgc3VwcGxpZWQgYXMgYW4gYXJyYXkgb2Ygc3RyaW5ncycpLFxuICAgICAgICAgaGFuZGxlclxuICAgICAgKTtcbiAgIH1cblxuICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgIGNvbW1hbmQucHVzaC5hcHBseShjb21tYW5kLCBvcHRpb25zKTtcbiAgIH1cblxuICAgY29uc3QgdGFzayA9XG4gICAgICBmb3JtYXQgPT09ICdidWZmZXInID8gc3RyYWlnaHRUaHJvdWdoQnVmZmVyVGFzayhjb21tYW5kKSA6IHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZCk7XG5cbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHRhc2ssIGhhbmRsZXIpO1xufTtcblxuR2l0LnByb3RvdHlwZS5kaWZmID0gZnVuY3Rpb24gKG9wdGlvbnMsIHRoZW4pIHtcbiAgIGNvbnN0IHRhc2sgPSBmaWx0ZXJTdHJpbmcob3B0aW9ucylcbiAgICAgID8gY29uZmlndXJhdGlvbkVycm9yVGFzayhcbiAgICAgICAgICAgJ2dpdC5kaWZmOiBzdXBwbHlpbmcgb3B0aW9ucyBhcyBhIHNpbmdsZSBzdHJpbmcgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCwgc3dpdGNoIHRvIGFuIGFycmF5IG9mIHN0cmluZ3MnXG4gICAgICAgIClcbiAgICAgIDogc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbJ2RpZmYnLCAuLi5nZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKV0pO1xuXG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKSk7XG59O1xuXG5HaXQucHJvdG90eXBlLmRpZmZTdW1tYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBkaWZmU3VtbWFyeVRhc2soZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgMSkpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG5HaXQucHJvdG90eXBlLmFwcGx5UGF0Y2ggPSBmdW5jdGlvbiAocGF0Y2hlcykge1xuICAgY29uc3QgdGFzayA9ICFmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5KHBhdGNoZXMpXG4gICAgICA/IGNvbmZpZ3VyYXRpb25FcnJvclRhc2soXG4gICAgICAgICAgIGBnaXQuYXBwbHlQYXRjaCByZXF1aXJlcyBvbmUgb3IgbW9yZSBzdHJpbmcgcGF0Y2hlcyBhcyB0aGUgZmlyc3QgYXJndW1lbnRgXG4gICAgICAgIClcbiAgICAgIDogYXBwbHlQYXRjaFRhc2soYXNBcnJheShwYXRjaGVzKSwgZ2V0VHJhaWxpbmdPcHRpb25zKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSkpO1xuXG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKSk7XG59O1xuXG5HaXQucHJvdG90eXBlLnJldnBhcnNlID0gZnVuY3Rpb24gKCkge1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ3Jldi1wYXJzZScsIC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMsIHRydWUpXTtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kcywgdHJ1ZSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICovXG5HaXQucHJvdG90eXBlLmNsZWFuID0gZnVuY3Rpb24gKG1vZGUsIG9wdGlvbnMsIHRoZW4pIHtcbiAgIGNvbnN0IHVzaW5nQ2xlYW5PcHRpb25zQXJyYXkgPSBpc0NsZWFuT3B0aW9uc0FycmF5KG1vZGUpO1xuICAgY29uc3QgY2xlYW5Nb2RlID1cbiAgICAgICh1c2luZ0NsZWFuT3B0aW9uc0FycmF5ICYmIG1vZGUuam9pbignJykpIHx8IGZpbHRlclR5cGUobW9kZSwgZmlsdGVyU3RyaW5nKSB8fCAnJztcbiAgIGNvbnN0IGN1c3RvbUFyZ3MgPSBnZXRUcmFpbGluZ09wdGlvbnMoW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIHVzaW5nQ2xlYW5PcHRpb25zQXJyYXkgPyAxIDogMCkpO1xuXG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIGNsZWFuV2l0aE9wdGlvbnNUYXNrKGNsZWFuTW9kZSwgY3VzdG9tQXJncyksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbkdpdC5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uICh0aGVuKSB7XG4gICBjb25zdCB0YXNrID0ge1xuICAgICAgY29tbWFuZHM6IFtdLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgcGFyc2VyKCkge1xuICAgICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGVuKCk7XG4gICAgICAgICB9XG4gICAgICB9LFxuICAgfTtcblxuICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzayk7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgcXVldWUgb2YgcGVuZGluZyBjb21tYW5kcyBhbmQgcmV0dXJucyB0aGUgd3JhcHBlciBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gKlxuICogQHJldHVybnMge0dpdH1cbiAqL1xuR2l0LnByb3RvdHlwZS5jbGVhclF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgLy8gVE9ETzpcbiAgIC8vIHRoaXMuX2V4ZWN1dG9yLmNsZWFyKCk7XG4gICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBwYXRobmFtZSBvciBwYXRobmFtZXMgYXJlIGV4Y2x1ZGVkIGJ5IC5naXRpZ25vcmVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcGF0aG5hbWVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbdGhlbl1cbiAqL1xuR2l0LnByb3RvdHlwZS5jaGVja0lnbm9yZSA9IGZ1bmN0aW9uIChwYXRobmFtZXMsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgY2hlY2tJZ25vcmVUYXNrKGFzQXJyYXkoZmlsdGVyVHlwZShwYXRobmFtZXMsIGZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXksIFtdKSkpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG5HaXQucHJvdG90eXBlLmNoZWNrSXNSZXBvID0gZnVuY3Rpb24gKGNoZWNrVHlwZSwgdGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBjaGVja0lzUmVwb1Rhc2soZmlsdGVyVHlwZShjaGVja1R5cGUsIGZpbHRlclN0cmluZykpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdpdDtcbiIsICJpbXBvcnQgeyBwYXRoc3BlYyB9IGZyb20gJy4vYXJncy9wYXRoc3BlYyc7XG5pbXBvcnQgeyBHaXRDb25zdHJ1Y3RFcnJvciB9IGZyb20gJy4vZXJyb3JzL2dpdC1jb25zdHJ1Y3QtZXJyb3InO1xuaW1wb3J0IHsgR2l0RXJyb3IgfSBmcm9tICcuL2Vycm9ycy9naXQtZXJyb3InO1xuaW1wb3J0IHsgR2l0UGx1Z2luRXJyb3IgfSBmcm9tICcuL2Vycm9ycy9naXQtcGx1Z2luLWVycm9yJztcbmltcG9ydCB7IEdpdFJlc3BvbnNlRXJyb3IgfSBmcm9tICcuL2Vycm9ycy9naXQtcmVzcG9uc2UtZXJyb3InO1xuaW1wb3J0IHsgVGFza0NvbmZpZ3VyYXRpb25FcnJvciB9IGZyb20gJy4vZXJyb3JzL3Rhc2stY29uZmlndXJhdGlvbi1lcnJvcic7XG5pbXBvcnQgeyBDaGVja1JlcG9BY3Rpb25zIH0gZnJvbSAnLi90YXNrcy9jaGVjay1pcy1yZXBvJztcbmltcG9ydCB7IENsZWFuT3B0aW9ucyB9IGZyb20gJy4vdGFza3MvY2xlYW4nO1xuaW1wb3J0IHsgR2l0Q29uZmlnU2NvcGUgfSBmcm9tICcuL3Rhc2tzL2NvbmZpZyc7XG5pbXBvcnQgeyBEaWZmTmFtZVN0YXR1cyB9IGZyb20gJy4vdGFza3MvZGlmZi1uYW1lLXN0YXR1cyc7XG5pbXBvcnQgeyBncmVwUXVlcnlCdWlsZGVyIH0gZnJvbSAnLi90YXNrcy9ncmVwJztcbmltcG9ydCB7IFJlc2V0TW9kZSB9IGZyb20gJy4vdGFza3MvcmVzZXQnO1xuXG5leHBvcnQge1xuICAgQ2hlY2tSZXBvQWN0aW9ucyxcbiAgIENsZWFuT3B0aW9ucyxcbiAgIERpZmZOYW1lU3RhdHVzLFxuICAgR2l0Q29uZmlnU2NvcGUsXG4gICBHaXRDb25zdHJ1Y3RFcnJvcixcbiAgIEdpdEVycm9yLFxuICAgR2l0UGx1Z2luRXJyb3IsXG4gICBHaXRSZXNwb25zZUVycm9yLFxuICAgUmVzZXRNb2RlLFxuICAgVGFza0NvbmZpZ3VyYXRpb25FcnJvcixcbiAgIGdyZXBRdWVyeUJ1aWxkZXIsXG4gICBwYXRoc3BlYyxcbn07XG4iLCAiaW1wb3J0IHsgR2l0RXJyb3IgfSBmcm9tICcuL2dpdC1lcnJvcic7XG5pbXBvcnQgeyBTaW1wbGVHaXRPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG4vKipcbiAqIFRoZSBgR2l0Q29uc3RydWN0RXJyb3JgIGlzIHRocm93biB3aGVuIGFuIGVycm9yIG9jY3VycyBpbiB0aGUgY29uc3RydWN0b3JcbiAqIG9mIHRoZSBgc2ltcGxlLWdpdGAgaW5zdGFuY2UgaXRzZWxmLiBNb3N0IGNvbW1vbmx5IGFzIGEgcmVzdWx0IG9mIHVzaW5nXG4gKiBhIGBiYXNlRGlyYCBvcHRpb24gdGhhdCBwb2ludHMgdG8gYSBmb2xkZXIgdGhhdCBlaXRoZXIgZG9lcyBub3QgZXhpc3QsXG4gKiBvciBjYW5ub3QgYmUgcmVhZCBieSB0aGUgdXNlciB0aGUgbm9kZSBzY3JpcHQgaXMgcnVubmluZyBhcy5cbiAqXG4gKiBDaGVjayB0aGUgYC5tZXNzYWdlYCBwcm9wZXJ0eSBmb3IgbW9yZSBkZXRhaWwgaW5jbHVkaW5nIHRoZSBwcm9wZXJ0aWVzXG4gKiBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICovXG5leHBvcnQgY2xhc3MgR2l0Q29uc3RydWN0RXJyb3IgZXh0ZW5kcyBHaXRFcnJvciB7XG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyByZWFkb25seSBjb25maWc6IFNpbXBsZUdpdE9wdGlvbnMsXG4gICAgICBtZXNzYWdlOiBzdHJpbmdcbiAgICkge1xuICAgICAgc3VwZXIodW5kZWZpbmVkLCBtZXNzYWdlKTtcbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBTaW1wbGVHaXRPcHRpb25zLCBTaW1wbGVHaXRUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgR2l0RXJyb3IgfSBmcm9tICcuL2dpdC1lcnJvcic7XG5cbmV4cG9ydCBjbGFzcyBHaXRQbHVnaW5FcnJvciBleHRlbmRzIEdpdEVycm9yIHtcbiAgIGNvbnN0cnVjdG9yKFxuICAgICAgcHVibGljIHRhc2s/OiBTaW1wbGVHaXRUYXNrPGFueT4sXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgcGx1Z2luPzoga2V5b2YgU2ltcGxlR2l0T3B0aW9ucyxcbiAgICAgIG1lc3NhZ2U/OiBzdHJpbmdcbiAgICkge1xuICAgICAgc3VwZXIodGFzaywgbWVzc2FnZSk7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgfVxufVxuIiwgImltcG9ydCB7IFNpbXBsZUdpdE9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBTaW1wbGVHaXRQbHVnaW4gfSBmcm9tICcuL3NpbXBsZS1naXQtcGx1Z2luJztcbmltcG9ydCB7IEdpdFBsdWdpbkVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2dpdC1wbHVnaW4tZXJyb3InO1xuXG5leHBvcnQgZnVuY3Rpb24gYWJvcnRQbHVnaW4oc2lnbmFsOiBTaW1wbGVHaXRPcHRpb25zWydhYm9ydCddKSB7XG4gICBpZiAoIXNpZ25hbCkge1xuICAgICAgcmV0dXJuO1xuICAgfVxuXG4gICBjb25zdCBvblNwYXduQWZ0ZXI6IFNpbXBsZUdpdFBsdWdpbjwnc3Bhd24uYWZ0ZXInPiA9IHtcbiAgICAgIHR5cGU6ICdzcGF3bi5hZnRlcicsXG4gICAgICBhY3Rpb24oX2RhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgIGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICAgICAgICBjb250ZXh0LmtpbGwobmV3IEdpdFBsdWdpbkVycm9yKHVuZGVmaW5lZCwgJ2Fib3J0JywgJ0Fib3J0IHNpZ25hbCByZWNlaXZlZCcpKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywga2lsbCk7XG5cbiAgICAgICAgIGNvbnRleHQuc3Bhd25lZC5vbignY2xvc2UnLCAoKSA9PiBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBraWxsKSk7XG4gICAgICB9LFxuICAgfTtcblxuICAgY29uc3Qgb25TcGF3bkJlZm9yZTogU2ltcGxlR2l0UGx1Z2luPCdzcGF3bi5iZWZvcmUnPiA9IHtcbiAgICAgIHR5cGU6ICdzcGF3bi5iZWZvcmUnLFxuICAgICAgYWN0aW9uKF9kYXRhLCBjb250ZXh0KSB7XG4gICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIGNvbnRleHQua2lsbChuZXcgR2l0UGx1Z2luRXJyb3IodW5kZWZpbmVkLCAnYWJvcnQnLCAnQWJvcnQgYWxyZWFkeSBzaWduYWxlZCcpKTtcbiAgICAgICAgIH1cbiAgICAgIH0sXG4gICB9O1xuXG4gICByZXR1cm4gW29uU3Bhd25CZWZvcmUsIG9uU3Bhd25BZnRlcl07XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBTaW1wbGVHaXRQbHVnaW4gfSBmcm9tICcuL3NpbXBsZS1naXQtcGx1Z2luJztcblxuaW1wb3J0IHsgR2l0UGx1Z2luRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZ2l0LXBsdWdpbi1lcnJvcic7XG5pbXBvcnQgdHlwZSB7IFNpbXBsZUdpdFBsdWdpbkNvbmZpZyB9IGZyb20gJy4uL3R5cGVzJztcblxuZnVuY3Rpb24gaXNDb25maWdTd2l0Y2goYXJnOiBzdHJpbmcgfCB1bmtub3duKSB7XG4gICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgJiYgYXJnLnRyaW0oKS50b0xvd2VyQ2FzZSgpID09PSAnLWMnO1xufVxuXG5mdW5jdGlvbiBwcmV2ZW50UHJvdG9jb2xPdmVycmlkZShhcmc6IHN0cmluZywgbmV4dDogc3RyaW5nKSB7XG4gICBpZiAoIWlzQ29uZmlnU3dpdGNoKGFyZykpIHtcbiAgICAgIHJldHVybjtcbiAgIH1cblxuICAgaWYgKCEvXlxccypwcm90b2NvbCguW2Etel0rKT8uYWxsb3cvLnRlc3QobmV4dCkpIHtcbiAgICAgIHJldHVybjtcbiAgIH1cblxuICAgdGhyb3cgbmV3IEdpdFBsdWdpbkVycm9yKFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgJ3Vuc2FmZScsXG4gICAgICAnQ29uZmlndXJpbmcgcHJvdG9jb2wuYWxsb3cgaXMgbm90IHBlcm1pdHRlZCB3aXRob3V0IGVuYWJsaW5nIGFsbG93VW5zYWZlRXh0UHJvdG9jb2wnXG4gICApO1xufVxuXG5mdW5jdGlvbiBwcmV2ZW50VXBsb2FkUGFjayhhcmc6IHN0cmluZywgbWV0aG9kOiBzdHJpbmcpIHtcbiAgIGlmICgvXlxccyotLSh1cGxvYWR8cmVjZWl2ZSktcGFjay8udGVzdChhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgR2l0UGx1Z2luRXJyb3IoXG4gICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAndW5zYWZlJyxcbiAgICAgICAgIGBVc2Ugb2YgLS11cGxvYWQtcGFjayBvciAtLXJlY2VpdmUtcGFjayBpcyBub3QgcGVybWl0dGVkIHdpdGhvdXQgZW5hYmxpbmcgYWxsb3dVbnNhZmVQYWNrYFxuICAgICAgKTtcbiAgIH1cblxuICAgaWYgKG1ldGhvZCA9PT0gJ2Nsb25lJyAmJiAvXlxccyotdVxcYi8udGVzdChhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgR2l0UGx1Z2luRXJyb3IoXG4gICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAndW5zYWZlJyxcbiAgICAgICAgIGBVc2Ugb2YgY2xvbmUgd2l0aCBvcHRpb24gLXUgaXMgbm90IHBlcm1pdHRlZCB3aXRob3V0IGVuYWJsaW5nIGFsbG93VW5zYWZlUGFja2BcbiAgICAgICk7XG4gICB9XG5cbiAgIGlmIChtZXRob2QgPT09ICdwdXNoJyAmJiAvXlxccyotLWV4ZWNcXGIvLnRlc3QoYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IEdpdFBsdWdpbkVycm9yKFxuICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgJ3Vuc2FmZScsXG4gICAgICAgICBgVXNlIG9mIHB1c2ggd2l0aCBvcHRpb24gLS1leGVjIGlzIG5vdCBwZXJtaXR0ZWQgd2l0aG91dCBlbmFibGluZyBhbGxvd1Vuc2FmZVBhY2tgXG4gICAgICApO1xuICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYmxvY2tVbnNhZmVPcGVyYXRpb25zUGx1Z2luKHtcbiAgIGFsbG93VW5zYWZlUHJvdG9jb2xPdmVycmlkZSA9IGZhbHNlLFxuICAgYWxsb3dVbnNhZmVQYWNrID0gZmFsc2UsXG59OiBTaW1wbGVHaXRQbHVnaW5Db25maWdbJ3Vuc2FmZSddID0ge30pOiBTaW1wbGVHaXRQbHVnaW48J3NwYXduLmFyZ3MnPiB7XG4gICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3NwYXduLmFyZ3MnLFxuICAgICAgYWN0aW9uKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgIGFyZ3MuZm9yRWFjaCgoY3VycmVudCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBpbmRleCA8IGFyZ3MubGVuZ3RoID8gYXJnc1tpbmRleCArIDFdIDogJyc7XG5cbiAgICAgICAgICAgIGFsbG93VW5zYWZlUHJvdG9jb2xPdmVycmlkZSB8fCBwcmV2ZW50UHJvdG9jb2xPdmVycmlkZShjdXJyZW50LCBuZXh0KTtcbiAgICAgICAgICAgIGFsbG93VW5zYWZlUGFjayB8fCBwcmV2ZW50VXBsb2FkUGFjayhjdXJyZW50LCBjb250ZXh0Lm1ldGhvZCk7XG4gICAgICAgICB9KTtcblxuICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJpbXBvcnQgeyBwcmVmaXhlZEFycmF5IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgU2ltcGxlR2l0UGx1Z2luIH0gZnJvbSAnLi9zaW1wbGUtZ2l0LXBsdWdpbic7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21tYW5kQ29uZmlnUHJlZml4aW5nUGx1Z2luKFxuICAgY29uZmlndXJhdGlvbjogc3RyaW5nW11cbik6IFNpbXBsZUdpdFBsdWdpbjwnc3Bhd24uYXJncyc+IHtcbiAgIGNvbnN0IHByZWZpeCA9IHByZWZpeGVkQXJyYXkoY29uZmlndXJhdGlvbiwgJy1jJyk7XG5cbiAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnc3Bhd24uYXJncycsXG4gICAgICBhY3Rpb24oZGF0YSkge1xuICAgICAgICAgcmV0dXJuIFsuLi5wcmVmaXgsIC4uLmRhdGFdO1xuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgZGVmZXJyZWQsIERlZmVycmVkUHJvbWlzZSB9IGZyb20gJ0Brd3NpdGVzL3Byb21pc2UtZGVmZXJyZWQnO1xuaW1wb3J0IHsgU2ltcGxlR2l0UGx1Z2luQ29uZmlnIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgZGVsYXkgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBTaW1wbGVHaXRQbHVnaW4gfSBmcm9tICcuL3NpbXBsZS1naXQtcGx1Z2luJztcblxuY29uc3QgbmV2ZXIgPSBkZWZlcnJlZCgpLnByb21pc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wbGV0aW9uRGV0ZWN0aW9uUGx1Z2luKHtcbiAgIG9uQ2xvc2UgPSB0cnVlLFxuICAgb25FeGl0ID0gNTAsXG59OiBTaW1wbGVHaXRQbHVnaW5Db25maWdbJ2NvbXBsZXRpb24nXSA9IHt9KTogU2ltcGxlR2l0UGx1Z2luPCdzcGF3bi5hZnRlcic+IHtcbiAgIGZ1bmN0aW9uIGNyZWF0ZUV2ZW50cygpIHtcbiAgICAgIGxldCBleGl0Q29kZSA9IC0xO1xuICAgICAgY29uc3QgZXZlbnRzID0ge1xuICAgICAgICAgY2xvc2U6IGRlZmVycmVkKCksXG4gICAgICAgICBjbG9zZVRpbWVvdXQ6IGRlZmVycmVkKCksXG4gICAgICAgICBleGl0OiBkZWZlcnJlZCgpLFxuICAgICAgICAgZXhpdFRpbWVvdXQ6IGRlZmVycmVkKCksXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgb25DbG9zZSA9PT0gZmFsc2UgPyBuZXZlciA6IGV2ZW50cy5jbG9zZVRpbWVvdXQucHJvbWlzZSxcbiAgICAgICAgIG9uRXhpdCA9PT0gZmFsc2UgPyBuZXZlciA6IGV2ZW50cy5leGl0VGltZW91dC5wcm9taXNlLFxuICAgICAgXSk7XG5cbiAgICAgIGNvbmZpZ3VyZVRpbWVvdXQob25DbG9zZSwgZXZlbnRzLmNsb3NlLCBldmVudHMuY2xvc2VUaW1lb3V0KTtcbiAgICAgIGNvbmZpZ3VyZVRpbWVvdXQob25FeGl0LCBldmVudHMuZXhpdCwgZXZlbnRzLmV4aXRUaW1lb3V0KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgIGNsb3NlKGNvZGU6IG51bWJlcikge1xuICAgICAgICAgICAgZXhpdENvZGUgPSBjb2RlO1xuICAgICAgICAgICAgZXZlbnRzLmNsb3NlLmRvbmUoKTtcbiAgICAgICAgIH0sXG4gICAgICAgICBleGl0KGNvZGU6IG51bWJlcikge1xuICAgICAgICAgICAgZXhpdENvZGUgPSBjb2RlO1xuICAgICAgICAgICAgZXZlbnRzLmV4aXQuZG9uZSgpO1xuICAgICAgICAgfSxcbiAgICAgICAgIGdldCBleGl0Q29kZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBleGl0Q29kZTtcbiAgICAgICAgIH0sXG4gICAgICAgICByZXN1bHQsXG4gICAgICB9O1xuICAgfVxuXG4gICBmdW5jdGlvbiBjb25maWd1cmVUaW1lb3V0KFxuICAgICAgZmxhZzogYm9vbGVhbiB8IG51bWJlcixcbiAgICAgIGV2ZW50OiBEZWZlcnJlZFByb21pc2U8dm9pZD4sXG4gICAgICB0aW1lb3V0OiBEZWZlcnJlZFByb21pc2U8dm9pZD5cbiAgICkge1xuICAgICAgaWYgKGZsYWcgPT09IGZhbHNlKSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIChmbGFnID09PSB0cnVlID8gZXZlbnQucHJvbWlzZSA6IGV2ZW50LnByb21pc2UudGhlbigoKSA9PiBkZWxheShmbGFnKSkpLnRoZW4odGltZW91dC5kb25lKTtcbiAgIH1cblxuICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdzcGF3bi5hZnRlcicsXG4gICAgICBhc3luYyBhY3Rpb24oX2RhdGEsIHsgc3Bhd25lZCwgY2xvc2UgfSkge1xuICAgICAgICAgY29uc3QgZXZlbnRzID0gY3JlYXRlRXZlbnRzKCk7XG5cbiAgICAgICAgIGxldCBkZWZlckNsb3NlID0gdHJ1ZTtcbiAgICAgICAgIGxldCBxdWlja0Nsb3NlID0gKCkgPT4gdm9pZCAoZGVmZXJDbG9zZSA9IGZhbHNlKTtcblxuICAgICAgICAgc3Bhd25lZC5zdGRvdXQ/Lm9uKCdkYXRhJywgcXVpY2tDbG9zZSk7XG4gICAgICAgICBzcGF3bmVkLnN0ZGVycj8ub24oJ2RhdGEnLCBxdWlja0Nsb3NlKTtcbiAgICAgICAgIHNwYXduZWQub24oJ2Vycm9yJywgcXVpY2tDbG9zZSk7XG5cbiAgICAgICAgIHNwYXduZWQub24oJ2Nsb3NlJywgKGNvZGU6IG51bWJlcikgPT4gZXZlbnRzLmNsb3NlKGNvZGUpKTtcbiAgICAgICAgIHNwYXduZWQub24oJ2V4aXQnLCAoY29kZTogbnVtYmVyKSA9PiBldmVudHMuZXhpdChjb2RlKSk7XG5cbiAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBldmVudHMucmVzdWx0O1xuICAgICAgICAgICAgaWYgKGRlZmVyQ2xvc2UpIHtcbiAgICAgICAgICAgICAgIGF3YWl0IGRlbGF5KDUwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsb3NlKGV2ZW50cy5leGl0Q29kZSk7XG4gICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNsb3NlKGV2ZW50cy5leGl0Q29kZSwgZXJyIGFzIEVycm9yKTtcbiAgICAgICAgIH1cbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImltcG9ydCB7IEdpdEVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2dpdC1lcnJvcic7XG5pbXBvcnQgeyBHaXRFeGVjdXRvclJlc3VsdCwgU2ltcGxlR2l0UGx1Z2luQ29uZmlnIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgU2ltcGxlR2l0UGx1Z2luIH0gZnJvbSAnLi9zaW1wbGUtZ2l0LXBsdWdpbic7XG5cbnR5cGUgVGFza1Jlc3VsdCA9IE9taXQ8R2l0RXhlY3V0b3JSZXN1bHQsICdyZWplY3Rpb24nPjtcblxuZnVuY3Rpb24gaXNUYXNrRXJyb3IocmVzdWx0OiBUYXNrUmVzdWx0KSB7XG4gICByZXR1cm4gISEocmVzdWx0LmV4aXRDb2RlICYmIHJlc3VsdC5zdGRFcnIubGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKHJlc3VsdDogVGFza1Jlc3VsdCkge1xuICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoWy4uLnJlc3VsdC5zdGRPdXQsIC4uLnJlc3VsdC5zdGRFcnJdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVycm9yRGV0ZWN0aW9uSGFuZGxlcihcbiAgIG92ZXJ3cml0ZSA9IGZhbHNlLFxuICAgaXNFcnJvciA9IGlzVGFza0Vycm9yLFxuICAgZXJyb3JNZXNzYWdlOiAocmVzdWx0OiBUYXNrUmVzdWx0KSA9PiBCdWZmZXIgfCBFcnJvciA9IGdldEVycm9yTWVzc2FnZVxuKSB7XG4gICByZXR1cm4gKGVycm9yOiBCdWZmZXIgfCBFcnJvciB8IHVuZGVmaW5lZCwgcmVzdWx0OiBUYXNrUmVzdWx0KSA9PiB7XG4gICAgICBpZiAoKCFvdmVyd3JpdGUgJiYgZXJyb3IpIHx8ICFpc0Vycm9yKHJlc3VsdCkpIHtcbiAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVycm9yTWVzc2FnZShyZXN1bHQpO1xuICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVycm9yRGV0ZWN0aW9uUGx1Z2luKFxuICAgY29uZmlnOiBTaW1wbGVHaXRQbHVnaW5Db25maWdbJ2Vycm9ycyddXG4pOiBTaW1wbGVHaXRQbHVnaW48J3Rhc2suZXJyb3InPiB7XG4gICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3Rhc2suZXJyb3InLFxuICAgICAgYWN0aW9uKGRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgIGNvbnN0IGVycm9yID0gY29uZmlnKGRhdGEuZXJyb3IsIHtcbiAgICAgICAgICAgIHN0ZEVycjogY29udGV4dC5zdGRFcnIsXG4gICAgICAgICAgICBzdGRPdXQ6IGNvbnRleHQuc3RkT3V0LFxuICAgICAgICAgICAgZXhpdENvZGU6IGNvbnRleHQuZXhpdENvZGUsXG4gICAgICAgICB9KTtcblxuICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihlcnJvcikpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBuZXcgR2l0RXJyb3IodW5kZWZpbmVkLCBlcnJvci50b1N0cmluZygndXRmLTgnKSkgfTtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgfTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImltcG9ydCB7IFNpbXBsZUdpdFBsdWdpbiwgU2ltcGxlR2l0UGx1Z2luVHlwZSwgU2ltcGxlR2l0UGx1Z2luVHlwZXMgfSBmcm9tICcuL3NpbXBsZS1naXQtcGx1Z2luJztcbmltcG9ydCB7IGFwcGVuZCwgYXNBcnJheSB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGNsYXNzIFBsdWdpblN0b3JlIHtcbiAgIHByaXZhdGUgcGx1Z2luczogU2V0PFNpbXBsZUdpdFBsdWdpbjxTaW1wbGVHaXRQbHVnaW5UeXBlPj4gPSBuZXcgU2V0KCk7XG5cbiAgIHB1YmxpYyBhZGQ8VCBleHRlbmRzIFNpbXBsZUdpdFBsdWdpblR5cGU+KFxuICAgICAgcGx1Z2luOiB2b2lkIHwgU2ltcGxlR2l0UGx1Z2luPFQ+IHwgU2ltcGxlR2l0UGx1Z2luPFQ+W11cbiAgICkge1xuICAgICAgY29uc3QgcGx1Z2luczogU2ltcGxlR2l0UGx1Z2luPFQ+W10gPSBbXTtcblxuICAgICAgYXNBcnJheShwbHVnaW4pLmZvckVhY2goKHBsdWdpbikgPT4gcGx1Z2luICYmIHRoaXMucGx1Z2lucy5hZGQoYXBwZW5kKHBsdWdpbnMsIHBsdWdpbikpKTtcblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgIHBsdWdpbnMuZm9yRWFjaCgocGx1Z2luKSA9PiB0aGlzLnBsdWdpbnMuZGVsZXRlKHBsdWdpbikpO1xuICAgICAgfTtcbiAgIH1cblxuICAgcHVibGljIGV4ZWM8VCBleHRlbmRzIFNpbXBsZUdpdFBsdWdpblR5cGU+KFxuICAgICAgdHlwZTogVCxcbiAgICAgIGRhdGE6IFNpbXBsZUdpdFBsdWdpblR5cGVzW1RdWydkYXRhJ10sXG4gICAgICBjb250ZXh0OiBTaW1wbGVHaXRQbHVnaW5UeXBlc1tUXVsnY29udGV4dCddXG4gICApOiB0eXBlb2YgZGF0YSB7XG4gICAgICBsZXQgb3V0cHV0ID0gZGF0YTtcbiAgICAgIGNvbnN0IGNvbnRleHR1YWwgPSBPYmplY3QuZnJlZXplKE9iamVjdC5jcmVhdGUoY29udGV4dCkpO1xuXG4gICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpIHtcbiAgICAgICAgIGlmIChwbHVnaW4udHlwZSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgb3V0cHV0ID0gcGx1Z2luLmFjdGlvbihvdXRwdXQsIGNvbnRleHR1YWwpO1xuICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgfVxufVxuIiwgImltcG9ydCB7IFNpbXBsZUdpdE9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBhc051bWJlciwgaW5jbHVkaW5nIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5pbXBvcnQgeyBTaW1wbGVHaXRQbHVnaW4gfSBmcm9tICcuL3NpbXBsZS1naXQtcGx1Z2luJztcblxuZXhwb3J0IGZ1bmN0aW9uIHByb2dyZXNzTW9uaXRvclBsdWdpbihwcm9ncmVzczogRXhjbHVkZTxTaW1wbGVHaXRPcHRpb25zWydwcm9ncmVzcyddLCB2b2lkPikge1xuICAgY29uc3QgcHJvZ3Jlc3NDb21tYW5kID0gJy0tcHJvZ3Jlc3MnO1xuICAgY29uc3QgcHJvZ3Jlc3NNZXRob2RzID0gWydjaGVja291dCcsICdjbG9uZScsICdmZXRjaCcsICdwdWxsJywgJ3B1c2gnXTtcblxuICAgY29uc3Qgb25Qcm9ncmVzczogU2ltcGxlR2l0UGx1Z2luPCdzcGF3bi5hZnRlcic+ID0ge1xuICAgICAgdHlwZTogJ3NwYXduLmFmdGVyJyxcbiAgICAgIGFjdGlvbihfZGF0YSwgY29udGV4dCkge1xuICAgICAgICAgaWYgKCFjb250ZXh0LmNvbW1hbmRzLmluY2x1ZGVzKHByb2dyZXNzQ29tbWFuZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgIH1cblxuICAgICAgICAgY29udGV4dC5zcGF3bmVkLnN0ZGVycj8ub24oJ2RhdGEnLCAoY2h1bms6IEJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IC9eKFtcXHNcXFNdKz8pOlxccyooXFxkKyklIFxcKChcXGQrKVxcLyhcXGQrKVxcKS8uZXhlYyhjaHVuay50b1N0cmluZygndXRmOCcpKTtcbiAgICAgICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcm9ncmVzcyh7XG4gICAgICAgICAgICAgICBtZXRob2Q6IGNvbnRleHQubWV0aG9kLFxuICAgICAgICAgICAgICAgc3RhZ2U6IHByb2dyZXNzRXZlbnRTdGFnZShtZXNzYWdlWzFdKSxcbiAgICAgICAgICAgICAgIHByb2dyZXNzOiBhc051bWJlcihtZXNzYWdlWzJdKSxcbiAgICAgICAgICAgICAgIHByb2Nlc3NlZDogYXNOdW1iZXIobWVzc2FnZVszXSksXG4gICAgICAgICAgICAgICB0b3RhbDogYXNOdW1iZXIobWVzc2FnZVs0XSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgIH0pO1xuICAgICAgfSxcbiAgIH07XG5cbiAgIGNvbnN0IG9uQXJnczogU2ltcGxlR2l0UGx1Z2luPCdzcGF3bi5hcmdzJz4gPSB7XG4gICAgICB0eXBlOiAnc3Bhd24uYXJncycsXG4gICAgICBhY3Rpb24oYXJncywgY29udGV4dCkge1xuICAgICAgICAgaWYgKCFwcm9ncmVzc01ldGhvZHMuaW5jbHVkZXMoY29udGV4dC5tZXRob2QpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIGluY2x1ZGluZyhhcmdzLCBwcm9ncmVzc0NvbW1hbmQpO1xuICAgICAgfSxcbiAgIH07XG5cbiAgIHJldHVybiBbb25BcmdzLCBvblByb2dyZXNzXTtcbn1cblxuZnVuY3Rpb24gcHJvZ3Jlc3NFdmVudFN0YWdlKGlucHV0OiBzdHJpbmcpIHtcbiAgIHJldHVybiBTdHJpbmcoaW5wdXQudG9Mb3dlckNhc2UoKS5zcGxpdCgnICcsIDEpKSB8fCAndW5rbm93bic7XG59XG4iLCAiaW1wb3J0IHsgU3Bhd25PcHRpb25zIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgeyBwaWNrIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgU2ltcGxlR2l0UGx1Z2luIH0gZnJvbSAnLi9zaW1wbGUtZ2l0LXBsdWdpbic7XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGF3bk9wdGlvbnNQbHVnaW4oXG4gICBzcGF3bk9wdGlvbnM6IFBhcnRpYWw8U3Bhd25PcHRpb25zPlxuKTogU2ltcGxlR2l0UGx1Z2luPCdzcGF3bi5vcHRpb25zJz4ge1xuICAgY29uc3Qgb3B0aW9ucyA9IHBpY2soc3Bhd25PcHRpb25zLCBbJ3VpZCcsICdnaWQnXSk7XG5cbiAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnc3Bhd24ub3B0aW9ucycsXG4gICAgICBhY3Rpb24oZGF0YSkge1xuICAgICAgICAgcmV0dXJuIHsgLi4ub3B0aW9ucywgLi4uZGF0YSB9O1xuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBTaW1wbGVHaXRQbHVnaW4gfSBmcm9tICcuL3NpbXBsZS1naXQtcGx1Z2luJztcblxuaW1wb3J0IHR5cGUgeyBTaW1wbGVHaXRPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgR2l0UGx1Z2luRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZ2l0LXBsdWdpbi1lcnJvcic7XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lb3V0UGx1Z2luKHtcbiAgIGJsb2NrLFxuICAgc3RkRXJyID0gdHJ1ZSxcbiAgIHN0ZE91dCA9IHRydWUsXG59OiBFeGNsdWRlPFNpbXBsZUdpdE9wdGlvbnNbJ3RpbWVvdXQnXSwgdW5kZWZpbmVkPik6IFNpbXBsZUdpdFBsdWdpbjwnc3Bhd24uYWZ0ZXInPiB8IHZvaWQge1xuICAgaWYgKGJsb2NrID4gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgIHR5cGU6ICdzcGF3bi5hZnRlcicsXG4gICAgICAgICBhY3Rpb24oX2RhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGxldCB0aW1lb3V0OiBOb2RlSlMuVGltZW91dDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gd2FpdCgpIHtcbiAgICAgICAgICAgICAgIHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoa2lsbCwgYmxvY2spO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICAgICAgICAgY29udGV4dC5zcGF3bmVkLnN0ZG91dD8ub2ZmKCdkYXRhJywgd2FpdCk7XG4gICAgICAgICAgICAgICBjb250ZXh0LnNwYXduZWQuc3RkZXJyPy5vZmYoJ2RhdGEnLCB3YWl0KTtcbiAgICAgICAgICAgICAgIGNvbnRleHQuc3Bhd25lZC5vZmYoJ2V4aXQnLCBzdG9wKTtcbiAgICAgICAgICAgICAgIGNvbnRleHQuc3Bhd25lZC5vZmYoJ2Nsb3NlJywgc3RvcCk7XG4gICAgICAgICAgICAgICB0aW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24ga2lsbCgpIHtcbiAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgICAgIGNvbnRleHQua2lsbChuZXcgR2l0UGx1Z2luRXJyb3IodW5kZWZpbmVkLCAndGltZW91dCcsIGBibG9jayB0aW1lb3V0IHJlYWNoZWRgKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0ZE91dCAmJiBjb250ZXh0LnNwYXduZWQuc3Rkb3V0Py5vbignZGF0YScsIHdhaXQpO1xuICAgICAgICAgICAgc3RkRXJyICYmIGNvbnRleHQuc3Bhd25lZC5zdGRlcnI/Lm9uKCdkYXRhJywgd2FpdCk7XG4gICAgICAgICAgICBjb250ZXh0LnNwYXduZWQub24oJ2V4aXQnLCBzdG9wKTtcbiAgICAgICAgICAgIGNvbnRleHQuc3Bhd25lZC5vbignY2xvc2UnLCBzdG9wKTtcblxuICAgICAgICAgICAgd2FpdCgpO1xuICAgICAgICAgfSxcbiAgICAgIH07XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgU2ltcGxlR2l0UGx1Z2luIH0gZnJvbSAnLi9zaW1wbGUtZ2l0LXBsdWdpbic7XG5pbXBvcnQgeyBpc1BhdGhTcGVjLCB0b1BhdGhzIH0gZnJvbSAnLi4vYXJncy9wYXRoc3BlYyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdWZmaXhQYXRoc1BsdWdpbigpOiBTaW1wbGVHaXRQbHVnaW48J3NwYXduLmFyZ3MnPiB7XG4gICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3NwYXduLmFyZ3MnLFxuICAgICAgYWN0aW9uKGRhdGEpIHtcbiAgICAgICAgIGNvbnN0IHByZWZpeDogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgIGxldCBzdWZmaXg6IHVuZGVmaW5lZCB8IHN0cmluZ1tdO1xuICAgICAgICAgZnVuY3Rpb24gYXBwZW5kKGFyZ3M6IHN0cmluZ1tdKSB7XG4gICAgICAgICAgICAoc3VmZml4ID0gc3VmZml4IHx8IFtdKS5wdXNoKC4uLmFyZ3MpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtID0gZGF0YVtpXTtcblxuICAgICAgICAgICAgaWYgKGlzUGF0aFNwZWMocGFyYW0pKSB7XG4gICAgICAgICAgICAgICBhcHBlbmQodG9QYXRocyhwYXJhbSkpO1xuICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJhbSA9PT0gJy0tJykge1xuICAgICAgICAgICAgICAgYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgZGF0YS5zbGljZShpICsgMSkuZmxhdE1hcCgoaXRlbSkgPT4gKGlzUGF0aFNwZWMoaXRlbSkgJiYgdG9QYXRocyhpdGVtKSkgfHwgaXRlbSlcbiAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJlZml4LnB1c2gocGFyYW0pO1xuICAgICAgICAgfVxuXG4gICAgICAgICByZXR1cm4gIXN1ZmZpeCA/IHByZWZpeCA6IFsuLi5wcmVmaXgsICctLScsIC4uLnN1ZmZpeC5tYXAoU3RyaW5nKV07XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJpbXBvcnQgeyBTaW1wbGVHaXRGYWN0b3J5IH0gZnJvbSAnLi4vLi4vdHlwaW5ncyc7XG5cbmltcG9ydCAqIGFzIGFwaSBmcm9tICcuL2FwaSc7XG5pbXBvcnQge1xuICAgYWJvcnRQbHVnaW4sXG4gICBibG9ja1Vuc2FmZU9wZXJhdGlvbnNQbHVnaW4sXG4gICBjb21tYW5kQ29uZmlnUHJlZml4aW5nUGx1Z2luLFxuICAgY29tcGxldGlvbkRldGVjdGlvblBsdWdpbixcbiAgIGVycm9yRGV0ZWN0aW9uSGFuZGxlcixcbiAgIGVycm9yRGV0ZWN0aW9uUGx1Z2luLFxuICAgUGx1Z2luU3RvcmUsXG4gICBwcm9ncmVzc01vbml0b3JQbHVnaW4sXG4gICBzcGF3bk9wdGlvbnNQbHVnaW4sXG4gICB0aW1lb3V0UGx1Z2luLFxufSBmcm9tICcuL3BsdWdpbnMnO1xuaW1wb3J0IHsgc3VmZml4UGF0aHNQbHVnaW4gfSBmcm9tICcuL3BsdWdpbnMvc3VmZml4LXBhdGhzLnBsdWdpbic7XG5pbXBvcnQgeyBjcmVhdGVJbnN0YW5jZUNvbmZpZywgZm9sZGVyRXhpc3RzIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBTaW1wbGVHaXRPcHRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IEdpdCA9IHJlcXVpcmUoJy4uL2dpdCcpO1xuXG4vKipcbiAqIEFkZHMgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzIHRvIHRoZSBzdXBwbGllZCBvYmplY3QgdG8gZW5hYmxlIGl0IGZvciB1c2UgYXNcbiAqIHRoZSBkZWZhdWx0IGV4cG9ydCBvZiBhIG1vZHVsZS5cbiAqXG4gKiBFZzogYG1vZHVsZS5leHBvcnRzID0gZXNNb2R1bGVGYWN0b3J5KHsgc29tZXRoaW5nICgpIHt9IH0pYFxuICovXG5leHBvcnQgZnVuY3Rpb24gZXNNb2R1bGVGYWN0b3J5PFQ+KGRlZmF1bHRFeHBvcnQ6IFQpIHtcbiAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhkZWZhdWx0RXhwb3J0LCB7XG4gICAgICBfX2VzTW9kdWxlOiB7IHZhbHVlOiB0cnVlIH0sXG4gICAgICBkZWZhdWx0OiB7IHZhbHVlOiBkZWZhdWx0RXhwb3J0IH0sXG4gICB9KSBhcyBUICYgeyBfX2VzTW9kdWxlOiB0cnVlOyBkZWZhdWx0OiBUIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnaXRFeHBvcnRGYWN0b3J5KGZhY3Rvcnk6IFNpbXBsZUdpdEZhY3RvcnkpIHtcbiAgIHJldHVybiBPYmplY3QuYXNzaWduKGZhY3RvcnkuYmluZChudWxsKSwgYXBpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdpdEluc3RhbmNlRmFjdG9yeShcbiAgIGJhc2VEaXI/OiBzdHJpbmcgfCBQYXJ0aWFsPFNpbXBsZUdpdE9wdGlvbnM+LFxuICAgb3B0aW9ucz86IFBhcnRpYWw8U2ltcGxlR2l0T3B0aW9ucz5cbikge1xuICAgY29uc3QgcGx1Z2lucyA9IG5ldyBQbHVnaW5TdG9yZSgpO1xuICAgY29uc3QgY29uZmlnID0gY3JlYXRlSW5zdGFuY2VDb25maWcoXG4gICAgICAoYmFzZURpciAmJiAodHlwZW9mIGJhc2VEaXIgPT09ICdzdHJpbmcnID8geyBiYXNlRGlyIH0gOiBiYXNlRGlyKSkgfHwge30sXG4gICAgICBvcHRpb25zXG4gICApO1xuXG4gICBpZiAoIWZvbGRlckV4aXN0cyhjb25maWcuYmFzZURpcikpIHtcbiAgICAgIHRocm93IG5ldyBhcGkuR2l0Q29uc3RydWN0RXJyb3IoXG4gICAgICAgICBjb25maWcsXG4gICAgICAgICBgQ2Fubm90IHVzZSBzaW1wbGUtZ2l0IG9uIGEgZGlyZWN0b3J5IHRoYXQgZG9lcyBub3QgZXhpc3RgXG4gICAgICApO1xuICAgfVxuXG4gICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcuY29uZmlnKSkge1xuICAgICAgcGx1Z2lucy5hZGQoY29tbWFuZENvbmZpZ1ByZWZpeGluZ1BsdWdpbihjb25maWcuY29uZmlnKSk7XG4gICB9XG5cbiAgIHBsdWdpbnMuYWRkKGJsb2NrVW5zYWZlT3BlcmF0aW9uc1BsdWdpbihjb25maWcudW5zYWZlKSk7XG4gICBwbHVnaW5zLmFkZChzdWZmaXhQYXRoc1BsdWdpbigpKTtcbiAgIHBsdWdpbnMuYWRkKGNvbXBsZXRpb25EZXRlY3Rpb25QbHVnaW4oY29uZmlnLmNvbXBsZXRpb24pKTtcbiAgIGNvbmZpZy5hYm9ydCAmJiBwbHVnaW5zLmFkZChhYm9ydFBsdWdpbihjb25maWcuYWJvcnQpKTtcbiAgIGNvbmZpZy5wcm9ncmVzcyAmJiBwbHVnaW5zLmFkZChwcm9ncmVzc01vbml0b3JQbHVnaW4oY29uZmlnLnByb2dyZXNzKSk7XG4gICBjb25maWcudGltZW91dCAmJiBwbHVnaW5zLmFkZCh0aW1lb3V0UGx1Z2luKGNvbmZpZy50aW1lb3V0KSk7XG4gICBjb25maWcuc3Bhd25PcHRpb25zICYmIHBsdWdpbnMuYWRkKHNwYXduT3B0aW9uc1BsdWdpbihjb25maWcuc3Bhd25PcHRpb25zKSk7XG5cbiAgIHBsdWdpbnMuYWRkKGVycm9yRGV0ZWN0aW9uUGx1Z2luKGVycm9yRGV0ZWN0aW9uSGFuZGxlcih0cnVlKSkpO1xuICAgY29uZmlnLmVycm9ycyAmJiBwbHVnaW5zLmFkZChlcnJvckRldGVjdGlvblBsdWdpbihjb25maWcuZXJyb3JzKSk7XG5cbiAgIHJldHVybiBuZXcgR2l0KGNvbmZpZywgcGx1Z2lucyk7XG59XG4iLCAiaW1wb3J0IHsgU2ltcGxlR2l0LCBTaW1wbGVHaXRPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5cbmltcG9ydCB7IEdpdFJlc3BvbnNlRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZ2l0LXJlc3BvbnNlLWVycm9yJztcbmltcG9ydCB7IGdpdEluc3RhbmNlRmFjdG9yeSB9IGZyb20gJy4uL2dpdC1mYWN0b3J5JztcbmltcG9ydCB7IFNpbXBsZUdpdFRhc2tDYWxsYmFjayB9IGZyb20gJy4uL3R5cGVzJztcblxuY29uc3QgZnVuY3Rpb25OYW1lc0J1aWxkZXJBcGkgPSBbJ2N1c3RvbUJpbmFyeScsICdlbnYnLCAnb3V0cHV0SGFuZGxlcicsICdzaWxlbnQnXTtcblxuY29uc3QgZnVuY3Rpb25OYW1lc1Byb21pc2VBcGkgPSBbXG4gICAnYWRkJyxcbiAgICdhZGRBbm5vdGF0ZWRUYWcnLFxuICAgJ2FkZENvbmZpZycsXG4gICAnYWRkUmVtb3RlJyxcbiAgICdhZGRUYWcnLFxuICAgJ2FwcGx5UGF0Y2gnLFxuICAgJ2JpbmFyeUNhdEZpbGUnLFxuICAgJ2JyYW5jaCcsXG4gICAnYnJhbmNoTG9jYWwnLFxuICAgJ2NhdEZpbGUnLFxuICAgJ2NoZWNrSWdub3JlJyxcbiAgICdjaGVja0lzUmVwbycsXG4gICAnY2hlY2tvdXQnLFxuICAgJ2NoZWNrb3V0QnJhbmNoJyxcbiAgICdjaGVja291dExhdGVzdFRhZycsXG4gICAnY2hlY2tvdXRMb2NhbEJyYW5jaCcsXG4gICAnY2xlYW4nLFxuICAgJ2Nsb25lJyxcbiAgICdjb21taXQnLFxuICAgJ2N3ZCcsXG4gICAnZGVsZXRlTG9jYWxCcmFuY2gnLFxuICAgJ2RlbGV0ZUxvY2FsQnJhbmNoZXMnLFxuICAgJ2RpZmYnLFxuICAgJ2RpZmZTdW1tYXJ5JyxcbiAgICdleGVjJyxcbiAgICdmZXRjaCcsXG4gICAnZ2V0UmVtb3RlcycsXG4gICAnaW5pdCcsXG4gICAnbGlzdENvbmZpZycsXG4gICAnbGlzdFJlbW90ZScsXG4gICAnbG9nJyxcbiAgICdtZXJnZScsXG4gICAnbWVyZ2VGcm9tVG8nLFxuICAgJ21pcnJvcicsXG4gICAnbXYnLFxuICAgJ3B1bGwnLFxuICAgJ3B1c2gnLFxuICAgJ3B1c2hUYWdzJyxcbiAgICdyYXcnLFxuICAgJ3JlYmFzZScsXG4gICAncmVtb3RlJyxcbiAgICdyZW1vdmVSZW1vdGUnLFxuICAgJ3Jlc2V0JyxcbiAgICdyZXZlcnQnLFxuICAgJ3JldnBhcnNlJyxcbiAgICdybScsXG4gICAncm1LZWVwTG9jYWwnLFxuICAgJ3Nob3cnLFxuICAgJ3N0YXNoJyxcbiAgICdzdGFzaExpc3QnLFxuICAgJ3N0YXR1cycsXG4gICAnc3ViTW9kdWxlJyxcbiAgICdzdWJtb2R1bGVBZGQnLFxuICAgJ3N1Ym1vZHVsZUluaXQnLFxuICAgJ3N1Ym1vZHVsZVVwZGF0ZScsXG4gICAndGFnJyxcbiAgICd0YWdzJyxcbiAgICd1cGRhdGVTZXJ2ZXJJbmZvJyxcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiBnaXRQKFxuICAgLi4uYXJnczogW10gfCBbc3RyaW5nXSB8IFtQYXJ0aWFsPFNpbXBsZUdpdE9wdGlvbnM+XSB8IFtzdHJpbmcsIFBhcnRpYWw8U2ltcGxlR2l0T3B0aW9ucz5dXG4pOiBTaW1wbGVHaXQge1xuICAgbGV0IGdpdDogYW55O1xuXG4gICBsZXQgY2hhaW4gPSBQcm9taXNlLnJlc29sdmUoKTtcblxuICAgdHJ5IHtcbiAgICAgIGdpdCA9IGdpdEluc3RhbmNlRmFjdG9yeSguLi5hcmdzKTtcbiAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNoYWluID0gUHJvbWlzZS5yZWplY3QoZSk7XG4gICB9XG5cbiAgIGZ1bmN0aW9uIGJ1aWxkZXJSZXR1cm4oKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZUFwaTtcbiAgIH1cblxuICAgZnVuY3Rpb24gY2hhaW5SZXR1cm4oKSB7XG4gICAgICByZXR1cm4gY2hhaW47XG4gICB9XG5cbiAgIGNvbnN0IHByb21pc2VBcGkgPSBbLi4uZnVuY3Rpb25OYW1lc0J1aWxkZXJBcGksIC4uLmZ1bmN0aW9uTmFtZXNQcm9taXNlQXBpXS5yZWR1Y2UoXG4gICAgICAoYXBpOiBhbnksIG5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgICAgY29uc3QgaXNBc3luYyA9IGZ1bmN0aW9uTmFtZXNQcm9taXNlQXBpLmluY2x1ZGVzKG5hbWUpO1xuXG4gICAgICAgICBjb25zdCB2YWxpZCA9IGlzQXN5bmMgPyBhc3luY1dyYXBwZXIobmFtZSwgZ2l0KSA6IHN5bmNXcmFwcGVyKG5hbWUsIGdpdCwgYXBpKTtcbiAgICAgICAgIGNvbnN0IGFsdGVybmF0aXZlID0gaXNBc3luYyA/IGNoYWluUmV0dXJuIDogYnVpbGRlclJldHVybjtcblxuICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwaSwgbmFtZSwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IGdpdCA/IHZhbGlkIDogYWx0ZXJuYXRpdmUsXG4gICAgICAgICB9KTtcblxuICAgICAgICAgcmV0dXJuIGFwaTtcbiAgICAgIH0sXG4gICAgICB7fVxuICAgKTtcblxuICAgcmV0dXJuIHByb21pc2VBcGkgYXMgU2ltcGxlR2l0O1xuXG4gICBmdW5jdGlvbiBhc3luY1dyYXBwZXIoZm46IHN0cmluZywgZ2l0OiBhbnkpOiAoLi4uYXJnczogYW55W10pID0+IFByb21pc2U8YW55PiB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgICAgICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGhdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgJ1Byb21pc2UgaW50ZXJmYWNlIHJlcXVpcmVzIHRoYXQgaGFuZGxlcnMgYXJlIG5vdCBzdXBwbGllZCBpbmxpbmUsICcgK1xuICAgICAgICAgICAgICAgICAgJ3RyYWlsaW5nIGZ1bmN0aW9uIG5vdCBhbGxvd2VkIGluIGNhbGwgdG8gJyArXG4gICAgICAgICAgICAgICAgICBmblxuICAgICAgICAgICAgKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIGNoYWluLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrOiBTaW1wbGVHaXRUYXNrQ2FsbGJhY2sgPSAoZXJyOiBFcnJvciB8IG51bGwsIHJlc3VsdD86IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCh0b0Vycm9yKGVycikpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgYXJncy5wdXNoKGNhbGxiYWNrKTtcblxuICAgICAgICAgICAgICAgZ2l0W2ZuXS5hcHBseShnaXQsIGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICB9KTtcbiAgICAgIH07XG4gICB9XG5cbiAgIGZ1bmN0aW9uIHN5bmNXcmFwcGVyKGZuOiBzdHJpbmcsIGdpdDogYW55LCBhcGk6IFNpbXBsZUdpdCkge1xuICAgICAgcmV0dXJuICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgICAgICAgZ2l0W2ZuXSguLi5hcmdzKTtcblxuICAgICAgICAgcmV0dXJuIGFwaTtcbiAgICAgIH07XG4gICB9XG59XG5cbmZ1bmN0aW9uIHRvRXJyb3IoZXJyb3I6IEVycm9yIHwgc3RyaW5nIHwgYW55KTogRXJyb3Ige1xuICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgIH1cblxuICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoZXJyb3IpO1xuICAgfVxuXG4gICByZXR1cm4gbmV3IEdpdFJlc3BvbnNlRXJyb3IoZXJyb3IpO1xufVxuIiwgImltcG9ydCB7IGdpdEluc3RhbmNlRmFjdG9yeSB9IGZyb20gJy4vbGliL2dpdC1mYWN0b3J5JztcblxuZXhwb3J0IHsgZ2l0UCB9IGZyb20gJy4vbGliL3J1bm5lcnMvcHJvbWlzZS13cmFwcGVkJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL2FwaSc7XG5cbmV4cG9ydCBjb25zdCBzaW1wbGVHaXQgPSBnaXRJbnN0YW5jZUZhY3Rvcnk7XG5cbmV4cG9ydCBkZWZhdWx0IGdpdEluc3RhbmNlRmFjdG9yeTtcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFB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QUEsTUFDSTtBQUdBLFlBQU0sV0FBVyxNQUFNLE1BQU0sS0FBSyxTQUFTLFlBQVksWUFBWTtBQUNuRSxZQUFNLE9BQU8sTUFBTSxTQUFTLEtBQUs7QUFHakMsVUFBSSx1QkFBTyxJQUFJO0FBQUEsSUFDakIsU0FBUyxPQUFQO0FBQ0EsY0FBUSxNQUFNLDJCQUEyQixLQUFLO0FBQzlDLFVBQUksdUJBQU8sdUJBQXVCLE1BQU0sT0FBTztBQUFBLElBQ2pEO0FBQUEsRUFDRjtBQUNGO0FBR0EsSUFBTSxrQkFBTixjQUE4QixpQ0FBaUI7QUFBQSxFQUc3QyxZQUFZLEtBQVUsUUFBcUI7QUFDekMsVUFBTSxLQUFLLE1BQU07QUFDakIsU0FBSyxTQUFTO0FBQUEsRUFDaEI7QUFBQSxFQUVBLFVBQWdCO0FBQ2QsVUFBTSxFQUFDLFlBQVcsSUFBSTtBQUV0QixnQkFBWSxNQUFNO0FBRWxCLFFBQUksd0JBQVEsV0FBVyxFQUNwQixRQUFRLGFBQWEsRUFDckIsUUFBUSxrRUFBa0UsRUFDMUUsUUFBUSxVQUFRLEtBQ2QsZUFBZSwwQ0FBMEMsRUFDekQsU0FBUyxLQUFLLE9BQU8sU0FBUyxVQUFVLEVBQ3hDLFNBQVMsT0FBTyxVQUFVO0FBQ3pCLFdBQUssT0FBTyxTQUFTLGFBQWE7QUFDbEMsWUFBTSxLQUFLLE9BQU8sYUFBYTtBQUFBLElBQ2pDLENBQUMsQ0FBQztBQUVOLFFBQUksd0JBQVEsV0FBVyxFQUNwQixRQUFRLGtCQUFrQixFQUMxQixRQUFRLHVEQUF1RCxFQUMvRCxRQUFRLFVBQVEsS0FDZCxlQUFlLFFBQVEsRUFDdkIsU0FBUyxLQUFLLE9BQU8sU0FBUyxlQUFlLEVBQzdDLFNBQVMsT0FBTyxVQUFVO0FBQ3pCLFdBQUssT0FBTyxTQUFTLGtCQUFrQjtBQUN2QyxZQUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsSUFDakMsQ0FBQyxDQUFDO0FBRU4sUUFBSSx3QkFBUSxXQUFXLEVBQ3BCLFFBQVEsa0JBQWtCLEVBQzFCLFFBQVEsdURBQXVELEVBQy9ELFFBQVEsVUFBUSxLQUNkLGVBQWUsT0FBTyxFQUN0QixTQUFTLEtBQUssT0FBTyxTQUFTLGVBQWUsRUFDN0MsU0FBUyxPQUFPLFVBQVU7QUFDekIsV0FBSyxPQUFPLFNBQVMsa0JBQWtCO0FBQ3ZDLFlBQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxJQUNqQyxDQUFDLENBQUM7QUFBQSxFQUNSO0FBQ0Y7IiwKICAibmFtZXMiOiBbIm1vZHVsZSIsICJtb2R1bGUiLCAiZGVidWciLCAibW9kdWxlIiwgImV4aXN0cyIsICJfX2V4cG9ydCIsICJkZWZlcnJlZCIsICJpbXBvcnRfcHJvbWlzZV9kZWZlcnJlZCIsICJfX2V4cG9ydCIsICJDbGVhbk9wdGlvbnMyIiwgImRlYnVnIiwgIl9fY29tbW9uSlMiLCAibW9kdWxlIiwgIl9fdG9Db21tb25KUyJdCn0K
