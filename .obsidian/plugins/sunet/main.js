/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self = debug2;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/@kwsites/file-exists/dist/src/index.js
var require_src = __commonJS({
  "node_modules/@kwsites/file-exists/dist/src/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs_1 = require("fs");
    var debug_1 = __importDefault(require_browser());
    var log = debug_1.default("@kwsites/file-exists");
    function check(path, isFile, isDirectory) {
      log(`checking %s`, path);
      try {
        const stat = fs_1.statSync(path);
        if (stat.isFile() && isFile) {
          log(`[OK] path represents a file`);
          return true;
        }
        if (stat.isDirectory() && isDirectory) {
          log(`[OK] path represents a directory`);
          return true;
        }
        log(`[FAIL] path represents something other than a file or directory`);
        return false;
      } catch (e) {
        if (e.code === "ENOENT") {
          log(`[FAIL] path is not accessible: %o`, e);
          return false;
        }
        log(`[FATAL] %o`, e);
        throw e;
      }
    }
    function exists2(path, type = exports.READABLE) {
      return check(path, (type & exports.FILE) > 0, (type & exports.FOLDER) > 0);
    }
    exports.exists = exists2;
    exports.FILE = 1;
    exports.FOLDER = 2;
    exports.READABLE = exports.FILE + exports.FOLDER;
  }
});

// node_modules/@kwsites/file-exists/dist/index.js
var require_dist = __commonJS({
  "node_modules/@kwsites/file-exists/dist/index.js"(exports) {
    "use strict";
    function __export3(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export3(require_src());
  }
});

// node_modules/@kwsites/promise-deferred/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@kwsites/promise-deferred/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDeferred = exports.deferred = void 0;
    function deferred2() {
      let done;
      let fail;
      let status = "pending";
      const promise = new Promise((_done, _fail) => {
        done = _done;
        fail = _fail;
      });
      return {
        promise,
        done(result) {
          if (status === "pending") {
            status = "resolved";
            done(result);
          }
        },
        fail(error) {
          if (status === "pending") {
            status = "rejected";
            fail(error);
          }
        },
        get fulfilled() {
          return status !== "pending";
        },
        get status() {
          return status;
        }
      };
    }
    exports.deferred = deferred2;
    exports.createDeferred = deferred2;
    exports.default = deferred2;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SunetPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// node_modules/simple-git/dist/esm/index.js
var import_file_exists = __toESM(require_dist(), 1);
var import_debug = __toESM(require_browser(), 1);
var import_child_process = require("child_process");
var import_promise_deferred = __toESM(require_dist2(), 1);
var import_promise_deferred2 = __toESM(require_dist2(), 1);
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;
};
var __commonJS2 = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames2(module2))
      if (!__hasOwnProp2.call(target, key) && (copyDefault || key !== "default"))
        __defProp2(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc2(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toCommonJS2 = /* @__PURE__ */ ((cache2) => {
  return (module2, temp) => {
    return cache2 && cache2.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache2 && cache2.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function pathspec(...paths) {
  const key = new String(paths);
  cache.set(key, paths);
  return key;
}
function isPathSpec(path) {
  return path instanceof String && cache.has(path);
}
function toPaths(pathSpec) {
  return cache.get(pathSpec) || [];
}
var cache;
var init_pathspec = __esm({
  "src/lib/args/pathspec.ts"() {
    cache = /* @__PURE__ */ new WeakMap();
  }
});
var GitError;
var init_git_error = __esm({
  "src/lib/errors/git-error.ts"() {
    GitError = class extends Error {
      constructor(task, message) {
        super(message);
        this.task = task;
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
  }
});
var GitResponseError;
var init_git_response_error = __esm({
  "src/lib/errors/git-response-error.ts"() {
    init_git_error();
    GitResponseError = class extends GitError {
      constructor(git, message) {
        super(void 0, message || String(git));
        this.git = git;
      }
    };
  }
});
var TaskConfigurationError;
var init_task_configuration_error = __esm({
  "src/lib/errors/task-configuration-error.ts"() {
    init_git_error();
    TaskConfigurationError = class extends GitError {
      constructor(message) {
        super(void 0, message);
      }
    };
  }
});
function asFunction(source) {
  return typeof source === "function" ? source : NOOP;
}
function isUserFunction(source) {
  return typeof source === "function" && source !== NOOP;
}
function splitOn(input, char) {
  const index = input.indexOf(char);
  if (index <= 0) {
    return [input, ""];
  }
  return [input.substr(0, index), input.substr(index + 1)];
}
function first(input, offset = 0) {
  return isArrayLike(input) && input.length > offset ? input[offset] : void 0;
}
function last(input, offset = 0) {
  if (isArrayLike(input) && input.length > offset) {
    return input[input.length - 1 - offset];
  }
}
function isArrayLike(input) {
  return !!(input && typeof input.length === "number");
}
function toLinesWithContent(input = "", trimmed2 = true, separator = "\n") {
  return input.split(separator).reduce((output, line) => {
    const lineContent = trimmed2 ? line.trim() : line;
    if (lineContent) {
      output.push(lineContent);
    }
    return output;
  }, []);
}
function forEachLineWithContent(input, callback) {
  return toLinesWithContent(input, true).map((line) => callback(line));
}
function folderExists(path) {
  return (0, import_file_exists.exists)(path, import_file_exists.FOLDER);
}
function append(target, item) {
  if (Array.isArray(target)) {
    if (!target.includes(item)) {
      target.push(item);
    }
  } else {
    target.add(item);
  }
  return item;
}
function including(target, item) {
  if (Array.isArray(target) && !target.includes(item)) {
    target.push(item);
  }
  return target;
}
function remove(target, item) {
  if (Array.isArray(target)) {
    const index = target.indexOf(item);
    if (index >= 0) {
      target.splice(index, 1);
    }
  } else {
    target.delete(item);
  }
  return item;
}
function asArray(source) {
  return Array.isArray(source) ? source : [source];
}
function asStringArray(source) {
  return asArray(source).map(String);
}
function asNumber(source, onNaN = 0) {
  if (source == null) {
    return onNaN;
  }
  const num = parseInt(source, 10);
  return isNaN(num) ? onNaN : num;
}
function prefixedArray(input, prefix) {
  const output = [];
  for (let i = 0, max = input.length; i < max; i++) {
    output.push(prefix, input[i]);
  }
  return output;
}
function bufferToString(input) {
  return (Array.isArray(input) ? Buffer.concat(input) : input).toString("utf-8");
}
function pick(source, properties) {
  return Object.assign({}, ...properties.map((property) => property in source ? { [property]: source[property] } : {}));
}
function delay(duration = 0) {
  return new Promise((done) => setTimeout(done, duration));
}
function orVoid(input) {
  if (input === false) {
    return void 0;
  }
  return input;
}
var NULL;
var NOOP;
var objectToString;
var init_util = __esm({
  "src/lib/utils/util.ts"() {
    NULL = "\0";
    NOOP = () => {
    };
    objectToString = Object.prototype.toString.call.bind(Object.prototype.toString);
  }
});
function filterType(input, filter, def) {
  if (filter(input)) {
    return input;
  }
  return arguments.length > 2 ? def : void 0;
}
function filterPrimitives(input, omit) {
  const type = isPathSpec(input) ? "string" : typeof input;
  return /number|string|boolean/.test(type) && (!omit || !omit.includes(type));
}
function filterPlainObject(input) {
  return !!input && objectToString(input) === "[object Object]";
}
function filterFunction(input) {
  return typeof input === "function";
}
var filterArray;
var filterString;
var filterStringArray;
var filterStringOrStringArray;
var filterHasLength;
var init_argument_filters = __esm({
  "src/lib/utils/argument-filters.ts"() {
    init_util();
    init_pathspec();
    filterArray = (input) => {
      return Array.isArray(input);
    };
    filterString = (input) => {
      return typeof input === "string";
    };
    filterStringArray = (input) => {
      return Array.isArray(input) && input.every(filterString);
    };
    filterStringOrStringArray = (input) => {
      return filterString(input) || Array.isArray(input) && input.every(filterString);
    };
    filterHasLength = (input) => {
      if (input == null || "number|boolean|function".includes(typeof input)) {
        return false;
      }
      return Array.isArray(input) || typeof input === "string" || typeof input.length === "number";
    };
  }
});
var ExitCodes;
var init_exit_codes = __esm({
  "src/lib/utils/exit-codes.ts"() {
    ExitCodes = /* @__PURE__ */ ((ExitCodes2) => {
      ExitCodes2[ExitCodes2["SUCCESS"] = 0] = "SUCCESS";
      ExitCodes2[ExitCodes2["ERROR"] = 1] = "ERROR";
      ExitCodes2[ExitCodes2["NOT_FOUND"] = -2] = "NOT_FOUND";
      ExitCodes2[ExitCodes2["UNCLEAN"] = 128] = "UNCLEAN";
      return ExitCodes2;
    })(ExitCodes || {});
  }
});
var GitOutputStreams;
var init_git_output_streams = __esm({
  "src/lib/utils/git-output-streams.ts"() {
    GitOutputStreams = class {
      constructor(stdOut, stdErr) {
        this.stdOut = stdOut;
        this.stdErr = stdErr;
      }
      asStrings() {
        return new GitOutputStreams(this.stdOut.toString("utf8"), this.stdErr.toString("utf8"));
      }
    };
  }
});
var LineParser;
var RemoteLineParser;
var init_line_parser = __esm({
  "src/lib/utils/line-parser.ts"() {
    LineParser = class {
      constructor(regExp, useMatches) {
        this.matches = [];
        this.parse = (line, target) => {
          this.resetMatches();
          if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {
            return false;
          }
          return this.useMatches(target, this.prepareMatches()) !== false;
        };
        this._regExp = Array.isArray(regExp) ? regExp : [regExp];
        if (useMatches) {
          this.useMatches = useMatches;
        }
      }
      useMatches(target, match) {
        throw new Error(`LineParser:useMatches not implemented`);
      }
      resetMatches() {
        this.matches.length = 0;
      }
      prepareMatches() {
        return this.matches;
      }
      addMatch(reg, index, line) {
        const matched = line && reg.exec(line);
        if (matched) {
          this.pushMatch(index, matched);
        }
        return !!matched;
      }
      pushMatch(_index, matched) {
        this.matches.push(...matched.slice(1));
      }
    };
    RemoteLineParser = class extends LineParser {
      addMatch(reg, index, line) {
        return /^remote:\s/.test(String(line)) && super.addMatch(reg, index, line);
      }
      pushMatch(index, matched) {
        if (index > 0 || matched.length > 1) {
          super.pushMatch(index, matched);
        }
      }
    };
  }
});
function createInstanceConfig(...options) {
  const baseDir = process.cwd();
  const config = Object.assign(__spreadValues({ baseDir }, defaultOptions), ...options.filter((o) => typeof o === "object" && o));
  config.baseDir = config.baseDir || baseDir;
  config.trimmed = config.trimmed === true;
  return config;
}
var defaultOptions;
var init_simple_git_options = __esm({
  "src/lib/utils/simple-git-options.ts"() {
    defaultOptions = {
      binary: "git",
      maxConcurrentProcesses: 5,
      config: [],
      trimmed: false
    };
  }
});
function appendTaskOptions(options, commands = []) {
  if (!filterPlainObject(options)) {
    return commands;
  }
  return Object.keys(options).reduce((commands2, key) => {
    const value = options[key];
    if (isPathSpec(value)) {
      commands2.push(value);
    } else if (filterPrimitives(value, ["boolean"])) {
      commands2.push(key + "=" + value);
    } else {
      commands2.push(key);
    }
    return commands2;
  }, commands);
}
function getTrailingOptions(args, initialPrimitive = 0, objectOnly = false) {
  const command = [];
  for (let i = 0, max = initialPrimitive < 0 ? args.length : initialPrimitive; i < max; i++) {
    if ("string|number".includes(typeof args[i])) {
      command.push(String(args[i]));
    }
  }
  appendTaskOptions(trailingOptionsArgument(args), command);
  if (!objectOnly) {
    command.push(...trailingArrayArgument(args));
  }
  return command;
}
function trailingArrayArgument(args) {
  const hasTrailingCallback = typeof last(args) === "function";
  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterArray, []);
}
function trailingOptionsArgument(args) {
  const hasTrailingCallback = filterFunction(last(args));
  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterPlainObject);
}
function trailingFunctionArgument(args, includeNoop = true) {
  const callback = asFunction(last(args));
  return includeNoop || isUserFunction(callback) ? callback : void 0;
}
var init_task_options = __esm({
  "src/lib/utils/task-options.ts"() {
    init_argument_filters();
    init_util();
    init_pathspec();
  }
});
function callTaskParser(parser3, streams) {
  return parser3(streams.stdOut, streams.stdErr);
}
function parseStringResponse(result, parsers12, texts, trim = true) {
  asArray(texts).forEach((text) => {
    for (let lines = toLinesWithContent(text, trim), i = 0, max = lines.length; i < max; i++) {
      const line = (offset = 0) => {
        if (i + offset >= max) {
          return;
        }
        return lines[i + offset];
      };
      parsers12.some(({ parse }) => parse(line, result));
    }
  });
  return result;
}
var init_task_parser = __esm({
  "src/lib/utils/task-parser.ts"() {
    init_util();
  }
});
var utils_exports = {};
__export2(utils_exports, {
  ExitCodes: () => ExitCodes,
  GitOutputStreams: () => GitOutputStreams,
  LineParser: () => LineParser,
  NOOP: () => NOOP,
  NULL: () => NULL,
  RemoteLineParser: () => RemoteLineParser,
  append: () => append,
  appendTaskOptions: () => appendTaskOptions,
  asArray: () => asArray,
  asFunction: () => asFunction,
  asNumber: () => asNumber,
  asStringArray: () => asStringArray,
  bufferToString: () => bufferToString,
  callTaskParser: () => callTaskParser,
  createInstanceConfig: () => createInstanceConfig,
  delay: () => delay,
  filterArray: () => filterArray,
  filterFunction: () => filterFunction,
  filterHasLength: () => filterHasLength,
  filterPlainObject: () => filterPlainObject,
  filterPrimitives: () => filterPrimitives,
  filterString: () => filterString,
  filterStringArray: () => filterStringArray,
  filterStringOrStringArray: () => filterStringOrStringArray,
  filterType: () => filterType,
  first: () => first,
  folderExists: () => folderExists,
  forEachLineWithContent: () => forEachLineWithContent,
  getTrailingOptions: () => getTrailingOptions,
  including: () => including,
  isUserFunction: () => isUserFunction,
  last: () => last,
  objectToString: () => objectToString,
  orVoid: () => orVoid,
  parseStringResponse: () => parseStringResponse,
  pick: () => pick,
  prefixedArray: () => prefixedArray,
  remove: () => remove,
  splitOn: () => splitOn,
  toLinesWithContent: () => toLinesWithContent,
  trailingFunctionArgument: () => trailingFunctionArgument,
  trailingOptionsArgument: () => trailingOptionsArgument
});
var init_utils = __esm({
  "src/lib/utils/index.ts"() {
    init_argument_filters();
    init_exit_codes();
    init_git_output_streams();
    init_line_parser();
    init_simple_git_options();
    init_task_options();
    init_task_parser();
    init_util();
  }
});
var check_is_repo_exports = {};
__export2(check_is_repo_exports, {
  CheckRepoActions: () => CheckRepoActions,
  checkIsBareRepoTask: () => checkIsBareRepoTask,
  checkIsRepoRootTask: () => checkIsRepoRootTask,
  checkIsRepoTask: () => checkIsRepoTask
});
function checkIsRepoTask(action) {
  switch (action) {
    case "bare":
      return checkIsBareRepoTask();
    case "root":
      return checkIsRepoRootTask();
  }
  const commands = ["rev-parse", "--is-inside-work-tree"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser
  };
}
function checkIsRepoRootTask() {
  const commands = ["rev-parse", "--git-dir"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser(path) {
      return /^\.(git)?$/.test(path.trim());
    }
  };
}
function checkIsBareRepoTask() {
  const commands = ["rev-parse", "--is-bare-repository"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser
  };
}
function isNotRepoMessage(error) {
  return /(Not a git repository|Kein Git-Repository)/i.test(String(error));
}
var CheckRepoActions;
var onError;
var parser;
var init_check_is_repo = __esm({
  "src/lib/tasks/check-is-repo.ts"() {
    init_utils();
    CheckRepoActions = /* @__PURE__ */ ((CheckRepoActions2) => {
      CheckRepoActions2["BARE"] = "bare";
      CheckRepoActions2["IN_TREE"] = "tree";
      CheckRepoActions2["IS_REPO_ROOT"] = "root";
      return CheckRepoActions2;
    })(CheckRepoActions || {});
    onError = ({ exitCode }, error, done, fail) => {
      if (exitCode === 128 && isNotRepoMessage(error)) {
        return done(Buffer.from("false"));
      }
      fail(error);
    };
    parser = (text) => {
      return text.trim() === "true";
    };
  }
});
function cleanSummaryParser(dryRun, text) {
  const summary = new CleanResponse(dryRun);
  const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;
  toLinesWithContent(text).forEach((line) => {
    const removed = line.replace(regexp, "");
    summary.paths.push(removed);
    (isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);
  });
  return summary;
}
var CleanResponse;
var removalRegexp;
var dryRunRemovalRegexp;
var isFolderRegexp;
var init_CleanSummary = __esm({
  "src/lib/responses/CleanSummary.ts"() {
    init_utils();
    CleanResponse = class {
      constructor(dryRun) {
        this.dryRun = dryRun;
        this.paths = [];
        this.files = [];
        this.folders = [];
      }
    };
    removalRegexp = /^[a-z]+\s*/i;
    dryRunRemovalRegexp = /^[a-z]+\s+[a-z]+\s*/i;
    isFolderRegexp = /\/$/;
  }
});
var task_exports = {};
__export2(task_exports, {
  EMPTY_COMMANDS: () => EMPTY_COMMANDS,
  adhocExecTask: () => adhocExecTask,
  configurationErrorTask: () => configurationErrorTask,
  isBufferTask: () => isBufferTask,
  isEmptyTask: () => isEmptyTask,
  straightThroughBufferTask: () => straightThroughBufferTask,
  straightThroughStringTask: () => straightThroughStringTask
});
function adhocExecTask(parser3) {
  return {
    commands: EMPTY_COMMANDS,
    format: "empty",
    parser: parser3
  };
}
function configurationErrorTask(error) {
  return {
    commands: EMPTY_COMMANDS,
    format: "empty",
    parser() {
      throw typeof error === "string" ? new TaskConfigurationError(error) : error;
    }
  };
}
function straightThroughStringTask(commands, trimmed2 = false) {
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return trimmed2 ? String(text).trim() : text;
    }
  };
}
function straightThroughBufferTask(commands) {
  return {
    commands,
    format: "buffer",
    parser(buffer) {
      return buffer;
    }
  };
}
function isBufferTask(task) {
  return task.format === "buffer";
}
function isEmptyTask(task) {
  return task.format === "empty" || !task.commands.length;
}
var EMPTY_COMMANDS;
var init_task = __esm({
  "src/lib/tasks/task.ts"() {
    init_task_configuration_error();
    EMPTY_COMMANDS = [];
  }
});
var clean_exports = {};
__export2(clean_exports, {
  CONFIG_ERROR_INTERACTIVE_MODE: () => CONFIG_ERROR_INTERACTIVE_MODE,
  CONFIG_ERROR_MODE_REQUIRED: () => CONFIG_ERROR_MODE_REQUIRED,
  CONFIG_ERROR_UNKNOWN_OPTION: () => CONFIG_ERROR_UNKNOWN_OPTION,
  CleanOptions: () => CleanOptions,
  cleanTask: () => cleanTask,
  cleanWithOptionsTask: () => cleanWithOptionsTask,
  isCleanOptionsArray: () => isCleanOptionsArray
});
function cleanWithOptionsTask(mode, customArgs) {
  const { cleanMode, options, valid } = getCleanOptions(mode);
  if (!cleanMode) {
    return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);
  }
  if (!valid.options) {
    return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));
  }
  options.push(...customArgs);
  if (options.some(isInteractiveMode)) {
    return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);
  }
  return cleanTask(cleanMode, options);
}
function cleanTask(mode, customArgs) {
  const commands = ["clean", `-${mode}`, ...customArgs];
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return cleanSummaryParser(mode === "n", text);
    }
  };
}
function isCleanOptionsArray(input) {
  return Array.isArray(input) && input.every((test) => CleanOptionValues.has(test));
}
function getCleanOptions(input) {
  let cleanMode;
  let options = [];
  let valid = { cleanMode: false, options: true };
  input.replace(/[^a-z]i/g, "").split("").forEach((char) => {
    if (isCleanMode(char)) {
      cleanMode = char;
      valid.cleanMode = true;
    } else {
      valid.options = valid.options && isKnownOption(options[options.length] = `-${char}`);
    }
  });
  return {
    cleanMode,
    options,
    valid
  };
}
function isCleanMode(cleanMode) {
  return cleanMode === "f" || cleanMode === "n";
}
function isKnownOption(option) {
  return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt(1));
}
function isInteractiveMode(option) {
  if (/^-[^\-]/.test(option)) {
    return option.indexOf("i") > 0;
  }
  return option === "--interactive";
}
var CONFIG_ERROR_INTERACTIVE_MODE;
var CONFIG_ERROR_MODE_REQUIRED;
var CONFIG_ERROR_UNKNOWN_OPTION;
var CleanOptions;
var CleanOptionValues;
var init_clean = __esm({
  "src/lib/tasks/clean.ts"() {
    init_CleanSummary();
    init_utils();
    init_task();
    CONFIG_ERROR_INTERACTIVE_MODE = "Git clean interactive mode is not supported";
    CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter ("n" or "f") is required';
    CONFIG_ERROR_UNKNOWN_OPTION = "Git clean unknown option found in: ";
    CleanOptions = /* @__PURE__ */ ((CleanOptions22) => {
      CleanOptions22["DRY_RUN"] = "n";
      CleanOptions22["FORCE"] = "f";
      CleanOptions22["IGNORED_INCLUDED"] = "x";
      CleanOptions22["IGNORED_ONLY"] = "X";
      CleanOptions22["EXCLUDING"] = "e";
      CleanOptions22["QUIET"] = "q";
      CleanOptions22["RECURSIVE"] = "d";
      return CleanOptions22;
    })(CleanOptions || {});
    CleanOptionValues = /* @__PURE__ */ new Set([
      "i",
      ...asStringArray(Object.values(CleanOptions))
    ]);
  }
});
function configListParser(text) {
  const config = new ConfigList();
  for (const item of configParser(text)) {
    config.addValue(item.file, String(item.key), item.value);
  }
  return config;
}
function configGetParser(text, key) {
  let value = null;
  const values = [];
  const scopes = /* @__PURE__ */ new Map();
  for (const item of configParser(text, key)) {
    if (item.key !== key) {
      continue;
    }
    values.push(value = item.value);
    if (!scopes.has(item.file)) {
      scopes.set(item.file, []);
    }
    scopes.get(item.file).push(value);
  }
  return {
    key,
    paths: Array.from(scopes.keys()),
    scopes,
    value,
    values
  };
}
function configFilePath(filePath) {
  return filePath.replace(/^(file):/, "");
}
function* configParser(text, requestedKey = null) {
  const lines = text.split("\0");
  for (let i = 0, max = lines.length - 1; i < max; ) {
    const file = configFilePath(lines[i++]);
    let value = lines[i++];
    let key = requestedKey;
    if (value.includes("\n")) {
      const line = splitOn(value, "\n");
      key = line[0];
      value = line[1];
    }
    yield { file, key, value };
  }
}
var ConfigList;
var init_ConfigList = __esm({
  "src/lib/responses/ConfigList.ts"() {
    init_utils();
    ConfigList = class {
      constructor() {
        this.files = [];
        this.values = /* @__PURE__ */ Object.create(null);
      }
      get all() {
        if (!this._all) {
          this._all = this.files.reduce((all, file) => {
            return Object.assign(all, this.values[file]);
          }, {});
        }
        return this._all;
      }
      addFile(file) {
        if (!(file in this.values)) {
          const latest = last(this.files);
          this.values[file] = latest ? Object.create(this.values[latest]) : {};
          this.files.push(file);
        }
        return this.values[file];
      }
      addValue(file, key, value) {
        const values = this.addFile(file);
        if (!values.hasOwnProperty(key)) {
          values[key] = value;
        } else if (Array.isArray(values[key])) {
          values[key].push(value);
        } else {
          values[key] = [values[key], value];
        }
        this._all = void 0;
      }
    };
  }
});
function asConfigScope(scope, fallback) {
  if (typeof scope === "string" && GitConfigScope.hasOwnProperty(scope)) {
    return scope;
  }
  return fallback;
}
function addConfigTask(key, value, append2, scope) {
  const commands = ["config", `--${scope}`];
  if (append2) {
    commands.push("--add");
  }
  commands.push(key, value);
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return text;
    }
  };
}
function getConfigTask(key, scope) {
  const commands = ["config", "--null", "--show-origin", "--get-all", key];
  if (scope) {
    commands.splice(1, 0, `--${scope}`);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return configGetParser(text, key);
    }
  };
}
function listConfigTask(scope) {
  const commands = ["config", "--list", "--show-origin", "--null"];
  if (scope) {
    commands.push(`--${scope}`);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return configListParser(text);
    }
  };
}
function config_default() {
  return {
    addConfig(key, value, ...rest) {
      return this._runTask(addConfigTask(key, value, rest[0] === true, asConfigScope(
        rest[1],
        "local"
        /* local */
      )), trailingFunctionArgument(arguments));
    },
    getConfig(key, scope) {
      return this._runTask(getConfigTask(key, asConfigScope(scope, void 0)), trailingFunctionArgument(arguments));
    },
    listConfig(...rest) {
      return this._runTask(listConfigTask(asConfigScope(rest[0], void 0)), trailingFunctionArgument(arguments));
    }
  };
}
var GitConfigScope;
var init_config = __esm({
  "src/lib/tasks/config.ts"() {
    init_ConfigList();
    init_utils();
    GitConfigScope = /* @__PURE__ */ ((GitConfigScope2) => {
      GitConfigScope2["system"] = "system";
      GitConfigScope2["global"] = "global";
      GitConfigScope2["local"] = "local";
      GitConfigScope2["worktree"] = "worktree";
      return GitConfigScope2;
    })(GitConfigScope || {});
  }
});
function isDiffNameStatus(input) {
  return diffNameStatus.has(input);
}
var DiffNameStatus;
var diffNameStatus;
var init_diff_name_status = __esm({
  "src/lib/tasks/diff-name-status.ts"() {
    DiffNameStatus = /* @__PURE__ */ ((DiffNameStatus2) => {
      DiffNameStatus2["ADDED"] = "A";
      DiffNameStatus2["COPIED"] = "C";
      DiffNameStatus2["DELETED"] = "D";
      DiffNameStatus2["MODIFIED"] = "M";
      DiffNameStatus2["RENAMED"] = "R";
      DiffNameStatus2["CHANGED"] = "T";
      DiffNameStatus2["UNMERGED"] = "U";
      DiffNameStatus2["UNKNOWN"] = "X";
      DiffNameStatus2["BROKEN"] = "B";
      return DiffNameStatus2;
    })(DiffNameStatus || {});
    diffNameStatus = new Set(Object.values(DiffNameStatus));
  }
});
function grepQueryBuilder(...params) {
  return new GrepQuery().param(...params);
}
function parseGrep(grep) {
  const paths = /* @__PURE__ */ new Set();
  const results = {};
  forEachLineWithContent(grep, (input) => {
    const [path, line, preview] = input.split(NULL);
    paths.add(path);
    (results[path] = results[path] || []).push({
      line: asNumber(line),
      path,
      preview
    });
  });
  return {
    paths,
    results
  };
}
function grep_default() {
  return {
    grep(searchTerm) {
      const then = trailingFunctionArgument(arguments);
      const options = getTrailingOptions(arguments);
      for (const option of disallowedOptions) {
        if (options.includes(option)) {
          return this._runTask(configurationErrorTask(`git.grep: use of "${option}" is not supported.`), then);
        }
      }
      if (typeof searchTerm === "string") {
        searchTerm = grepQueryBuilder().param(searchTerm);
      }
      const commands = ["grep", "--null", "-n", "--full-name", ...options, ...searchTerm];
      return this._runTask({
        commands,
        format: "utf-8",
        parser(stdOut) {
          return parseGrep(stdOut);
        }
      }, then);
    }
  };
}
var disallowedOptions;
var Query;
var _a;
var GrepQuery;
var init_grep = __esm({
  "src/lib/tasks/grep.ts"() {
    init_utils();
    init_task();
    disallowedOptions = ["-h"];
    Query = Symbol("grepQuery");
    GrepQuery = class {
      constructor() {
        this[_a] = [];
      }
      *[(_a = Query, Symbol.iterator)]() {
        for (const query of this[Query]) {
          yield query;
        }
      }
      and(...and) {
        and.length && this[Query].push("--and", "(", ...prefixedArray(and, "-e"), ")");
        return this;
      }
      param(...param) {
        this[Query].push(...prefixedArray(param, "-e"));
        return this;
      }
    };
  }
});
var reset_exports = {};
__export2(reset_exports, {
  ResetMode: () => ResetMode,
  getResetMode: () => getResetMode,
  resetTask: () => resetTask
});
function resetTask(mode, customArgs) {
  const commands = ["reset"];
  if (isValidResetMode(mode)) {
    commands.push(`--${mode}`);
  }
  commands.push(...customArgs);
  return straightThroughStringTask(commands);
}
function getResetMode(mode) {
  if (isValidResetMode(mode)) {
    return mode;
  }
  switch (typeof mode) {
    case "string":
    case "undefined":
      return "soft";
  }
  return;
}
function isValidResetMode(mode) {
  return ResetModes.includes(mode);
}
var ResetMode;
var ResetModes;
var init_reset = __esm({
  "src/lib/tasks/reset.ts"() {
    init_task();
    ResetMode = /* @__PURE__ */ ((ResetMode2) => {
      ResetMode2["MIXED"] = "mixed";
      ResetMode2["SOFT"] = "soft";
      ResetMode2["HARD"] = "hard";
      ResetMode2["MERGE"] = "merge";
      ResetMode2["KEEP"] = "keep";
      return ResetMode2;
    })(ResetMode || {});
    ResetModes = Array.from(Object.values(ResetMode));
  }
});
function createLog() {
  return (0, import_debug.default)("simple-git");
}
function prefixedLogger(to, prefix, forward) {
  if (!prefix || !String(prefix).replace(/\s*/, "")) {
    return !forward ? to : (message, ...args) => {
      to(message, ...args);
      forward(message, ...args);
    };
  }
  return (message, ...args) => {
    to(`%s ${message}`, prefix, ...args);
    if (forward) {
      forward(message, ...args);
    }
  };
}
function childLoggerName(name, childDebugger, { namespace: parentNamespace }) {
  if (typeof name === "string") {
    return name;
  }
  const childNamespace = childDebugger && childDebugger.namespace || "";
  if (childNamespace.startsWith(parentNamespace)) {
    return childNamespace.substr(parentNamespace.length + 1);
  }
  return childNamespace || parentNamespace;
}
function createLogger(label, verbose, initialStep, infoDebugger = createLog()) {
  const labelPrefix = label && `[${label}]` || "";
  const spawned = [];
  const debugDebugger = typeof verbose === "string" ? infoDebugger.extend(verbose) : verbose;
  const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);
  return step(initialStep);
  function sibling(name, initial) {
    return append(spawned, createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger));
  }
  function step(phase) {
    const stepPrefix = phase && `[${phase}]` || "";
    const debug2 = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || NOOP;
    const info = prefixedLogger(infoDebugger, `${labelPrefix} ${stepPrefix}`, debug2);
    return Object.assign(debugDebugger ? debug2 : info, {
      label,
      sibling,
      info,
      step
    });
  }
}
var init_git_logger = __esm({
  "src/lib/git-logger.ts"() {
    init_utils();
    import_debug.default.formatters.L = (value) => String(filterHasLength(value) ? value.length : "-");
    import_debug.default.formatters.B = (value) => {
      if (Buffer.isBuffer(value)) {
        return value.toString("utf8");
      }
      return objectToString(value);
    };
  }
});
var _TasksPendingQueue;
var TasksPendingQueue;
var init_tasks_pending_queue = __esm({
  "src/lib/runners/tasks-pending-queue.ts"() {
    init_git_error();
    init_git_logger();
    _TasksPendingQueue = class {
      constructor(logLabel = "GitExecutor") {
        this.logLabel = logLabel;
        this._queue = /* @__PURE__ */ new Map();
      }
      withProgress(task) {
        return this._queue.get(task);
      }
      createProgress(task) {
        const name = _TasksPendingQueue.getName(task.commands[0]);
        const logger = createLogger(this.logLabel, name);
        return {
          task,
          logger,
          name
        };
      }
      push(task) {
        const progress = this.createProgress(task);
        progress.logger("Adding task to the queue, commands = %o", task.commands);
        this._queue.set(task, progress);
        return progress;
      }
      fatal(err) {
        for (const [task, { logger }] of Array.from(this._queue.entries())) {
          if (task === err.task) {
            logger.info(`Failed %o`, err);
            logger(`Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`);
          } else {
            logger.info(`A fatal exception occurred in a previous task, the queue has been purged: %o`, err.message);
          }
          this.complete(task);
        }
        if (this._queue.size !== 0) {
          throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);
        }
      }
      complete(task) {
        const progress = this.withProgress(task);
        if (progress) {
          this._queue.delete(task);
        }
      }
      attempt(task) {
        const progress = this.withProgress(task);
        if (!progress) {
          throw new GitError(void 0, "TasksPendingQueue: attempt called for an unknown task");
        }
        progress.logger("Starting task");
        return progress;
      }
      static getName(name = "empty") {
        return `task:${name}:${++_TasksPendingQueue.counter}`;
      }
    };
    TasksPendingQueue = _TasksPendingQueue;
    TasksPendingQueue.counter = 0;
  }
});
function pluginContext(task, commands) {
  return {
    method: first(task.commands) || "",
    commands
  };
}
function onErrorReceived(target, logger) {
  return (err) => {
    logger(`[ERROR] child process exception %o`, err);
    target.push(Buffer.from(String(err.stack), "ascii"));
  };
}
function onDataReceived(target, name, logger, output) {
  return (buffer) => {
    logger(`%s received %L bytes`, name, buffer);
    output(`%B`, buffer);
    target.push(buffer);
  };
}
var GitExecutorChain;
var init_git_executor_chain = __esm({
  "src/lib/runners/git-executor-chain.ts"() {
    init_git_error();
    init_task();
    init_utils();
    init_tasks_pending_queue();
    GitExecutorChain = class {
      constructor(_executor, _scheduler, _plugins) {
        this._executor = _executor;
        this._scheduler = _scheduler;
        this._plugins = _plugins;
        this._chain = Promise.resolve();
        this._queue = new TasksPendingQueue();
      }
      get binary() {
        return this._executor.binary;
      }
      get cwd() {
        return this._cwd || this._executor.cwd;
      }
      set cwd(cwd) {
        this._cwd = cwd;
      }
      get env() {
        return this._executor.env;
      }
      get outputHandler() {
        return this._executor.outputHandler;
      }
      chain() {
        return this;
      }
      push(task) {
        this._queue.push(task);
        return this._chain = this._chain.then(() => this.attemptTask(task));
      }
      attemptTask(task) {
        return __async(this, null, function* () {
          const onScheduleComplete = yield this._scheduler.next();
          const onQueueComplete = () => this._queue.complete(task);
          try {
            const { logger } = this._queue.attempt(task);
            return yield isEmptyTask(task) ? this.attemptEmptyTask(task, logger) : this.attemptRemoteTask(task, logger);
          } catch (e) {
            throw this.onFatalException(task, e);
          } finally {
            onQueueComplete();
            onScheduleComplete();
          }
        });
      }
      onFatalException(task, e) {
        const gitError = e instanceof GitError ? Object.assign(e, { task }) : new GitError(task, e && String(e));
        this._chain = Promise.resolve();
        this._queue.fatal(gitError);
        return gitError;
      }
      attemptRemoteTask(task, logger) {
        return __async(this, null, function* () {
          const args = this._plugins.exec("spawn.args", [...task.commands], pluginContext(task, task.commands));
          const raw = yield this.gitResponse(task, this.binary, args, this.outputHandler, logger.step("SPAWN"));
          const outputStreams = yield this.handleTaskData(task, args, raw, logger.step("HANDLE"));
          logger(`passing response to task's parser as a %s`, task.format);
          if (isBufferTask(task)) {
            return callTaskParser(task.parser, outputStreams);
          }
          return callTaskParser(task.parser, outputStreams.asStrings());
        });
      }
      attemptEmptyTask(task, logger) {
        return __async(this, null, function* () {
          logger(`empty task bypassing child process to call to task's parser`);
          return task.parser(this);
        });
      }
      handleTaskData(task, args, result, logger) {
        const { exitCode, rejection, stdOut, stdErr } = result;
        return new Promise((done, fail) => {
          logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);
          const { error } = this._plugins.exec("task.error", { error: rejection }, __spreadValues(__spreadValues({}, pluginContext(task, args)), result));
          if (error && task.onError) {
            logger.info(`exitCode=%s handling with custom error handler`);
            return task.onError(result, error, (newStdOut) => {
              logger.info(`custom error handler treated as success`);
              logger(`custom error returned a %s`, objectToString(newStdOut));
              done(new GitOutputStreams(Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut, Buffer.concat(stdErr)));
            }, fail);
          }
          if (error) {
            logger.info(`handling as error: exitCode=%s stdErr=%s rejection=%o`, exitCode, stdErr.length, rejection);
            return fail(error);
          }
          logger.info(`retrieving task output complete`);
          done(new GitOutputStreams(Buffer.concat(stdOut), Buffer.concat(stdErr)));
        });
      }
      gitResponse(task, command, args, outputHandler, logger) {
        return __async(this, null, function* () {
          const outputLogger = logger.sibling("output");
          const spawnOptions = this._plugins.exec("spawn.options", {
            cwd: this.cwd,
            env: this.env,
            windowsHide: true
          }, pluginContext(task, task.commands));
          return new Promise((done) => {
            const stdOut = [];
            const stdErr = [];
            logger.info(`%s %o`, command, args);
            logger("%O", spawnOptions);
            let rejection = this._beforeSpawn(task, args);
            if (rejection) {
              return done({
                stdOut,
                stdErr,
                exitCode: 9901,
                rejection
              });
            }
            this._plugins.exec("spawn.before", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {
              kill(reason) {
                rejection = reason || rejection;
              }
            }));
            const spawned = (0, import_child_process.spawn)(command, args, spawnOptions);
            spawned.stdout.on("data", onDataReceived(stdOut, "stdOut", logger, outputLogger.step("stdOut")));
            spawned.stderr.on("data", onDataReceived(stdErr, "stdErr", logger, outputLogger.step("stdErr")));
            spawned.on("error", onErrorReceived(stdErr, logger));
            if (outputHandler) {
              logger(`Passing child process stdOut/stdErr to custom outputHandler`);
              outputHandler(command, spawned.stdout, spawned.stderr, [...args]);
            }
            this._plugins.exec("spawn.after", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {
              spawned,
              close(exitCode, reason) {
                done({
                  stdOut,
                  stdErr,
                  exitCode,
                  rejection: rejection || reason
                });
              },
              kill(reason) {
                if (spawned.killed) {
                  return;
                }
                rejection = reason;
                spawned.kill("SIGINT");
              }
            }));
          });
        });
      }
      _beforeSpawn(task, args) {
        let rejection;
        this._plugins.exec("spawn.before", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {
          kill(reason) {
            rejection = reason || rejection;
          }
        }));
        return rejection;
      }
    };
  }
});
var git_executor_exports = {};
__export2(git_executor_exports, {
  GitExecutor: () => GitExecutor
});
var GitExecutor;
var init_git_executor = __esm({
  "src/lib/runners/git-executor.ts"() {
    init_git_executor_chain();
    GitExecutor = class {
      constructor(binary = "git", cwd, _scheduler, _plugins) {
        this.binary = binary;
        this.cwd = cwd;
        this._scheduler = _scheduler;
        this._plugins = _plugins;
        this._chain = new GitExecutorChain(this, this._scheduler, this._plugins);
      }
      chain() {
        return new GitExecutorChain(this, this._scheduler, this._plugins);
      }
      push(task) {
        return this._chain.push(task);
      }
    };
  }
});
function taskCallback(task, response, callback = NOOP) {
  const onSuccess = (data) => {
    callback(null, data);
  };
  const onError2 = (err) => {
    if ((err == null ? void 0 : err.task) === task) {
      callback(err instanceof GitResponseError ? addDeprecationNoticeToError(err) : err, void 0);
    }
  };
  response.then(onSuccess, onError2);
}
function addDeprecationNoticeToError(err) {
  let log = (name) => {
    console.warn(`simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`);
    log = NOOP;
  };
  return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));
  function descriptorReducer(all, name) {
    if (name in err) {
      return all;
    }
    all[name] = {
      enumerable: false,
      configurable: false,
      get() {
        log(name);
        return err.git[name];
      }
    };
    return all;
  }
}
var init_task_callback = __esm({
  "src/lib/task-callback.ts"() {
    init_git_response_error();
    init_utils();
  }
});
function changeWorkingDirectoryTask(directory, root) {
  return adhocExecTask((instance) => {
    if (!folderExists(directory)) {
      throw new Error(`Git.cwd: cannot change to non-directory "${directory}"`);
    }
    return (root || instance).cwd = directory;
  });
}
var init_change_working_directory = __esm({
  "src/lib/tasks/change-working-directory.ts"() {
    init_utils();
    init_task();
  }
});
function checkoutTask(args) {
  const commands = ["checkout", ...args];
  if (commands[1] === "-b" && commands.includes("-B")) {
    commands[1] = remove(commands, "-B");
  }
  return straightThroughStringTask(commands);
}
function checkout_default() {
  return {
    checkout() {
      return this._runTask(checkoutTask(getTrailingOptions(arguments, 1)), trailingFunctionArgument(arguments));
    },
    checkoutBranch(branchName, startPoint) {
      return this._runTask(checkoutTask(["-b", branchName, startPoint, ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments));
    },
    checkoutLocalBranch(branchName) {
      return this._runTask(checkoutTask(["-b", branchName, ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments));
    }
  };
}
var init_checkout = __esm({
  "src/lib/tasks/checkout.ts"() {
    init_utils();
    init_task();
  }
});
function parseCommitResult(stdOut) {
  const result = {
    author: null,
    branch: "",
    commit: "",
    root: false,
    summary: {
      changes: 0,
      insertions: 0,
      deletions: 0
    }
  };
  return parseStringResponse(result, parsers, stdOut);
}
var parsers;
var init_parse_commit = __esm({
  "src/lib/parsers/parse-commit.ts"() {
    init_utils();
    parsers = [
      new LineParser(/^\[([^\s]+)( \([^)]+\))? ([^\]]+)/, (result, [branch, root, commit]) => {
        result.branch = branch;
        result.commit = commit;
        result.root = !!root;
      }),
      new LineParser(/\s*Author:\s(.+)/i, (result, [author]) => {
        const parts = author.split("<");
        const email = parts.pop();
        if (!email || !email.includes("@")) {
          return;
        }
        result.author = {
          email: email.substr(0, email.length - 1),
          name: parts.join("<").trim()
        };
      }),
      new LineParser(/(\d+)[^,]*(?:,\s*(\d+)[^,]*)(?:,\s*(\d+))/g, (result, [changes, insertions, deletions]) => {
        result.summary.changes = parseInt(changes, 10) || 0;
        result.summary.insertions = parseInt(insertions, 10) || 0;
        result.summary.deletions = parseInt(deletions, 10) || 0;
      }),
      new LineParser(/^(\d+)[^,]*(?:,\s*(\d+)[^(]+\(([+-]))?/, (result, [changes, lines, direction]) => {
        result.summary.changes = parseInt(changes, 10) || 0;
        const count = parseInt(lines, 10) || 0;
        if (direction === "-") {
          result.summary.deletions = count;
        } else if (direction === "+") {
          result.summary.insertions = count;
        }
      })
    ];
  }
});
function commitTask(message, files, customArgs) {
  const commands = [
    "-c",
    "core.abbrev=40",
    "commit",
    ...prefixedArray(message, "-m"),
    ...files,
    ...customArgs
  ];
  return {
    commands,
    format: "utf-8",
    parser: parseCommitResult
  };
}
function commit_default() {
  return {
    commit(message, ...rest) {
      const next = trailingFunctionArgument(arguments);
      const task = rejectDeprecatedSignatures(message) || commitTask(asArray(message), asArray(filterType(rest[0], filterStringOrStringArray, [])), [...filterType(rest[1], filterArray, []), ...getTrailingOptions(arguments, 0, true)]);
      return this._runTask(task, next);
    }
  };
  function rejectDeprecatedSignatures(message) {
    return !filterStringOrStringArray(message) && configurationErrorTask(`git.commit: requires the commit message to be supplied as a string/string[]`);
  }
}
var init_commit = __esm({
  "src/lib/tasks/commit.ts"() {
    init_parse_commit();
    init_utils();
    init_task();
  }
});
function first_commit_default() {
  return {
    firstCommit() {
      return this._runTask(straightThroughStringTask(["rev-list", "--max-parents=0", "HEAD"], true), trailingFunctionArgument(arguments));
    }
  };
}
var init_first_commit = __esm({
  "src/lib/tasks/first-commit.ts"() {
    init_utils();
    init_task();
  }
});
function hashObjectTask(filePath, write) {
  const commands = ["hash-object", filePath];
  if (write) {
    commands.push("-w");
  }
  return straightThroughStringTask(commands, true);
}
var init_hash_object = __esm({
  "src/lib/tasks/hash-object.ts"() {
    init_task();
  }
});
function parseInit(bare, path, text) {
  const response = String(text).trim();
  let result;
  if (result = initResponseRegex.exec(response)) {
    return new InitSummary(bare, path, false, result[1]);
  }
  if (result = reInitResponseRegex.exec(response)) {
    return new InitSummary(bare, path, true, result[1]);
  }
  let gitDir = "";
  const tokens = response.split(" ");
  while (tokens.length) {
    const token = tokens.shift();
    if (token === "in") {
      gitDir = tokens.join(" ");
      break;
    }
  }
  return new InitSummary(bare, path, /^re/i.test(response), gitDir);
}
var InitSummary;
var initResponseRegex;
var reInitResponseRegex;
var init_InitSummary = __esm({
  "src/lib/responses/InitSummary.ts"() {
    InitSummary = class {
      constructor(bare, path, existing, gitDir) {
        this.bare = bare;
        this.path = path;
        this.existing = existing;
        this.gitDir = gitDir;
      }
    };
    initResponseRegex = /^Init.+ repository in (.+)$/;
    reInitResponseRegex = /^Rein.+ in (.+)$/;
  }
});
function hasBareCommand(command) {
  return command.includes(bareCommand);
}
function initTask(bare = false, path, customArgs) {
  const commands = ["init", ...customArgs];
  if (bare && !hasBareCommand(commands)) {
    commands.splice(1, 0, bareCommand);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return parseInit(commands.includes("--bare"), path, text);
    }
  };
}
var bareCommand;
var init_init = __esm({
  "src/lib/tasks/init.ts"() {
    init_InitSummary();
    bareCommand = "--bare";
  }
});
function logFormatFromCommand(customArgs) {
  for (let i = 0; i < customArgs.length; i++) {
    const format = logFormatRegex.exec(customArgs[i]);
    if (format) {
      return `--${format[1]}`;
    }
  }
  return "";
}
function isLogFormat(customArg) {
  return logFormatRegex.test(customArg);
}
var logFormatRegex;
var init_log_format = __esm({
  "src/lib/args/log-format.ts"() {
    logFormatRegex = /^--(stat|numstat|name-only|name-status)(=|$)/;
  }
});
var DiffSummary;
var init_DiffSummary = __esm({
  "src/lib/responses/DiffSummary.ts"() {
    DiffSummary = class {
      constructor() {
        this.changed = 0;
        this.deletions = 0;
        this.insertions = 0;
        this.files = [];
      }
    };
  }
});
function getDiffParser(format = "") {
  const parser3 = diffSummaryParsers[format];
  return (stdOut) => parseStringResponse(new DiffSummary(), parser3, stdOut, false);
}
var statParser;
var numStatParser;
var nameOnlyParser;
var nameStatusParser;
var diffSummaryParsers;
var init_parse_diff_summary = __esm({
  "src/lib/parsers/parse-diff-summary.ts"() {
    init_log_format();
    init_DiffSummary();
    init_diff_name_status();
    init_utils();
    statParser = [
      new LineParser(/(.+)\s+\|\s+(\d+)(\s+[+\-]+)?$/, (result, [file, changes, alterations = ""]) => {
        result.files.push({
          file: file.trim(),
          changes: asNumber(changes),
          insertions: alterations.replace(/[^+]/g, "").length,
          deletions: alterations.replace(/[^-]/g, "").length,
          binary: false
        });
      }),
      new LineParser(/(.+) \|\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/, (result, [file, before, after]) => {
        result.files.push({
          file: file.trim(),
          before: asNumber(before),
          after: asNumber(after),
          binary: true
        });
      }),
      new LineParser(/(\d+) files? changed\s*((?:, \d+ [^,]+){0,2})/, (result, [changed, summary]) => {
        const inserted = /(\d+) i/.exec(summary);
        const deleted = /(\d+) d/.exec(summary);
        result.changed = asNumber(changed);
        result.insertions = asNumber(inserted == null ? void 0 : inserted[1]);
        result.deletions = asNumber(deleted == null ? void 0 : deleted[1]);
      })
    ];
    numStatParser = [
      new LineParser(/(\d+)\t(\d+)\t(.+)$/, (result, [changesInsert, changesDelete, file]) => {
        const insertions = asNumber(changesInsert);
        const deletions = asNumber(changesDelete);
        result.changed++;
        result.insertions += insertions;
        result.deletions += deletions;
        result.files.push({
          file,
          changes: insertions + deletions,
          insertions,
          deletions,
          binary: false
        });
      }),
      new LineParser(/-\t-\t(.+)$/, (result, [file]) => {
        result.changed++;
        result.files.push({
          file,
          after: 0,
          before: 0,
          binary: true
        });
      })
    ];
    nameOnlyParser = [
      new LineParser(/(.+)$/, (result, [file]) => {
        result.changed++;
        result.files.push({
          file,
          changes: 0,
          insertions: 0,
          deletions: 0,
          binary: false
        });
      })
    ];
    nameStatusParser = [
      new LineParser(/([ACDMRTUXB])([0-9]{0,3})\t(.[^\t]*)(\t(.[^\t]*))?$/, (result, [status, _similarity, from, _to, to]) => {
        result.changed++;
        result.files.push({
          file: to != null ? to : from,
          changes: 0,
          status: orVoid(isDiffNameStatus(status) && status),
          insertions: 0,
          deletions: 0,
          binary: false
        });
      })
    ];
    diffSummaryParsers = {
      [
        ""
        /* NONE */
      ]: statParser,
      [
        "--stat"
        /* STAT */
      ]: statParser,
      [
        "--numstat"
        /* NUM_STAT */
      ]: numStatParser,
      [
        "--name-status"
        /* NAME_STATUS */
      ]: nameStatusParser,
      [
        "--name-only"
        /* NAME_ONLY */
      ]: nameOnlyParser
    };
  }
});
function lineBuilder(tokens, fields) {
  return fields.reduce((line, field, index) => {
    line[field] = tokens[index] || "";
    return line;
  }, /* @__PURE__ */ Object.create({ diff: null }));
}
function createListLogSummaryParser(splitter = SPLITTER, fields = defaultFieldNames, logFormat = "") {
  const parseDiffResult = getDiffParser(logFormat);
  return function(stdOut) {
    const all = toLinesWithContent(stdOut, true, START_BOUNDARY).map(function(item) {
      const lineDetail = item.trim().split(COMMIT_BOUNDARY);
      const listLogLine = lineBuilder(lineDetail[0].trim().split(splitter), fields);
      if (lineDetail.length > 1 && !!lineDetail[1].trim()) {
        listLogLine.diff = parseDiffResult(lineDetail[1]);
      }
      return listLogLine;
    });
    return {
      all,
      latest: all.length && all[0] || null,
      total: all.length
    };
  };
}
var START_BOUNDARY;
var COMMIT_BOUNDARY;
var SPLITTER;
var defaultFieldNames;
var init_parse_list_log_summary = __esm({
  "src/lib/parsers/parse-list-log-summary.ts"() {
    init_utils();
    init_parse_diff_summary();
    init_log_format();
    START_BOUNDARY = "\xF2\xF2\xF2\xF2\xF2\xF2 ";
    COMMIT_BOUNDARY = " \xF2\xF2";
    SPLITTER = " \xF2 ";
    defaultFieldNames = ["hash", "date", "message", "refs", "author_name", "author_email"];
  }
});
var diff_exports = {};
__export2(diff_exports, {
  diffSummaryTask: () => diffSummaryTask,
  validateLogFormatConfig: () => validateLogFormatConfig
});
function diffSummaryTask(customArgs) {
  let logFormat = logFormatFromCommand(customArgs);
  const commands = ["diff"];
  if (logFormat === "") {
    logFormat = "--stat";
    commands.push("--stat=4096");
  }
  commands.push(...customArgs);
  return validateLogFormatConfig(commands) || {
    commands,
    format: "utf-8",
    parser: getDiffParser(logFormat)
  };
}
function validateLogFormatConfig(customArgs) {
  const flags = customArgs.filter(isLogFormat);
  if (flags.length > 1) {
    return configurationErrorTask(`Summary flags are mutually exclusive - pick one of ${flags.join(",")}`);
  }
  if (flags.length && customArgs.includes("-z")) {
    return configurationErrorTask(`Summary flag ${flags} parsing is not compatible with null termination option '-z'`);
  }
}
var init_diff = __esm({
  "src/lib/tasks/diff.ts"() {
    init_log_format();
    init_parse_diff_summary();
    init_task();
  }
});
function prettyFormat(format, splitter) {
  const fields = [];
  const formatStr = [];
  Object.keys(format).forEach((field) => {
    fields.push(field);
    formatStr.push(String(format[field]));
  });
  return [fields, formatStr.join(splitter)];
}
function userOptions(input) {
  return Object.keys(input).reduce((out, key) => {
    if (!(key in excludeOptions)) {
      out[key] = input[key];
    }
    return out;
  }, {});
}
function parseLogOptions(opt = {}, customArgs = []) {
  const splitter = filterType(opt.splitter, filterString, SPLITTER);
  const format = !filterPrimitives(opt.format) && opt.format ? opt.format : {
    hash: "%H",
    date: opt.strictDate === false ? "%ai" : "%aI",
    message: "%s",
    refs: "%D",
    body: opt.multiLine ? "%B" : "%b",
    author_name: opt.mailMap !== false ? "%aN" : "%an",
    author_email: opt.mailMap !== false ? "%aE" : "%ae"
  };
  const [fields, formatStr] = prettyFormat(format, splitter);
  const suffix = [];
  const command = [
    `--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`,
    ...customArgs
  ];
  const maxCount = opt.n || opt["max-count"] || opt.maxCount;
  if (maxCount) {
    command.push(`--max-count=${maxCount}`);
  }
  if (opt.from || opt.to) {
    const rangeOperator = opt.symmetric !== false ? "..." : "..";
    suffix.push(`${opt.from || ""}${rangeOperator}${opt.to || ""}`);
  }
  if (filterString(opt.file)) {
    command.push("--follow", pathspec(opt.file));
  }
  appendTaskOptions(userOptions(opt), command);
  return {
    fields,
    splitter,
    commands: [...command, ...suffix]
  };
}
function logTask(splitter, fields, customArgs) {
  const parser3 = createListLogSummaryParser(splitter, fields, logFormatFromCommand(customArgs));
  return {
    commands: ["log", ...customArgs],
    format: "utf-8",
    parser: parser3
  };
}
function log_default() {
  return {
    log(...rest) {
      const next = trailingFunctionArgument(arguments);
      const options = parseLogOptions(trailingOptionsArgument(arguments), filterType(arguments[0], filterArray));
      const task = rejectDeprecatedSignatures(...rest) || validateLogFormatConfig(options.commands) || createLogTask(options);
      return this._runTask(task, next);
    }
  };
  function createLogTask(options) {
    return logTask(options.splitter, options.fields, options.commands);
  }
  function rejectDeprecatedSignatures(from, to) {
    return filterString(from) && filterString(to) && configurationErrorTask(`git.log(string, string) should be replaced with git.log({ from: string, to: string })`);
  }
}
var excludeOptions;
var init_log = __esm({
  "src/lib/tasks/log.ts"() {
    init_log_format();
    init_pathspec();
    init_parse_list_log_summary();
    init_utils();
    init_task();
    init_diff();
    excludeOptions = /* @__PURE__ */ ((excludeOptions2) => {
      excludeOptions2[excludeOptions2["--pretty"] = 0] = "--pretty";
      excludeOptions2[excludeOptions2["max-count"] = 1] = "max-count";
      excludeOptions2[excludeOptions2["maxCount"] = 2] = "maxCount";
      excludeOptions2[excludeOptions2["n"] = 3] = "n";
      excludeOptions2[excludeOptions2["file"] = 4] = "file";
      excludeOptions2[excludeOptions2["format"] = 5] = "format";
      excludeOptions2[excludeOptions2["from"] = 6] = "from";
      excludeOptions2[excludeOptions2["to"] = 7] = "to";
      excludeOptions2[excludeOptions2["splitter"] = 8] = "splitter";
      excludeOptions2[excludeOptions2["symmetric"] = 9] = "symmetric";
      excludeOptions2[excludeOptions2["mailMap"] = 10] = "mailMap";
      excludeOptions2[excludeOptions2["multiLine"] = 11] = "multiLine";
      excludeOptions2[excludeOptions2["strictDate"] = 12] = "strictDate";
      return excludeOptions2;
    })(excludeOptions || {});
  }
});
var MergeSummaryConflict;
var MergeSummaryDetail;
var init_MergeSummary = __esm({
  "src/lib/responses/MergeSummary.ts"() {
    MergeSummaryConflict = class {
      constructor(reason, file = null, meta) {
        this.reason = reason;
        this.file = file;
        this.meta = meta;
      }
      toString() {
        return `${this.file}:${this.reason}`;
      }
    };
    MergeSummaryDetail = class {
      constructor() {
        this.conflicts = [];
        this.merges = [];
        this.result = "success";
      }
      get failed() {
        return this.conflicts.length > 0;
      }
      get reason() {
        return this.result;
      }
      toString() {
        if (this.conflicts.length) {
          return `CONFLICTS: ${this.conflicts.join(", ")}`;
        }
        return "OK";
      }
    };
  }
});
var PullSummary;
var PullFailedSummary;
var init_PullSummary = __esm({
  "src/lib/responses/PullSummary.ts"() {
    PullSummary = class {
      constructor() {
        this.remoteMessages = {
          all: []
        };
        this.created = [];
        this.deleted = [];
        this.files = [];
        this.deletions = {};
        this.insertions = {};
        this.summary = {
          changes: 0,
          deletions: 0,
          insertions: 0
        };
      }
    };
    PullFailedSummary = class {
      constructor() {
        this.remote = "";
        this.hash = {
          local: "",
          remote: ""
        };
        this.branch = {
          local: "",
          remote: ""
        };
        this.message = "";
      }
      toString() {
        return this.message;
      }
    };
  }
});
function objectEnumerationResult(remoteMessages) {
  return remoteMessages.objects = remoteMessages.objects || {
    compressing: 0,
    counting: 0,
    enumerating: 0,
    packReused: 0,
    reused: { count: 0, delta: 0 },
    total: { count: 0, delta: 0 }
  };
}
function asObjectCount(source) {
  const count = /^\s*(\d+)/.exec(source);
  const delta = /delta (\d+)/i.exec(source);
  return {
    count: asNumber(count && count[1] || "0"),
    delta: asNumber(delta && delta[1] || "0")
  };
}
var remoteMessagesObjectParsers;
var init_parse_remote_objects = __esm({
  "src/lib/parsers/parse-remote-objects.ts"() {
    init_utils();
    remoteMessagesObjectParsers = [
      new RemoteLineParser(/^remote:\s*(enumerating|counting|compressing) objects: (\d+),/i, (result, [action, count]) => {
        const key = action.toLowerCase();
        const enumeration = objectEnumerationResult(result.remoteMessages);
        Object.assign(enumeration, { [key]: asNumber(count) });
      }),
      new RemoteLineParser(/^remote:\s*(enumerating|counting|compressing) objects: \d+% \(\d+\/(\d+)\),/i, (result, [action, count]) => {
        const key = action.toLowerCase();
        const enumeration = objectEnumerationResult(result.remoteMessages);
        Object.assign(enumeration, { [key]: asNumber(count) });
      }),
      new RemoteLineParser(/total ([^,]+), reused ([^,]+), pack-reused (\d+)/i, (result, [total, reused, packReused]) => {
        const objects = objectEnumerationResult(result.remoteMessages);
        objects.total = asObjectCount(total);
        objects.reused = asObjectCount(reused);
        objects.packReused = asNumber(packReused);
      })
    ];
  }
});
function parseRemoteMessages(_stdOut, stdErr) {
  return parseStringResponse({ remoteMessages: new RemoteMessageSummary() }, parsers2, stdErr);
}
var parsers2;
var RemoteMessageSummary;
var init_parse_remote_messages = __esm({
  "src/lib/parsers/parse-remote-messages.ts"() {
    init_utils();
    init_parse_remote_objects();
    parsers2 = [
      new RemoteLineParser(/^remote:\s*(.+)$/, (result, [text]) => {
        result.remoteMessages.all.push(text.trim());
        return false;
      }),
      ...remoteMessagesObjectParsers,
      new RemoteLineParser([/create a (?:pull|merge) request/i, /\s(https?:\/\/\S+)$/], (result, [pullRequestUrl]) => {
        result.remoteMessages.pullRequestUrl = pullRequestUrl;
      }),
      new RemoteLineParser([/found (\d+) vulnerabilities.+\(([^)]+)\)/i, /\s(https?:\/\/\S+)$/], (result, [count, summary, url]) => {
        result.remoteMessages.vulnerabilities = {
          count: asNumber(count),
          summary,
          url
        };
      })
    ];
    RemoteMessageSummary = class {
      constructor() {
        this.all = [];
      }
    };
  }
});
function parsePullErrorResult(stdOut, stdErr) {
  const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, [stdOut, stdErr]);
  return pullError.message && pullError;
}
var FILE_UPDATE_REGEX;
var SUMMARY_REGEX;
var ACTION_REGEX;
var parsers3;
var errorParsers;
var parsePullDetail;
var parsePullResult;
var init_parse_pull = __esm({
  "src/lib/parsers/parse-pull.ts"() {
    init_PullSummary();
    init_utils();
    init_parse_remote_messages();
    FILE_UPDATE_REGEX = /^\s*(.+?)\s+\|\s+\d+\s*(\+*)(-*)/;
    SUMMARY_REGEX = /(\d+)\D+((\d+)\D+\(\+\))?(\D+(\d+)\D+\(-\))?/;
    ACTION_REGEX = /^(create|delete) mode \d+ (.+)/;
    parsers3 = [
      new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {
        result.files.push(file);
        if (insertions) {
          result.insertions[file] = insertions.length;
        }
        if (deletions) {
          result.deletions[file] = deletions.length;
        }
      }),
      new LineParser(SUMMARY_REGEX, (result, [changes, , insertions, , deletions]) => {
        if (insertions !== void 0 || deletions !== void 0) {
          result.summary.changes = +changes || 0;
          result.summary.insertions = +insertions || 0;
          result.summary.deletions = +deletions || 0;
          return true;
        }
        return false;
      }),
      new LineParser(ACTION_REGEX, (result, [action, file]) => {
        append(result.files, file);
        append(action === "create" ? result.created : result.deleted, file);
      })
    ];
    errorParsers = [
      new LineParser(/^from\s(.+)$/i, (result, [remote]) => void (result.remote = remote)),
      new LineParser(/^fatal:\s(.+)$/, (result, [message]) => void (result.message = message)),
      new LineParser(/([a-z0-9]+)\.\.([a-z0-9]+)\s+(\S+)\s+->\s+(\S+)$/, (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {
        result.branch.local = branchLocal;
        result.hash.local = hashLocal;
        result.branch.remote = branchRemote;
        result.hash.remote = hashRemote;
      })
    ];
    parsePullDetail = (stdOut, stdErr) => {
      return parseStringResponse(new PullSummary(), parsers3, [stdOut, stdErr]);
    };
    parsePullResult = (stdOut, stdErr) => {
      return Object.assign(new PullSummary(), parsePullDetail(stdOut, stdErr), parseRemoteMessages(stdOut, stdErr));
    };
  }
});
var parsers4;
var parseMergeResult;
var parseMergeDetail;
var init_parse_merge = __esm({
  "src/lib/parsers/parse-merge.ts"() {
    init_MergeSummary();
    init_utils();
    init_parse_pull();
    parsers4 = [
      new LineParser(/^Auto-merging\s+(.+)$/, (summary, [autoMerge]) => {
        summary.merges.push(autoMerge);
      }),
      new LineParser(/^CONFLICT\s+\((.+)\): Merge conflict in (.+)$/, (summary, [reason, file]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, file));
      }),
      new LineParser(/^CONFLICT\s+\((.+\/delete)\): (.+) deleted in (.+) and/, (summary, [reason, file, deleteRef]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, file, { deleteRef }));
      }),
      new LineParser(/^CONFLICT\s+\((.+)\):/, (summary, [reason]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, null));
      }),
      new LineParser(/^Automatic merge failed;\s+(.+)$/, (summary, [result]) => {
        summary.result = result;
      })
    ];
    parseMergeResult = (stdOut, stdErr) => {
      return Object.assign(parseMergeDetail(stdOut, stdErr), parsePullResult(stdOut, stdErr));
    };
    parseMergeDetail = (stdOut) => {
      return parseStringResponse(new MergeSummaryDetail(), parsers4, stdOut);
    };
  }
});
function mergeTask(customArgs) {
  if (!customArgs.length) {
    return configurationErrorTask("Git.merge requires at least one option");
  }
  return {
    commands: ["merge", ...customArgs],
    format: "utf-8",
    parser(stdOut, stdErr) {
      const merge = parseMergeResult(stdOut, stdErr);
      if (merge.failed) {
        throw new GitResponseError(merge);
      }
      return merge;
    }
  };
}
var init_merge = __esm({
  "src/lib/tasks/merge.ts"() {
    init_git_response_error();
    init_parse_merge();
    init_task();
  }
});
function pushResultPushedItem(local, remote, status) {
  const deleted = status.includes("deleted");
  const tag = status.includes("tag") || /^refs\/tags/.test(local);
  const alreadyUpdated = !status.includes("new");
  return {
    deleted,
    tag,
    branch: !tag,
    new: !alreadyUpdated,
    alreadyUpdated,
    local,
    remote
  };
}
var parsers5;
var parsePushResult;
var parsePushDetail;
var init_parse_push = __esm({
  "src/lib/parsers/parse-push.ts"() {
    init_utils();
    init_parse_remote_messages();
    parsers5 = [
      new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {
        result.repo = repo;
      }),
      new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {
        result.ref = __spreadProps(__spreadValues({}, result.ref || {}), {
          local
        });
      }),
      new LineParser(/^[=*-]\s+([^:]+):(\S+)\s+\[(.+)]$/, (result, [local, remote, type]) => {
        result.pushed.push(pushResultPushedItem(local, remote, type));
      }),
      new LineParser(/^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/, (result, [local, remote, remoteName]) => {
        result.branch = __spreadProps(__spreadValues({}, result.branch || {}), {
          local,
          remote,
          remoteName
        });
      }),
      new LineParser(/^([^:]+):(\S+)\s+([a-z0-9]+)\.\.([a-z0-9]+)$/, (result, [local, remote, from, to]) => {
        result.update = {
          head: {
            local,
            remote
          },
          hash: {
            from,
            to
          }
        };
      })
    ];
    parsePushResult = (stdOut, stdErr) => {
      const pushDetail = parsePushDetail(stdOut, stdErr);
      const responseDetail = parseRemoteMessages(stdOut, stdErr);
      return __spreadValues(__spreadValues({}, pushDetail), responseDetail);
    };
    parsePushDetail = (stdOut, stdErr) => {
      return parseStringResponse({ pushed: [] }, parsers5, [stdOut, stdErr]);
    };
  }
});
var push_exports = {};
__export2(push_exports, {
  pushTagsTask: () => pushTagsTask,
  pushTask: () => pushTask
});
function pushTagsTask(ref = {}, customArgs) {
  append(customArgs, "--tags");
  return pushTask(ref, customArgs);
}
function pushTask(ref = {}, customArgs) {
  const commands = ["push", ...customArgs];
  if (ref.branch) {
    commands.splice(1, 0, ref.branch);
  }
  if (ref.remote) {
    commands.splice(1, 0, ref.remote);
  }
  remove(commands, "-v");
  append(commands, "--verbose");
  append(commands, "--porcelain");
  return {
    commands,
    format: "utf-8",
    parser: parsePushResult
  };
}
var init_push = __esm({
  "src/lib/tasks/push.ts"() {
    init_parse_push();
    init_utils();
  }
});
function show_default() {
  return {
    showBuffer() {
      const commands = ["show", ...getTrailingOptions(arguments, 1)];
      if (!commands.includes("--binary")) {
        commands.splice(1, 0, "--binary");
      }
      return this._runTask(straightThroughBufferTask(commands), trailingFunctionArgument(arguments));
    },
    show() {
      const commands = ["show", ...getTrailingOptions(arguments, 1)];
      return this._runTask(straightThroughStringTask(commands), trailingFunctionArgument(arguments));
    }
  };
}
var init_show = __esm({
  "src/lib/tasks/show.ts"() {
    init_utils();
    init_task();
  }
});
var fromPathRegex;
var FileStatusSummary;
var init_FileStatusSummary = __esm({
  "src/lib/responses/FileStatusSummary.ts"() {
    fromPathRegex = /^(.+) -> (.+)$/;
    FileStatusSummary = class {
      constructor(path, index, working_dir) {
        this.path = path;
        this.index = index;
        this.working_dir = working_dir;
        if (index + working_dir === "R") {
          const detail = fromPathRegex.exec(path) || [null, path, path];
          this.from = detail[1] || "";
          this.path = detail[2] || "";
        }
      }
    };
  }
});
function renamedFile(line) {
  const [to, from] = line.split(NULL);
  return {
    from: from || to,
    to
  };
}
function parser2(indexX, indexY, handler) {
  return [`${indexX}${indexY}`, handler];
}
function conflicts(indexX, ...indexY) {
  return indexY.map((y) => parser2(indexX, y, (result, file) => append(result.conflicted, file)));
}
function splitLine(result, lineStr) {
  const trimmed2 = lineStr.trim();
  switch (" ") {
    case trimmed2.charAt(2):
      return data(trimmed2.charAt(0), trimmed2.charAt(1), trimmed2.substr(3));
    case trimmed2.charAt(1):
      return data(" ", trimmed2.charAt(0), trimmed2.substr(2));
    default:
      return;
  }
  function data(index, workingDir, path) {
    const raw = `${index}${workingDir}`;
    const handler = parsers6.get(raw);
    if (handler) {
      handler(result, path);
    }
    if (raw !== "##" && raw !== "!!") {
      result.files.push(new FileStatusSummary(path.replace(/\0.+$/, ""), index, workingDir));
    }
  }
}
var StatusSummary;
var parsers6;
var parseStatusSummary;
var init_StatusSummary = __esm({
  "src/lib/responses/StatusSummary.ts"() {
    init_utils();
    init_FileStatusSummary();
    StatusSummary = class {
      constructor() {
        this.not_added = [];
        this.conflicted = [];
        this.created = [];
        this.deleted = [];
        this.ignored = void 0;
        this.modified = [];
        this.renamed = [];
        this.files = [];
        this.staged = [];
        this.ahead = 0;
        this.behind = 0;
        this.current = null;
        this.tracking = null;
        this.detached = false;
        this.isClean = () => {
          return !this.files.length;
        };
      }
    };
    parsers6 = new Map([
      parser2(" ", "A", (result, file) => append(result.created, file)),
      parser2(" ", "D", (result, file) => append(result.deleted, file)),
      parser2(" ", "M", (result, file) => append(result.modified, file)),
      parser2("A", " ", (result, file) => append(result.created, file) && append(result.staged, file)),
      parser2("A", "M", (result, file) => append(result.created, file) && append(result.staged, file) && append(result.modified, file)),
      parser2("D", " ", (result, file) => append(result.deleted, file) && append(result.staged, file)),
      parser2("M", " ", (result, file) => append(result.modified, file) && append(result.staged, file)),
      parser2("M", "M", (result, file) => append(result.modified, file) && append(result.staged, file)),
      parser2("R", " ", (result, file) => {
        append(result.renamed, renamedFile(file));
      }),
      parser2("R", "M", (result, file) => {
        const renamed = renamedFile(file);
        append(result.renamed, renamed);
        append(result.modified, renamed.to);
      }),
      parser2("!", "!", (_result, _file) => {
        append(_result.ignored = _result.ignored || [], _file);
      }),
      parser2("?", "?", (result, file) => append(result.not_added, file)),
      ...conflicts(
        "A",
        "A",
        "U"
        /* UNMERGED */
      ),
      ...conflicts(
        "D",
        "D",
        "U"
        /* UNMERGED */
      ),
      ...conflicts(
        "U",
        "A",
        "D",
        "U"
        /* UNMERGED */
      ),
      [
        "##",
        (result, line) => {
          const aheadReg = /ahead (\d+)/;
          const behindReg = /behind (\d+)/;
          const currentReg = /^(.+?(?=(?:\.{3}|\s|$)))/;
          const trackingReg = /\.{3}(\S*)/;
          const onEmptyBranchReg = /\son\s([\S]+)$/;
          let regexResult;
          regexResult = aheadReg.exec(line);
          result.ahead = regexResult && +regexResult[1] || 0;
          regexResult = behindReg.exec(line);
          result.behind = regexResult && +regexResult[1] || 0;
          regexResult = currentReg.exec(line);
          result.current = regexResult && regexResult[1];
          regexResult = trackingReg.exec(line);
          result.tracking = regexResult && regexResult[1];
          regexResult = onEmptyBranchReg.exec(line);
          result.current = regexResult && regexResult[1] || result.current;
          result.detached = /\(no branch\)/.test(line);
        }
      ]
    ]);
    parseStatusSummary = function(text) {
      const lines = text.split(NULL);
      const status = new StatusSummary();
      for (let i = 0, l = lines.length; i < l; ) {
        let line = lines[i++].trim();
        if (!line) {
          continue;
        }
        if (line.charAt(0) === "R") {
          line += NULL + (lines[i++] || "");
        }
        splitLine(status, line);
      }
      return status;
    };
  }
});
function statusTask(customArgs) {
  const commands = [
    "status",
    "--porcelain",
    "-b",
    "-u",
    "--null",
    ...customArgs.filter((arg) => !ignoredOptions.includes(arg))
  ];
  return {
    format: "utf-8",
    commands,
    parser(text) {
      return parseStatusSummary(text);
    }
  };
}
var ignoredOptions;
var init_status = __esm({
  "src/lib/tasks/status.ts"() {
    init_StatusSummary();
    ignoredOptions = ["--null", "-z"];
  }
});
function versionResponse(major = 0, minor = 0, patch = 0, agent = "", installed = true) {
  return Object.defineProperty({
    major,
    minor,
    patch,
    agent,
    installed
  }, "toString", {
    value() {
      return `${this.major}.${this.minor}.${this.patch}`;
    },
    configurable: false,
    enumerable: false
  });
}
function notInstalledResponse() {
  return versionResponse(0, 0, 0, "", false);
}
function version_default() {
  return {
    version() {
      return this._runTask({
        commands: ["--version"],
        format: "utf-8",
        parser: versionParser,
        onError(result, error, done, fail) {
          if (result.exitCode === -2) {
            return done(Buffer.from(NOT_INSTALLED));
          }
          fail(error);
        }
      });
    }
  };
}
function versionParser(stdOut) {
  if (stdOut === NOT_INSTALLED) {
    return notInstalledResponse();
  }
  return parseStringResponse(versionResponse(0, 0, 0, stdOut), parsers7, stdOut);
}
var NOT_INSTALLED;
var parsers7;
var init_version = __esm({
  "src/lib/tasks/version.ts"() {
    init_utils();
    NOT_INSTALLED = "installed=false";
    parsers7 = [
      new LineParser(/version (\d+)\.(\d+)\.(\d+)(?:\s*\((.+)\))?/, (result, [major, minor, patch, agent = ""]) => {
        Object.assign(result, versionResponse(asNumber(major), asNumber(minor), asNumber(patch), agent));
      }),
      new LineParser(/version (\d+)\.(\d+)\.(\D+)(.+)?$/, (result, [major, minor, patch, agent = ""]) => {
        Object.assign(result, versionResponse(asNumber(major), asNumber(minor), patch, agent));
      })
    ];
  }
});
var simple_git_api_exports = {};
__export2(simple_git_api_exports, {
  SimpleGitApi: () => SimpleGitApi
});
var SimpleGitApi;
var init_simple_git_api = __esm({
  "src/lib/simple-git-api.ts"() {
    init_task_callback();
    init_change_working_directory();
    init_checkout();
    init_commit();
    init_config();
    init_first_commit();
    init_grep();
    init_hash_object();
    init_init();
    init_log();
    init_merge();
    init_push();
    init_show();
    init_status();
    init_task();
    init_version();
    init_utils();
    SimpleGitApi = class {
      constructor(_executor) {
        this._executor = _executor;
      }
      _runTask(task, then) {
        const chain = this._executor.chain();
        const promise = chain.push(task);
        if (then) {
          taskCallback(task, promise, then);
        }
        return Object.create(this, {
          then: { value: promise.then.bind(promise) },
          catch: { value: promise.catch.bind(promise) },
          _executor: { value: chain }
        });
      }
      add(files) {
        return this._runTask(straightThroughStringTask(["add", ...asArray(files)]), trailingFunctionArgument(arguments));
      }
      cwd(directory) {
        const next = trailingFunctionArgument(arguments);
        if (typeof directory === "string") {
          return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next);
        }
        if (typeof (directory == null ? void 0 : directory.path) === "string") {
          return this._runTask(changeWorkingDirectoryTask(directory.path, directory.root && this._executor || void 0), next);
        }
        return this._runTask(configurationErrorTask("Git.cwd: workingDirectory must be supplied as a string"), next);
      }
      hashObject(path, write) {
        return this._runTask(hashObjectTask(path, write === true), trailingFunctionArgument(arguments));
      }
      init(bare) {
        return this._runTask(initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
      }
      merge() {
        return this._runTask(mergeTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
      }
      mergeFromTo(remote, branch) {
        if (!(filterString(remote) && filterString(branch))) {
          return this._runTask(configurationErrorTask(`Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`));
        }
        return this._runTask(mergeTask([remote, branch, ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments, false));
      }
      outputHandler(handler) {
        this._executor.outputHandler = handler;
        return this;
      }
      push() {
        const task = pushTask({
          remote: filterType(arguments[0], filterString),
          branch: filterType(arguments[1], filterString)
        }, getTrailingOptions(arguments));
        return this._runTask(task, trailingFunctionArgument(arguments));
      }
      stash() {
        return this._runTask(straightThroughStringTask(["stash", ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments));
      }
      status() {
        return this._runTask(statusTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
      }
    };
    Object.assign(SimpleGitApi.prototype, checkout_default(), commit_default(), config_default(), first_commit_default(), grep_default(), log_default(), show_default(), version_default());
  }
});
var scheduler_exports = {};
__export2(scheduler_exports, {
  Scheduler: () => Scheduler
});
var createScheduledTask;
var Scheduler;
var init_scheduler = __esm({
  "src/lib/runners/scheduler.ts"() {
    init_utils();
    init_git_logger();
    createScheduledTask = (() => {
      let id = 0;
      return () => {
        id++;
        const { promise, done } = (0, import_promise_deferred.createDeferred)();
        return {
          promise,
          done,
          id
        };
      };
    })();
    Scheduler = class {
      constructor(concurrency = 2) {
        this.concurrency = concurrency;
        this.logger = createLogger("", "scheduler");
        this.pending = [];
        this.running = [];
        this.logger(`Constructed, concurrency=%s`, concurrency);
      }
      schedule() {
        if (!this.pending.length || this.running.length >= this.concurrency) {
          this.logger(`Schedule attempt ignored, pending=%s running=%s concurrency=%s`, this.pending.length, this.running.length, this.concurrency);
          return;
        }
        const task = append(this.running, this.pending.shift());
        this.logger(`Attempting id=%s`, task.id);
        task.done(() => {
          this.logger(`Completing id=`, task.id);
          remove(this.running, task);
          this.schedule();
        });
      }
      next() {
        const { promise, id } = append(this.pending, createScheduledTask());
        this.logger(`Scheduling id=%s`, id);
        this.schedule();
        return promise;
      }
    };
  }
});
var apply_patch_exports = {};
__export2(apply_patch_exports, {
  applyPatchTask: () => applyPatchTask
});
function applyPatchTask(patches, customArgs) {
  return straightThroughStringTask(["apply", ...customArgs, ...patches]);
}
var init_apply_patch = __esm({
  "src/lib/tasks/apply-patch.ts"() {
    init_task();
  }
});
function branchDeletionSuccess(branch, hash) {
  return {
    branch,
    hash,
    success: true
  };
}
function branchDeletionFailure(branch) {
  return {
    branch,
    hash: null,
    success: false
  };
}
var BranchDeletionBatch;
var init_BranchDeleteSummary = __esm({
  "src/lib/responses/BranchDeleteSummary.ts"() {
    BranchDeletionBatch = class {
      constructor() {
        this.all = [];
        this.branches = {};
        this.errors = [];
      }
      get success() {
        return !this.errors.length;
      }
    };
  }
});
function hasBranchDeletionError(data, processExitCode) {
  return processExitCode === 1 && deleteErrorRegex.test(data);
}
var deleteSuccessRegex;
var deleteErrorRegex;
var parsers8;
var parseBranchDeletions;
var init_parse_branch_delete = __esm({
  "src/lib/parsers/parse-branch-delete.ts"() {
    init_BranchDeleteSummary();
    init_utils();
    deleteSuccessRegex = /(\S+)\s+\(\S+\s([^)]+)\)/;
    deleteErrorRegex = /^error[^']+'([^']+)'/m;
    parsers8 = [
      new LineParser(deleteSuccessRegex, (result, [branch, hash]) => {
        const deletion = branchDeletionSuccess(branch, hash);
        result.all.push(deletion);
        result.branches[branch] = deletion;
      }),
      new LineParser(deleteErrorRegex, (result, [branch]) => {
        const deletion = branchDeletionFailure(branch);
        result.errors.push(deletion);
        result.all.push(deletion);
        result.branches[branch] = deletion;
      })
    ];
    parseBranchDeletions = (stdOut, stdErr) => {
      return parseStringResponse(new BranchDeletionBatch(), parsers8, [stdOut, stdErr]);
    };
  }
});
var BranchSummaryResult;
var init_BranchSummary = __esm({
  "src/lib/responses/BranchSummary.ts"() {
    BranchSummaryResult = class {
      constructor() {
        this.all = [];
        this.branches = {};
        this.current = "";
        this.detached = false;
      }
      push(status, detached, name, commit, label) {
        if (status === "*") {
          this.detached = detached;
          this.current = name;
        }
        this.all.push(name);
        this.branches[name] = {
          current: status === "*",
          linkedWorkTree: status === "+",
          name,
          commit,
          label
        };
      }
    };
  }
});
function branchStatus(input) {
  return input ? input.charAt(0) : "";
}
function parseBranchSummary(stdOut) {
  return parseStringResponse(new BranchSummaryResult(), parsers9, stdOut);
}
var parsers9;
var init_parse_branch = __esm({
  "src/lib/parsers/parse-branch.ts"() {
    init_BranchSummary();
    init_utils();
    parsers9 = [
      new LineParser(/^([*+]\s)?\((?:HEAD )?detached (?:from|at) (\S+)\)\s+([a-z0-9]+)\s(.*)$/, (result, [current, name, commit, label]) => {
        result.push(branchStatus(current), true, name, commit, label);
      }),
      new LineParser(/^([*+]\s)?(\S+)\s+([a-z0-9]+)\s?(.*)$/s, (result, [current, name, commit, label]) => {
        result.push(branchStatus(current), false, name, commit, label);
      })
    ];
  }
});
var branch_exports = {};
__export2(branch_exports, {
  branchLocalTask: () => branchLocalTask,
  branchTask: () => branchTask,
  containsDeleteBranchCommand: () => containsDeleteBranchCommand,
  deleteBranchTask: () => deleteBranchTask,
  deleteBranchesTask: () => deleteBranchesTask
});
function containsDeleteBranchCommand(commands) {
  const deleteCommands = ["-d", "-D", "--delete"];
  return commands.some((command) => deleteCommands.includes(command));
}
function branchTask(customArgs) {
  const isDelete = containsDeleteBranchCommand(customArgs);
  const commands = ["branch", ...customArgs];
  if (commands.length === 1) {
    commands.push("-a");
  }
  if (!commands.includes("-v")) {
    commands.splice(1, 0, "-v");
  }
  return {
    format: "utf-8",
    commands,
    parser(stdOut, stdErr) {
      if (isDelete) {
        return parseBranchDeletions(stdOut, stdErr).all[0];
      }
      return parseBranchSummary(stdOut);
    }
  };
}
function branchLocalTask() {
  const parser3 = parseBranchSummary;
  return {
    format: "utf-8",
    commands: ["branch", "-v"],
    parser: parser3
  };
}
function deleteBranchesTask(branches, forceDelete = false) {
  return {
    format: "utf-8",
    commands: ["branch", "-v", forceDelete ? "-D" : "-d", ...branches],
    parser(stdOut, stdErr) {
      return parseBranchDeletions(stdOut, stdErr);
    },
    onError({ exitCode, stdOut }, error, done, fail) {
      if (!hasBranchDeletionError(String(error), exitCode)) {
        return fail(error);
      }
      done(stdOut);
    }
  };
}
function deleteBranchTask(branch, forceDelete = false) {
  const task = {
    format: "utf-8",
    commands: ["branch", "-v", forceDelete ? "-D" : "-d", branch],
    parser(stdOut, stdErr) {
      return parseBranchDeletions(stdOut, stdErr).branches[branch];
    },
    onError({ exitCode, stdErr, stdOut }, error, _, fail) {
      if (!hasBranchDeletionError(String(error), exitCode)) {
        return fail(error);
      }
      throw new GitResponseError(task.parser(bufferToString(stdOut), bufferToString(stdErr)), String(error));
    }
  };
  return task;
}
var init_branch = __esm({
  "src/lib/tasks/branch.ts"() {
    init_git_response_error();
    init_parse_branch_delete();
    init_parse_branch();
    init_utils();
  }
});
var parseCheckIgnore;
var init_CheckIgnore = __esm({
  "src/lib/responses/CheckIgnore.ts"() {
    parseCheckIgnore = (text) => {
      return text.split(/\n/g).map((line) => line.trim()).filter((file) => !!file);
    };
  }
});
var check_ignore_exports = {};
__export2(check_ignore_exports, {
  checkIgnoreTask: () => checkIgnoreTask
});
function checkIgnoreTask(paths) {
  return {
    commands: ["check-ignore", ...paths],
    format: "utf-8",
    parser: parseCheckIgnore
  };
}
var init_check_ignore = __esm({
  "src/lib/tasks/check-ignore.ts"() {
    init_CheckIgnore();
  }
});
var clone_exports = {};
__export2(clone_exports, {
  cloneMirrorTask: () => cloneMirrorTask,
  cloneTask: () => cloneTask
});
function disallowedCommand(command) {
  return /^--upload-pack(=|$)/.test(command);
}
function cloneTask(repo, directory, customArgs) {
  const commands = ["clone", ...customArgs];
  filterString(repo) && commands.push(repo);
  filterString(directory) && commands.push(directory);
  const banned = commands.find(disallowedCommand);
  if (banned) {
    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);
  }
  return straightThroughStringTask(commands);
}
function cloneMirrorTask(repo, directory, customArgs) {
  append(customArgs, "--mirror");
  return cloneTask(repo, directory, customArgs);
}
var init_clone = __esm({
  "src/lib/tasks/clone.ts"() {
    init_task();
    init_utils();
  }
});
function parseFetchResult(stdOut, stdErr) {
  const result = {
    raw: stdOut,
    remote: null,
    branches: [],
    tags: [],
    updated: [],
    deleted: []
  };
  return parseStringResponse(result, parsers10, [stdOut, stdErr]);
}
var parsers10;
var init_parse_fetch = __esm({
  "src/lib/parsers/parse-fetch.ts"() {
    init_utils();
    parsers10 = [
      new LineParser(/From (.+)$/, (result, [remote]) => {
        result.remote = remote;
      }),
      new LineParser(/\* \[new branch]\s+(\S+)\s*-> (.+)$/, (result, [name, tracking]) => {
        result.branches.push({
          name,
          tracking
        });
      }),
      new LineParser(/\* \[new tag]\s+(\S+)\s*-> (.+)$/, (result, [name, tracking]) => {
        result.tags.push({
          name,
          tracking
        });
      }),
      new LineParser(/- \[deleted]\s+\S+\s*-> (.+)$/, (result, [tracking]) => {
        result.deleted.push({
          tracking
        });
      }),
      new LineParser(/\s*([^.]+)\.\.(\S+)\s+(\S+)\s*-> (.+)$/, (result, [from, to, name, tracking]) => {
        result.updated.push({
          name,
          tracking,
          to,
          from
        });
      })
    ];
  }
});
var fetch_exports = {};
__export2(fetch_exports, {
  fetchTask: () => fetchTask
});
function disallowedCommand2(command) {
  return /^--upload-pack(=|$)/.test(command);
}
function fetchTask(remote, branch, customArgs) {
  const commands = ["fetch", ...customArgs];
  if (remote && branch) {
    commands.push(remote, branch);
  }
  const banned = commands.find(disallowedCommand2);
  if (banned) {
    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);
  }
  return {
    commands,
    format: "utf-8",
    parser: parseFetchResult
  };
}
var init_fetch = __esm({
  "src/lib/tasks/fetch.ts"() {
    init_parse_fetch();
    init_task();
  }
});
function parseMoveResult(stdOut) {
  return parseStringResponse({ moves: [] }, parsers11, stdOut);
}
var parsers11;
var init_parse_move = __esm({
  "src/lib/parsers/parse-move.ts"() {
    init_utils();
    parsers11 = [
      new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {
        result.moves.push({ from, to });
      })
    ];
  }
});
var move_exports = {};
__export2(move_exports, {
  moveTask: () => moveTask
});
function moveTask(from, to) {
  return {
    commands: ["mv", "-v", ...asArray(from), to],
    format: "utf-8",
    parser: parseMoveResult
  };
}
var init_move = __esm({
  "src/lib/tasks/move.ts"() {
    init_parse_move();
    init_utils();
  }
});
var pull_exports = {};
__export2(pull_exports, {
  pullTask: () => pullTask
});
function pullTask(remote, branch, customArgs) {
  const commands = ["pull", ...customArgs];
  if (remote && branch) {
    commands.splice(1, 0, remote, branch);
  }
  return {
    commands,
    format: "utf-8",
    parser(stdOut, stdErr) {
      return parsePullResult(stdOut, stdErr);
    },
    onError(result, _error, _done, fail) {
      const pullError = parsePullErrorResult(bufferToString(result.stdOut), bufferToString(result.stdErr));
      if (pullError) {
        return fail(new GitResponseError(pullError));
      }
      fail(_error);
    }
  };
}
var init_pull = __esm({
  "src/lib/tasks/pull.ts"() {
    init_git_response_error();
    init_parse_pull();
    init_utils();
  }
});
function parseGetRemotes(text) {
  const remotes = {};
  forEach(text, ([name]) => remotes[name] = { name });
  return Object.values(remotes);
}
function parseGetRemotesVerbose(text) {
  const remotes = {};
  forEach(text, ([name, url, purpose]) => {
    if (!remotes.hasOwnProperty(name)) {
      remotes[name] = {
        name,
        refs: { fetch: "", push: "" }
      };
    }
    if (purpose && url) {
      remotes[name].refs[purpose.replace(/[^a-z]/g, "")] = url;
    }
  });
  return Object.values(remotes);
}
function forEach(text, handler) {
  forEachLineWithContent(text, (line) => handler(line.split(/\s+/)));
}
var init_GetRemoteSummary = __esm({
  "src/lib/responses/GetRemoteSummary.ts"() {
    init_utils();
  }
});
var remote_exports = {};
__export2(remote_exports, {
  addRemoteTask: () => addRemoteTask,
  getRemotesTask: () => getRemotesTask,
  listRemotesTask: () => listRemotesTask,
  remoteTask: () => remoteTask,
  removeRemoteTask: () => removeRemoteTask
});
function addRemoteTask(remoteName, remoteRepo, customArgs = []) {
  return straightThroughStringTask(["remote", "add", ...customArgs, remoteName, remoteRepo]);
}
function getRemotesTask(verbose) {
  const commands = ["remote"];
  if (verbose) {
    commands.push("-v");
  }
  return {
    commands,
    format: "utf-8",
    parser: verbose ? parseGetRemotesVerbose : parseGetRemotes
  };
}
function listRemotesTask(customArgs = []) {
  const commands = [...customArgs];
  if (commands[0] !== "ls-remote") {
    commands.unshift("ls-remote");
  }
  return straightThroughStringTask(commands);
}
function remoteTask(customArgs = []) {
  const commands = [...customArgs];
  if (commands[0] !== "remote") {
    commands.unshift("remote");
  }
  return straightThroughStringTask(commands);
}
function removeRemoteTask(remoteName) {
  return straightThroughStringTask(["remote", "remove", remoteName]);
}
var init_remote = __esm({
  "src/lib/tasks/remote.ts"() {
    init_GetRemoteSummary();
    init_task();
  }
});
var stash_list_exports = {};
__export2(stash_list_exports, {
  stashListTask: () => stashListTask
});
function stashListTask(opt = {}, customArgs) {
  const options = parseLogOptions(opt);
  const commands = ["stash", "list", ...options.commands, ...customArgs];
  const parser3 = createListLogSummaryParser(options.splitter, options.fields, logFormatFromCommand(commands));
  return validateLogFormatConfig(commands) || {
    commands,
    format: "utf-8",
    parser: parser3
  };
}
var init_stash_list = __esm({
  "src/lib/tasks/stash-list.ts"() {
    init_log_format();
    init_parse_list_log_summary();
    init_diff();
    init_log();
  }
});
var sub_module_exports = {};
__export2(sub_module_exports, {
  addSubModuleTask: () => addSubModuleTask,
  initSubModuleTask: () => initSubModuleTask,
  subModuleTask: () => subModuleTask,
  updateSubModuleTask: () => updateSubModuleTask
});
function addSubModuleTask(repo, path) {
  return subModuleTask(["add", repo, path]);
}
function initSubModuleTask(customArgs) {
  return subModuleTask(["init", ...customArgs]);
}
function subModuleTask(customArgs) {
  const commands = [...customArgs];
  if (commands[0] !== "submodule") {
    commands.unshift("submodule");
  }
  return straightThroughStringTask(commands);
}
function updateSubModuleTask(customArgs) {
  return subModuleTask(["update", ...customArgs]);
}
var init_sub_module = __esm({
  "src/lib/tasks/sub-module.ts"() {
    init_task();
  }
});
function singleSorted(a, b) {
  const aIsNum = isNaN(a);
  const bIsNum = isNaN(b);
  if (aIsNum !== bIsNum) {
    return aIsNum ? 1 : -1;
  }
  return aIsNum ? sorted(a, b) : 0;
}
function sorted(a, b) {
  return a === b ? 0 : a > b ? 1 : -1;
}
function trimmed(input) {
  return input.trim();
}
function toNumber(input) {
  if (typeof input === "string") {
    return parseInt(input.replace(/^\D+/g, ""), 10) || 0;
  }
  return 0;
}
var TagList;
var parseTagList;
var init_TagList = __esm({
  "src/lib/responses/TagList.ts"() {
    TagList = class {
      constructor(all, latest) {
        this.all = all;
        this.latest = latest;
      }
    };
    parseTagList = function(data, customSort = false) {
      const tags = data.split("\n").map(trimmed).filter(Boolean);
      if (!customSort) {
        tags.sort(function(tagA, tagB) {
          const partsA = tagA.split(".");
          const partsB = tagB.split(".");
          if (partsA.length === 1 || partsB.length === 1) {
            return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));
          }
          for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {
            const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));
            if (diff) {
              return diff;
            }
          }
          return 0;
        });
      }
      const latest = customSort ? tags[0] : [...tags].reverse().find((tag) => tag.indexOf(".") >= 0);
      return new TagList(tags, latest);
    };
  }
});
var tag_exports = {};
__export2(tag_exports, {
  addAnnotatedTagTask: () => addAnnotatedTagTask,
  addTagTask: () => addTagTask,
  tagListTask: () => tagListTask
});
function tagListTask(customArgs = []) {
  const hasCustomSort = customArgs.some((option) => /^--sort=/.test(option));
  return {
    format: "utf-8",
    commands: ["tag", "-l", ...customArgs],
    parser(text) {
      return parseTagList(text, hasCustomSort);
    }
  };
}
function addTagTask(name) {
  return {
    format: "utf-8",
    commands: ["tag", name],
    parser() {
      return { name };
    }
  };
}
function addAnnotatedTagTask(name, tagMessage) {
  return {
    format: "utf-8",
    commands: ["tag", "-a", "-m", tagMessage, name],
    parser() {
      return { name };
    }
  };
}
var init_tag = __esm({
  "src/lib/tasks/tag.ts"() {
    init_TagList();
  }
});
var require_git = __commonJS2({
  "src/git.js"(exports, module2) {
    var { GitExecutor: GitExecutor2 } = (init_git_executor(), __toCommonJS2(git_executor_exports));
    var { SimpleGitApi: SimpleGitApi2 } = (init_simple_git_api(), __toCommonJS2(simple_git_api_exports));
    var { Scheduler: Scheduler2 } = (init_scheduler(), __toCommonJS2(scheduler_exports));
    var { configurationErrorTask: configurationErrorTask2 } = (init_task(), __toCommonJS2(task_exports));
    var {
      asArray: asArray2,
      filterArray: filterArray2,
      filterPrimitives: filterPrimitives2,
      filterString: filterString2,
      filterStringOrStringArray: filterStringOrStringArray2,
      filterType: filterType2,
      getTrailingOptions: getTrailingOptions2,
      trailingFunctionArgument: trailingFunctionArgument2,
      trailingOptionsArgument: trailingOptionsArgument2
    } = (init_utils(), __toCommonJS2(utils_exports));
    var { applyPatchTask: applyPatchTask2 } = (init_apply_patch(), __toCommonJS2(apply_patch_exports));
    var {
      branchTask: branchTask2,
      branchLocalTask: branchLocalTask2,
      deleteBranchesTask: deleteBranchesTask2,
      deleteBranchTask: deleteBranchTask2
    } = (init_branch(), __toCommonJS2(branch_exports));
    var { checkIgnoreTask: checkIgnoreTask2 } = (init_check_ignore(), __toCommonJS2(check_ignore_exports));
    var { checkIsRepoTask: checkIsRepoTask2 } = (init_check_is_repo(), __toCommonJS2(check_is_repo_exports));
    var { cloneTask: cloneTask2, cloneMirrorTask: cloneMirrorTask2 } = (init_clone(), __toCommonJS2(clone_exports));
    var { cleanWithOptionsTask: cleanWithOptionsTask2, isCleanOptionsArray: isCleanOptionsArray2 } = (init_clean(), __toCommonJS2(clean_exports));
    var { diffSummaryTask: diffSummaryTask2 } = (init_diff(), __toCommonJS2(diff_exports));
    var { fetchTask: fetchTask2 } = (init_fetch(), __toCommonJS2(fetch_exports));
    var { moveTask: moveTask2 } = (init_move(), __toCommonJS2(move_exports));
    var { pullTask: pullTask2 } = (init_pull(), __toCommonJS2(pull_exports));
    var { pushTagsTask: pushTagsTask2 } = (init_push(), __toCommonJS2(push_exports));
    var {
      addRemoteTask: addRemoteTask2,
      getRemotesTask: getRemotesTask2,
      listRemotesTask: listRemotesTask2,
      remoteTask: remoteTask2,
      removeRemoteTask: removeRemoteTask2
    } = (init_remote(), __toCommonJS2(remote_exports));
    var { getResetMode: getResetMode2, resetTask: resetTask2 } = (init_reset(), __toCommonJS2(reset_exports));
    var { stashListTask: stashListTask2 } = (init_stash_list(), __toCommonJS2(stash_list_exports));
    var {
      addSubModuleTask: addSubModuleTask2,
      initSubModuleTask: initSubModuleTask2,
      subModuleTask: subModuleTask2,
      updateSubModuleTask: updateSubModuleTask2
    } = (init_sub_module(), __toCommonJS2(sub_module_exports));
    var { addAnnotatedTagTask: addAnnotatedTagTask2, addTagTask: addTagTask2, tagListTask: tagListTask2 } = (init_tag(), __toCommonJS2(tag_exports));
    var { straightThroughBufferTask: straightThroughBufferTask2, straightThroughStringTask: straightThroughStringTask2 } = (init_task(), __toCommonJS2(task_exports));
    function Git2(options, plugins) {
      this._executor = new GitExecutor2(options.binary, options.baseDir, new Scheduler2(options.maxConcurrentProcesses), plugins);
      this._trimmed = options.trimmed;
    }
    (Git2.prototype = Object.create(SimpleGitApi2.prototype)).constructor = Git2;
    Git2.prototype.customBinary = function(command) {
      this._executor.binary = command;
      return this;
    };
    Git2.prototype.env = function(name, value) {
      if (arguments.length === 1 && typeof name === "object") {
        this._executor.env = name;
      } else {
        (this._executor.env = this._executor.env || {})[name] = value;
      }
      return this;
    };
    Git2.prototype.stashList = function(options) {
      return this._runTask(stashListTask2(trailingOptionsArgument2(arguments) || {}, filterArray2(options) && options || []), trailingFunctionArgument2(arguments));
    };
    function createCloneTask(api, task, repoPath, localPath) {
      if (typeof repoPath !== "string") {
        return configurationErrorTask2(`git.${api}() requires a string 'repoPath'`);
      }
      return task(repoPath, filterType2(localPath, filterString2), getTrailingOptions2(arguments));
    }
    Git2.prototype.clone = function() {
      return this._runTask(createCloneTask("clone", cloneTask2, ...arguments), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.mirror = function() {
      return this._runTask(createCloneTask("mirror", cloneMirrorTask2, ...arguments), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.mv = function(from, to) {
      return this._runTask(moveTask2(from, to), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.checkoutLatestTag = function(then) {
      var git = this;
      return this.pull(function() {
        git.tags(function(err, tags) {
          git.checkout(tags.latest, then);
        });
      });
    };
    Git2.prototype.pull = function(remote, branch, options, then) {
      return this._runTask(pullTask2(filterType2(remote, filterString2), filterType2(branch, filterString2), getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.fetch = function(remote, branch) {
      return this._runTask(fetchTask2(filterType2(remote, filterString2), filterType2(branch, filterString2), getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.silent = function(silence) {
      console.warn("simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3");
      return this;
    };
    Git2.prototype.tags = function(options, then) {
      return this._runTask(tagListTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.rebase = function() {
      return this._runTask(straightThroughStringTask2(["rebase", ...getTrailingOptions2(arguments)]), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.reset = function(mode) {
      return this._runTask(resetTask2(getResetMode2(mode), getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.revert = function(commit) {
      const next = trailingFunctionArgument2(arguments);
      if (typeof commit !== "string") {
        return this._runTask(configurationErrorTask2("Commit must be a string"), next);
      }
      return this._runTask(straightThroughStringTask2(["revert", ...getTrailingOptions2(arguments, 0, true), commit]), next);
    };
    Git2.prototype.addTag = function(name) {
      const task = typeof name === "string" ? addTagTask2(name) : configurationErrorTask2("Git.addTag requires a tag name");
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.addAnnotatedTag = function(tagName, tagMessage) {
      return this._runTask(addAnnotatedTagTask2(tagName, tagMessage), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.deleteLocalBranch = function(branchName, forceDelete, then) {
      return this._runTask(deleteBranchTask2(branchName, typeof forceDelete === "boolean" ? forceDelete : false), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.deleteLocalBranches = function(branchNames, forceDelete, then) {
      return this._runTask(deleteBranchesTask2(branchNames, typeof forceDelete === "boolean" ? forceDelete : false), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.branch = function(options, then) {
      return this._runTask(branchTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.branchLocal = function(then) {
      return this._runTask(branchLocalTask2(), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.raw = function(commands) {
      const createRestCommands = !Array.isArray(commands);
      const command = [].slice.call(createRestCommands ? arguments : commands, 0);
      for (let i = 0; i < command.length && createRestCommands; i++) {
        if (!filterPrimitives2(command[i])) {
          command.splice(i, command.length - i);
          break;
        }
      }
      command.push(...getTrailingOptions2(arguments, 0, true));
      var next = trailingFunctionArgument2(arguments);
      if (!command.length) {
        return this._runTask(configurationErrorTask2("Raw: must supply one or more command to execute"), next);
      }
      return this._runTask(straightThroughStringTask2(command, this._trimmed), next);
    };
    Git2.prototype.submoduleAdd = function(repo, path, then) {
      return this._runTask(addSubModuleTask2(repo, path), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.submoduleUpdate = function(args, then) {
      return this._runTask(updateSubModuleTask2(getTrailingOptions2(arguments, true)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.submoduleInit = function(args, then) {
      return this._runTask(initSubModuleTask2(getTrailingOptions2(arguments, true)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.subModule = function(options, then) {
      return this._runTask(subModuleTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.listRemote = function() {
      return this._runTask(listRemotesTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.addRemote = function(remoteName, remoteRepo, then) {
      return this._runTask(addRemoteTask2(remoteName, remoteRepo, getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.removeRemote = function(remoteName, then) {
      return this._runTask(removeRemoteTask2(remoteName), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.getRemotes = function(verbose, then) {
      return this._runTask(getRemotesTask2(verbose === true), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.remote = function(options, then) {
      return this._runTask(remoteTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.tag = function(options, then) {
      const command = getTrailingOptions2(arguments);
      if (command[0] !== "tag") {
        command.unshift("tag");
      }
      return this._runTask(straightThroughStringTask2(command), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.updateServerInfo = function(then) {
      return this._runTask(straightThroughStringTask2(["update-server-info"]), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.pushTags = function(remote, then) {
      const task = pushTagsTask2({ remote: filterType2(remote, filterString2) }, getTrailingOptions2(arguments));
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.rm = function(files) {
      return this._runTask(straightThroughStringTask2(["rm", "-f", ...asArray2(files)]), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.rmKeepLocal = function(files) {
      return this._runTask(straightThroughStringTask2(["rm", "--cached", ...asArray2(files)]), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.catFile = function(options, then) {
      return this._catFile("utf-8", arguments);
    };
    Git2.prototype.binaryCatFile = function() {
      return this._catFile("buffer", arguments);
    };
    Git2.prototype._catFile = function(format, args) {
      var handler = trailingFunctionArgument2(args);
      var command = ["cat-file"];
      var options = args[0];
      if (typeof options === "string") {
        return this._runTask(configurationErrorTask2("Git.catFile: options must be supplied as an array of strings"), handler);
      }
      if (Array.isArray(options)) {
        command.push.apply(command, options);
      }
      const task = format === "buffer" ? straightThroughBufferTask2(command) : straightThroughStringTask2(command);
      return this._runTask(task, handler);
    };
    Git2.prototype.diff = function(options, then) {
      const task = filterString2(options) ? configurationErrorTask2("git.diff: supplying options as a single string is no longer supported, switch to an array of strings") : straightThroughStringTask2(["diff", ...getTrailingOptions2(arguments)]);
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.diffSummary = function() {
      return this._runTask(diffSummaryTask2(getTrailingOptions2(arguments, 1)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.applyPatch = function(patches) {
      const task = !filterStringOrStringArray2(patches) ? configurationErrorTask2(`git.applyPatch requires one or more string patches as the first argument`) : applyPatchTask2(asArray2(patches), getTrailingOptions2([].slice.call(arguments, 1)));
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.revparse = function() {
      const commands = ["rev-parse", ...getTrailingOptions2(arguments, true)];
      return this._runTask(straightThroughStringTask2(commands, true), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.clean = function(mode, options, then) {
      const usingCleanOptionsArray = isCleanOptionsArray2(mode);
      const cleanMode = usingCleanOptionsArray && mode.join("") || filterType2(mode, filterString2) || "";
      const customArgs = getTrailingOptions2([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));
      return this._runTask(cleanWithOptionsTask2(cleanMode, customArgs), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.exec = function(then) {
      const task = {
        commands: [],
        format: "utf-8",
        parser() {
          if (typeof then === "function") {
            then();
          }
        }
      };
      return this._runTask(task);
    };
    Git2.prototype.clearQueue = function() {
      return this;
    };
    Git2.prototype.checkIgnore = function(pathnames, then) {
      return this._runTask(checkIgnoreTask2(asArray2(filterType2(pathnames, filterStringOrStringArray2, []))), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.checkIsRepo = function(checkType, then) {
      return this._runTask(checkIsRepoTask2(filterType2(checkType, filterString2)), trailingFunctionArgument2(arguments));
    };
    module2.exports = Git2;
  }
});
init_pathspec();
init_git_error();
var GitConstructError = class extends GitError {
  constructor(config, message) {
    super(void 0, message);
    this.config = config;
  }
};
init_git_error();
init_git_error();
var GitPluginError = class extends GitError {
  constructor(task, plugin, message) {
    super(task, message);
    this.task = task;
    this.plugin = plugin;
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
init_git_response_error();
init_task_configuration_error();
init_check_is_repo();
init_clean();
init_config();
init_diff_name_status();
init_grep();
init_reset();
function abortPlugin(signal) {
  if (!signal) {
    return;
  }
  const onSpawnAfter = {
    type: "spawn.after",
    action(_data, context) {
      function kill() {
        context.kill(new GitPluginError(void 0, "abort", "Abort signal received"));
      }
      signal.addEventListener("abort", kill);
      context.spawned.on("close", () => signal.removeEventListener("abort", kill));
    }
  };
  const onSpawnBefore = {
    type: "spawn.before",
    action(_data, context) {
      if (signal.aborted) {
        context.kill(new GitPluginError(void 0, "abort", "Abort already signaled"));
      }
    }
  };
  return [onSpawnBefore, onSpawnAfter];
}
function isConfigSwitch(arg) {
  return typeof arg === "string" && arg.trim().toLowerCase() === "-c";
}
function preventProtocolOverride(arg, next) {
  if (!isConfigSwitch(arg)) {
    return;
  }
  if (!/^\s*protocol(.[a-z]+)?.allow/.test(next)) {
    return;
  }
  throw new GitPluginError(void 0, "unsafe", "Configuring protocol.allow is not permitted without enabling allowUnsafeExtProtocol");
}
function preventUploadPack(arg, method) {
  if (/^\s*--(upload|receive)-pack/.test(arg)) {
    throw new GitPluginError(void 0, "unsafe", `Use of --upload-pack or --receive-pack is not permitted without enabling allowUnsafePack`);
  }
  if (method === "clone" && /^\s*-u\b/.test(arg)) {
    throw new GitPluginError(void 0, "unsafe", `Use of clone with option -u is not permitted without enabling allowUnsafePack`);
  }
  if (method === "push" && /^\s*--exec\b/.test(arg)) {
    throw new GitPluginError(void 0, "unsafe", `Use of push with option --exec is not permitted without enabling allowUnsafePack`);
  }
}
function blockUnsafeOperationsPlugin({
  allowUnsafeProtocolOverride = false,
  allowUnsafePack = false
} = {}) {
  return {
    type: "spawn.args",
    action(args, context) {
      args.forEach((current, index) => {
        const next = index < args.length ? args[index + 1] : "";
        allowUnsafeProtocolOverride || preventProtocolOverride(current, next);
        allowUnsafePack || preventUploadPack(current, context.method);
      });
      return args;
    }
  };
}
init_utils();
function commandConfigPrefixingPlugin(configuration) {
  const prefix = prefixedArray(configuration, "-c");
  return {
    type: "spawn.args",
    action(data) {
      return [...prefix, ...data];
    }
  };
}
init_utils();
var never = (0, import_promise_deferred2.deferred)().promise;
function completionDetectionPlugin({
  onClose = true,
  onExit = 50
} = {}) {
  function createEvents() {
    let exitCode = -1;
    const events = {
      close: (0, import_promise_deferred2.deferred)(),
      closeTimeout: (0, import_promise_deferred2.deferred)(),
      exit: (0, import_promise_deferred2.deferred)(),
      exitTimeout: (0, import_promise_deferred2.deferred)()
    };
    const result = Promise.race([
      onClose === false ? never : events.closeTimeout.promise,
      onExit === false ? never : events.exitTimeout.promise
    ]);
    configureTimeout(onClose, events.close, events.closeTimeout);
    configureTimeout(onExit, events.exit, events.exitTimeout);
    return {
      close(code) {
        exitCode = code;
        events.close.done();
      },
      exit(code) {
        exitCode = code;
        events.exit.done();
      },
      get exitCode() {
        return exitCode;
      },
      result
    };
  }
  function configureTimeout(flag, event, timeout) {
    if (flag === false) {
      return;
    }
    (flag === true ? event.promise : event.promise.then(() => delay(flag))).then(timeout.done);
  }
  return {
    type: "spawn.after",
    action(_0, _1) {
      return __async(this, arguments, function* (_data, { spawned, close }) {
        var _a2, _b;
        const events = createEvents();
        let deferClose = true;
        let quickClose = () => void (deferClose = false);
        (_a2 = spawned.stdout) == null ? void 0 : _a2.on("data", quickClose);
        (_b = spawned.stderr) == null ? void 0 : _b.on("data", quickClose);
        spawned.on("error", quickClose);
        spawned.on("close", (code) => events.close(code));
        spawned.on("exit", (code) => events.exit(code));
        try {
          yield events.result;
          if (deferClose) {
            yield delay(50);
          }
          close(events.exitCode);
        } catch (err) {
          close(events.exitCode, err);
        }
      });
    }
  };
}
init_git_error();
function isTaskError(result) {
  return !!(result.exitCode && result.stdErr.length);
}
function getErrorMessage(result) {
  return Buffer.concat([...result.stdOut, ...result.stdErr]);
}
function errorDetectionHandler(overwrite = false, isError = isTaskError, errorMessage = getErrorMessage) {
  return (error, result) => {
    if (!overwrite && error || !isError(result)) {
      return error;
    }
    return errorMessage(result);
  };
}
function errorDetectionPlugin(config) {
  return {
    type: "task.error",
    action(data, context) {
      const error = config(data.error, {
        stdErr: context.stdErr,
        stdOut: context.stdOut,
        exitCode: context.exitCode
      });
      if (Buffer.isBuffer(error)) {
        return { error: new GitError(void 0, error.toString("utf-8")) };
      }
      return {
        error
      };
    }
  };
}
init_utils();
var PluginStore = class {
  constructor() {
    this.plugins = /* @__PURE__ */ new Set();
  }
  add(plugin) {
    const plugins = [];
    asArray(plugin).forEach((plugin2) => plugin2 && this.plugins.add(append(plugins, plugin2)));
    return () => {
      plugins.forEach((plugin2) => this.plugins.delete(plugin2));
    };
  }
  exec(type, data, context) {
    let output = data;
    const contextual = Object.freeze(Object.create(context));
    for (const plugin of this.plugins) {
      if (plugin.type === type) {
        output = plugin.action(output, contextual);
      }
    }
    return output;
  }
};
init_utils();
function progressMonitorPlugin(progress) {
  const progressCommand = "--progress";
  const progressMethods = ["checkout", "clone", "fetch", "pull", "push"];
  const onProgress = {
    type: "spawn.after",
    action(_data, context) {
      var _a2;
      if (!context.commands.includes(progressCommand)) {
        return;
      }
      (_a2 = context.spawned.stderr) == null ? void 0 : _a2.on("data", (chunk) => {
        const message = /^([\s\S]+?):\s*(\d+)% \((\d+)\/(\d+)\)/.exec(chunk.toString("utf8"));
        if (!message) {
          return;
        }
        progress({
          method: context.method,
          stage: progressEventStage(message[1]),
          progress: asNumber(message[2]),
          processed: asNumber(message[3]),
          total: asNumber(message[4])
        });
      });
    }
  };
  const onArgs = {
    type: "spawn.args",
    action(args, context) {
      if (!progressMethods.includes(context.method)) {
        return args;
      }
      return including(args, progressCommand);
    }
  };
  return [onArgs, onProgress];
}
function progressEventStage(input) {
  return String(input.toLowerCase().split(" ", 1)) || "unknown";
}
init_utils();
function spawnOptionsPlugin(spawnOptions) {
  const options = pick(spawnOptions, ["uid", "gid"]);
  return {
    type: "spawn.options",
    action(data) {
      return __spreadValues(__spreadValues({}, options), data);
    }
  };
}
function timeoutPlugin({
  block,
  stdErr = true,
  stdOut = true
}) {
  if (block > 0) {
    return {
      type: "spawn.after",
      action(_data, context) {
        var _a2, _b;
        let timeout;
        function wait() {
          timeout && clearTimeout(timeout);
          timeout = setTimeout(kill, block);
        }
        function stop() {
          var _a3, _b2;
          (_a3 = context.spawned.stdout) == null ? void 0 : _a3.off("data", wait);
          (_b2 = context.spawned.stderr) == null ? void 0 : _b2.off("data", wait);
          context.spawned.off("exit", stop);
          context.spawned.off("close", stop);
          timeout && clearTimeout(timeout);
        }
        function kill() {
          stop();
          context.kill(new GitPluginError(void 0, "timeout", `block timeout reached`));
        }
        stdOut && ((_a2 = context.spawned.stdout) == null ? void 0 : _a2.on("data", wait));
        stdErr && ((_b = context.spawned.stderr) == null ? void 0 : _b.on("data", wait));
        context.spawned.on("exit", stop);
        context.spawned.on("close", stop);
        wait();
      }
    };
  }
}
init_pathspec();
function suffixPathsPlugin() {
  return {
    type: "spawn.args",
    action(data) {
      const prefix = [];
      let suffix;
      function append2(args) {
        (suffix = suffix || []).push(...args);
      }
      for (let i = 0; i < data.length; i++) {
        const param = data[i];
        if (isPathSpec(param)) {
          append2(toPaths(param));
          continue;
        }
        if (param === "--") {
          append2(data.slice(i + 1).flatMap((item) => isPathSpec(item) && toPaths(item) || item));
          break;
        }
        prefix.push(param);
      }
      return !suffix ? prefix : [...prefix, "--", ...suffix.map(String)];
    }
  };
}
init_utils();
var Git = require_git();
function gitInstanceFactory(baseDir, options) {
  const plugins = new PluginStore();
  const config = createInstanceConfig(baseDir && (typeof baseDir === "string" ? { baseDir } : baseDir) || {}, options);
  if (!folderExists(config.baseDir)) {
    throw new GitConstructError(config, `Cannot use simple-git on a directory that does not exist`);
  }
  if (Array.isArray(config.config)) {
    plugins.add(commandConfigPrefixingPlugin(config.config));
  }
  plugins.add(blockUnsafeOperationsPlugin(config.unsafe));
  plugins.add(suffixPathsPlugin());
  plugins.add(completionDetectionPlugin(config.completion));
  config.abort && plugins.add(abortPlugin(config.abort));
  config.progress && plugins.add(progressMonitorPlugin(config.progress));
  config.timeout && plugins.add(timeoutPlugin(config.timeout));
  config.spawnOptions && plugins.add(spawnOptionsPlugin(config.spawnOptions));
  plugins.add(errorDetectionPlugin(errorDetectionHandler(true)));
  config.errors && plugins.add(errorDetectionPlugin(config.errors));
  return new Git(config, plugins);
}
init_git_response_error();
var simpleGit = gitInstanceFactory;

// main.ts
var DEFAULT_SETTINGS = {
  refreshURL: "https://staging.sunet.se/refresh-content",
  refreshUsername: "editor",
  refreshPassword: "dummy"
};
var SunetPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    const gitOptions = {
      baseDir: this.app.vault.adapter.basePath,
      binary: "git",
      maxConcurrentProcesses: 6,
      trimmed: false
    };
    this.git = simpleGit(gitOptions);
    this.addCommand({
      id: "discard-changes",
      name: "Discard changes in current file",
      editorCallback: (editor, view) => {
        this.discardChanges(view);
      }
    });
    this.addCommand({
      id: "discard-all-changes",
      name: "Discard changes in all files",
      callback: () => {
        this.discardAllChanges();
      }
    });
    this.addCommand({
      id: "commit-push-and-fetch",
      name: "Push all changes to staging",
      callback: () => {
        this.commitPushAndFetch();
      }
    });
    this.addCommand({
      id: "hard-reset-force-push-and-fetch",
      name: "Undo last push of changes to staging",
      callback: () => {
        this.hardResetForcePushAndFetch();
      }
    });
    this.addSettingTab(new SunetSettingTab(this.app, this));
    this.registerDomEvent(document, "click", (evt) => {
      console.log("click", evt);
    });
    this.registerInterval(window.setInterval(() => console.log("setInterval"), 5 * 60 * 1e3));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async discardChanges(view) {
    const file = view.file;
    if (file) {
      const filePath = file.path;
      try {
        await this.git.checkout(["--", filePath]);
        new import_obsidian.Notice("Unstaged changes discarded");
      } catch (error) {
        console.error("Error discarding changes:", error);
        new import_obsidian.Notice("Failed to discard changes");
      }
    } else {
      new import_obsidian.Notice("No file is currently active");
    }
  }
  async discardAllChanges() {
    try {
      await this.git.checkout(["--", "."]);
      new import_obsidian.Notice("All unstaged changes discarded");
    } catch (error) {
      console.error("Error discarding changes:", error);
      new import_obsidian.Notice("Failed to discard all unstaged changes");
    }
  }
  async commitPushAndFetch() {
    try {
      await this.git.add("./*").commit("Auto-commit").push();
      const headers = new Headers();
      headers.append("Accept", "text/plain");
      const credentials = btoa(`${this.settings.refreshUsername}:${this.settings.refreshPassword}`);
      headers.append("Authorization", `Basic ${credentials}`);
      const fetchOptions = {
        method: "get",
        mode: "no-cors",
        headers
      };
      const response = await fetch(this.settings.refreshURL, fetchOptions);
      const body = await response.text();
      new import_obsidian.Notice(body);
    } catch (error) {
      console.error("Error during operation:", error);
      new import_obsidian.Notice("Operation failed");
    }
  }
  async hardResetForcePushAndFetch() {
    try {
      await this.git.reset(["--hard", "HEAD~1"]);
      await this.git.push(["-f"]);
      const headers = new Headers();
      headers.append("Accept", "text/plain");
      const credentials = btoa(`${this.settings.refreshUsername}:${this.settings.refreshPassword}`);
      headers.append("Authorization", `Basic ${credentials}`);
      const fetchOptions = {
        method: "get",
        mode: "no-cors",
        headers
      };
      const response = await fetch(this.settings.refreshURL, fetchOptions);
      const body = await response.text();
      new import_obsidian.Notice(body);
    } catch (error) {
      console.error("Error during operation:", error);
      new import_obsidian.Notice("Operation failed: " + error.message);
    }
  }
};
var SunetSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Staging URL").setDesc("URL of the staging site for sunet.se, ending in /refresh-content").addText((text) => text.setPlaceholder("https://staging.sunet.se/refresh-content").setValue(this.plugin.settings.refreshURL).onChange(async (value) => {
      this.plugin.settings.refreshURL = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Staging Username").setDesc("Basic auth username for the /refresh-content endpoint").addText((text) => text.setPlaceholder("editor").setValue(this.plugin.settings.refreshUsername).onChange(async (value) => {
      this.plugin.settings.refreshUsername = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Staging password").setDesc("Basic auth password for the /refresh-content endpoint").addText((text) => text.setPlaceholder("dummy").setValue(this.plugin.settings.refreshPassword).onChange(async (value) => {
      this.plugin.settings.refreshPassword = value;
      await this.plugin.saveSettings();
    }));
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsICJub2RlX21vZHVsZXMvQGt3c2l0ZXMvZmlsZS1leGlzdHMvc3JjL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9Aa3dzaXRlcy9maWxlLWV4aXN0cy9pbmRleC50cyIsICJub2RlX21vZHVsZXMvQGt3c2l0ZXMvcHJvbWlzZS1kZWZlcnJlZC9zcmMvaW5kZXgudHMiLCAibWFpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL2FyZ3MvcGF0aHNwZWMudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9lcnJvcnMvZ2l0LWVycm9yLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvZXJyb3JzL2dpdC1yZXNwb25zZS1lcnJvci50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL2Vycm9ycy90YXNrLWNvbmZpZ3VyYXRpb24tZXJyb3IudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi91dGlscy91dGlsLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdXRpbHMvYXJndW1lbnQtZmlsdGVycy50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3V0aWxzL2V4aXQtY29kZXMudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi91dGlscy9naXQtb3V0cHV0LXN0cmVhbXMudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi91dGlscy9saW5lLXBhcnNlci50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3V0aWxzL3NpbXBsZS1naXQtb3B0aW9ucy50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3V0aWxzL3Rhc2stb3B0aW9ucy50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3V0aWxzL3Rhc2stcGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdXRpbHMvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9jaGVjay1pcy1yZXBvLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcmVzcG9uc2VzL0NsZWFuU3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL3Rhc2sudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9jbGVhbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Jlc3BvbnNlcy9Db25maWdMaXN0LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvY29uZmlnLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvZGlmZi1uYW1lLXN0YXR1cy50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL2dyZXAudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9yZXNldC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL2dpdC1sb2dnZXIudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9ydW5uZXJzL3Rhc2tzLXBlbmRpbmctcXVldWUudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9ydW5uZXJzL2dpdC1leGVjdXRvci1jaGFpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3J1bm5lcnMvZ2l0LWV4ZWN1dG9yLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFzay1jYWxsYmFjay50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL2NoYW5nZS13b3JraW5nLWRpcmVjdG9yeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL2NoZWNrb3V0LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGFyc2Vycy9wYXJzZS1jb21taXQudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9jb21taXQudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9maXJzdC1jb21taXQudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9oYXNoLW9iamVjdC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Jlc3BvbnNlcy9Jbml0U3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL2luaXQudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9hcmdzL2xvZy1mb3JtYXQudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvRGlmZlN1bW1hcnkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wYXJzZXJzL3BhcnNlLWRpZmYtc3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtbGlzdC1sb2ctc3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL2RpZmYudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9sb2cudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvTWVyZ2VTdW1tYXJ5LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcmVzcG9uc2VzL1B1bGxTdW1tYXJ5LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGFyc2Vycy9wYXJzZS1yZW1vdGUtb2JqZWN0cy50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtcmVtb3RlLW1lc3NhZ2VzLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGFyc2Vycy9wYXJzZS1wdWxsLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGFyc2Vycy9wYXJzZS1tZXJnZS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL21lcmdlLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGFyc2Vycy9wYXJzZS1wdXNoLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvcHVzaC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL3Nob3cudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvRmlsZVN0YXR1c1N1bW1hcnkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvU3RhdHVzU3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL3N0YXR1cy50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL3ZlcnNpb24udHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9zaW1wbGUtZ2l0LWFwaS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3J1bm5lcnMvc2NoZWR1bGVyLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvYXBwbHktcGF0Y2gudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvQnJhbmNoRGVsZXRlU3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtYnJhbmNoLWRlbGV0ZS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Jlc3BvbnNlcy9CcmFuY2hTdW1tYXJ5LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGFyc2Vycy9wYXJzZS1icmFuY2gudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9icmFuY2gudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvQ2hlY2tJZ25vcmUudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9jaGVjay1pZ25vcmUudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9jbG9uZS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtZmV0Y2gudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9mZXRjaC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtbW92ZS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL21vdmUudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9wdWxsLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcmVzcG9uc2VzL0dldFJlbW90ZVN1bW1hcnkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9yZW1vdGUudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9zdGFzaC1saXN0LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3Mvc3ViLW1vZHVsZS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Jlc3BvbnNlcy9UYWdMaXN0LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvdGFnLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9naXQuanMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9hcGkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9lcnJvcnMvZ2l0LWNvbnN0cnVjdC1lcnJvci50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL2Vycm9ycy9naXQtcGx1Z2luLWVycm9yLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGx1Z2lucy9hYm9ydC1wbHVnaW4udHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wbHVnaW5zL2Jsb2NrLXVuc2FmZS1vcGVyYXRpb25zLXBsdWdpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BsdWdpbnMvY29tbWFuZC1jb25maWctcHJlZml4aW5nLXBsdWdpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BsdWdpbnMvY29tcGxldGlvbi1kZXRlY3Rpb24ucGx1Z2luLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGx1Z2lucy9lcnJvci1kZXRlY3Rpb24ucGx1Z2luLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGx1Z2lucy9wbHVnaW4tc3RvcmUudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wbHVnaW5zL3Byb2dyZXNzLW1vbml0b3ItcGx1Z2luLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGx1Z2lucy9zcGF3bi1vcHRpb25zLXBsdWdpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BsdWdpbnMvdGltb3V0LXBsdWdpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BsdWdpbnMvc3VmZml4LXBhdGhzLnBsdWdpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL2dpdC1mYWN0b3J5LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcnVubmVycy9wcm9taXNlLXdyYXBwZWQudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2VzbS5tanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuIiwgIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblx0Y3JlYXRlRGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cblx0T2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Y3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuXHR9KTtcblxuXHQvKipcblx0KiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0Ki9cblxuXHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0KlxuXHQqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0Ki9cblx0Y3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2Vcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblx0XHRsZXQgZW5hYmxlT3ZlcnJpZGUgPSBudWxsO1xuXHRcdGxldCBuYW1lc3BhY2VzQ2FjaGU7XG5cdFx0bGV0IGVuYWJsZWRDYWNoZTtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyUnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdFx0XHRtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0XHRcdFx0XHQvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cdFx0XHRjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0XHRcdGNvbnN0IGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuXHRcdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXG5cdFx0ZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuXHRcdGRlYnVnLmNvbG9yID0gY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGNyZWF0ZURlYnVnLmRlc3Ryb3k7IC8vIFhYWCBUZW1wb3JhcnkuIFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRlYnVnLCAnZW5hYmxlZCcsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdFx0Z2V0OiAoKSA9PiB7XG5cdFx0XHRcdGlmIChlbmFibGVPdmVycmlkZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBlbmFibGVPdmVycmlkZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobmFtZXNwYWNlc0NhY2hlICE9PSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzKSB7XG5cdFx0XHRcdFx0bmFtZXNwYWNlc0NhY2hlID0gY3JlYXRlRGVidWcubmFtZXNwYWNlcztcblx0XHRcdFx0XHRlbmFibGVkQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZW5hYmxlZENhY2hlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogdiA9PiB7XG5cdFx0XHRcdGVuYWJsZU92ZXJyaWRlID0gdjtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcblx0XHRjb25zdCBuZXdEZWJ1ZyA9IGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG5cdFx0bmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG5cdFx0cmV0dXJuIG5ld0RlYnVnO1xuXHR9XG5cblx0LyoqXG5cdCogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdFx0Y3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcblx0XHRjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcztcblxuXHRcdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdFx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHRcdGxldCBpO1xuXHRcdGNvbnN0IHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0XHRjb25zdCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICghc3BsaXRbaV0pIHtcblx0XHRcdFx0Ly8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG5cdFx0XHRpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnNsaWNlKDEpICsgJyQnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0LyoqXG5cdCogWFhYIERPIE5PVCBVU0UuIFRoaXMgaXMgYSB0ZW1wb3Jhcnkgc3R1YiBmdW5jdGlvbi5cblx0KiBYWFggSXQgV0lMTCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cdCovXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4iLCAiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5leHBvcnRzLmRlc3Ryb3kgPSAoKCkgPT4ge1xuXHRsZXQgd2FybmVkID0gZmFsc2U7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoIXdhcm5lZCkge1xuXHRcdFx0d2FybmVkID0gdHJ1ZTtcblx0XHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHRcdH1cblx0fTtcbn0pKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuXHQnIzAwMDBDQycsXG5cdCcjMDAwMEZGJyxcblx0JyMwMDMzQ0MnLFxuXHQnIzAwMzNGRicsXG5cdCcjMDA2NkNDJyxcblx0JyMwMDY2RkYnLFxuXHQnIzAwOTlDQycsXG5cdCcjMDA5OUZGJyxcblx0JyMwMENDMDAnLFxuXHQnIzAwQ0MzMycsXG5cdCcjMDBDQzY2Jyxcblx0JyMwMENDOTknLFxuXHQnIzAwQ0NDQycsXG5cdCcjMDBDQ0ZGJyxcblx0JyMzMzAwQ0MnLFxuXHQnIzMzMDBGRicsXG5cdCcjMzMzM0NDJyxcblx0JyMzMzMzRkYnLFxuXHQnIzMzNjZDQycsXG5cdCcjMzM2NkZGJyxcblx0JyMzMzk5Q0MnLFxuXHQnIzMzOTlGRicsXG5cdCcjMzNDQzAwJyxcblx0JyMzM0NDMzMnLFxuXHQnIzMzQ0M2NicsXG5cdCcjMzNDQzk5Jyxcblx0JyMzM0NDQ0MnLFxuXHQnIzMzQ0NGRicsXG5cdCcjNjYwMENDJyxcblx0JyM2NjAwRkYnLFxuXHQnIzY2MzNDQycsXG5cdCcjNjYzM0ZGJyxcblx0JyM2NkNDMDAnLFxuXHQnIzY2Q0MzMycsXG5cdCcjOTkwMENDJyxcblx0JyM5OTAwRkYnLFxuXHQnIzk5MzNDQycsXG5cdCcjOTkzM0ZGJyxcblx0JyM5OUNDMDAnLFxuXHQnIzk5Q0MzMycsXG5cdCcjQ0MwMDAwJyxcblx0JyNDQzAwMzMnLFxuXHQnI0NDMDA2NicsXG5cdCcjQ0MwMDk5Jyxcblx0JyNDQzAwQ0MnLFxuXHQnI0NDMDBGRicsXG5cdCcjQ0MzMzAwJyxcblx0JyNDQzMzMzMnLFxuXHQnI0NDMzM2NicsXG5cdCcjQ0MzMzk5Jyxcblx0JyNDQzMzQ0MnLFxuXHQnI0NDMzNGRicsXG5cdCcjQ0M2NjAwJyxcblx0JyNDQzY2MzMnLFxuXHQnI0NDOTkwMCcsXG5cdCcjQ0M5OTMzJyxcblx0JyNDQ0NDMDAnLFxuXHQnI0NDQ0MzMycsXG5cdCcjRkYwMDAwJyxcblx0JyNGRjAwMzMnLFxuXHQnI0ZGMDA2NicsXG5cdCcjRkYwMDk5Jyxcblx0JyNGRjAwQ0MnLFxuXHQnI0ZGMDBGRicsXG5cdCcjRkYzMzAwJyxcblx0JyNGRjMzMzMnLFxuXHQnI0ZGMzM2NicsXG5cdCcjRkYzMzk5Jyxcblx0JyNGRjMzQ0MnLFxuXHQnI0ZGMzNGRicsXG5cdCcjRkY2NjAwJyxcblx0JyNGRjY2MzMnLFxuXHQnI0ZGOTkwMCcsXG5cdCcjRkY5OTMzJyxcblx0JyNGRkNDMDAnLFxuXHQnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0Ly8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuXHQvLyBleHBsaWNpdGx5XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cdHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHRcdC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0XHQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuXHRcdC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5kZWJ1ZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqIElmIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYXZhaWxhYmxlLCBmYWxscyBiYWNrXG4gKiB0byBgY29uc29sZS5sb2dgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMubG9nID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZyB8fCAoKCkgPT4ge30pO1xuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcbiIsIG51bGwsIG51bGwsIG51bGwsICJpbXBvcnQgeyBBcHAsIEVkaXRvciwgTWFya2Rvd25WaWV3LCBNb2RhbCwgTm90aWNlLCBQbHVnaW4sIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcgfSBmcm9tICdvYnNpZGlhbic7XG5cbmltcG9ydCB7IHNpbXBsZUdpdCwgU2ltcGxlR2l0LCBDbGVhbk9wdGlvbnMgfSBmcm9tICdzaW1wbGUtZ2l0JztcblxuLy8gUmVtZW1iZXIgdG8gcmVuYW1lIHRoZXNlIGNsYXNzZXMgYW5kIGludGVyZmFjZXMhXG5cbmludGVyZmFjZSBTdW5ldFBsdWdpblNldHRpbmdzIHtcbiAgcmVmcmVzaFVSTDogc3RyaW5nO1xuICByZWZyZXNoVXNlcm5hbWU6IHN0cmluZztcbiAgcmVmcmVzaFBhc3N3b3JkOiBzdHJpbmc7XG59XG5cbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IFN1bmV0UGx1Z2luU2V0dGluZ3MgPSB7XG4gIHJlZnJlc2hVUkw6ICdodHRwczovL3N0YWdpbmcuc3VuZXQuc2UvcmVmcmVzaC1jb250ZW50JyxcbiAgcmVmcmVzaFVzZXJuYW1lOiAnZWRpdG9yJyxcbiAgcmVmcmVzaFBhc3N3b3JkOiAnZHVtbXknLFxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdW5ldFBsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG4gIHNldHRpbmdzOiBTdW5ldFBsdWdpblNldHRpbmdzO1xuICBnaXQ6IFNpbXBsZUdpdDtcblxuICBhc3luYyBvbmxvYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcblxuICAgIGNvbnN0IGdpdE9wdGlvbnM6IFBhcnRpYWw8U2ltcGxlR2l0T3B0aW9ucz4gPSB7XG4gICAgICBiYXNlRGlyOiB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLmJhc2VQYXRoLFxuICAgICAgYmluYXJ5OiAnZ2l0JyxcbiAgICAgIG1heENvbmN1cnJlbnRQcm9jZXNzZXM6IDYsXG4gICAgICB0cmltbWVkOiBmYWxzZSxcbiAgICB9O1xuICAgIHRoaXMuZ2l0ID0gc2ltcGxlR2l0KGdpdE9wdGlvbnMpO1xuXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiAnZGlzY2FyZC1jaGFuZ2VzJyxcbiAgICAgIG5hbWU6ICdEaXNjYXJkIGNoYW5nZXMgaW4gY3VycmVudCBmaWxlJyxcbiAgICAgIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuICAgICAgICB0aGlzLmRpc2NhcmRDaGFuZ2VzKHZpZXcpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6ICdkaXNjYXJkLWFsbC1jaGFuZ2VzJyxcbiAgICAgIG5hbWU6ICdEaXNjYXJkIGNoYW5nZXMgaW4gYWxsIGZpbGVzJyxcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuZGlzY2FyZEFsbENoYW5nZXMoKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiAnY29tbWl0LXB1c2gtYW5kLWZldGNoJyxcbiAgICAgIG5hbWU6ICdQdXNoIGFsbCBjaGFuZ2VzIHRvIHN0YWdpbmcnLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgdGhpcy5jb21taXRQdXNoQW5kRmV0Y2goKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiAnaGFyZC1yZXNldC1mb3JjZS1wdXNoLWFuZC1mZXRjaCcsXG4gICAgICBuYW1lOiAnVW5kbyBsYXN0IHB1c2ggb2YgY2hhbmdlcyB0byBzdGFnaW5nJyxcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuaGFyZFJlc2V0Rm9yY2VQdXNoQW5kRmV0Y2goKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBUaGlzIGFkZHMgYSBzZXR0aW5ncyB0YWIgc28gdGhlIHVzZXIgY2FuIGNvbmZpZ3VyZSB2YXJpb3VzIGFzcGVjdHMgb2YgdGhlIHBsdWdpblxuICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgU3VuZXRTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG5cbiAgICAvLyBJZiB0aGUgcGx1Z2luIGhvb2tzIHVwIGFueSBnbG9iYWwgRE9NIGV2ZW50cyAob24gcGFydHMgb2YgdGhlIGFwcCB0aGF0IGRvZXNuJ3QgYmVsb25nIHRvIHRoaXMgcGx1Z2luKVxuICAgIC8vIFVzaW5nIHRoaXMgZnVuY3Rpb24gd2lsbCBhdXRvbWF0aWNhbGx5IHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXIgd2hlbiB0aGlzIHBsdWdpbiBpcyBkaXNhYmxlZC5cbiAgICB0aGlzLnJlZ2lzdGVyRG9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycsIChldnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdjbGljaycsIGV2dCk7XG4gICAgfSk7XG5cbiAgICAvLyBXaGVuIHJlZ2lzdGVyaW5nIGludGVydmFscywgdGhpcyBmdW5jdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgY2xlYXIgdGhlIGludGVydmFsIHdoZW4gdGhlIHBsdWdpbiBpcyBkaXNhYmxlZC5cbiAgICB0aGlzLnJlZ2lzdGVySW50ZXJ2YWwod2luZG93LnNldEludGVydmFsKCgpID0+IGNvbnNvbGUubG9nKCdzZXRJbnRlcnZhbCcpLCA1ICogNjAgKiAxMDAwKSk7XG4gIH1cblxuICBvbnVubG9hZCgpIHtcblxuICB9XG5cbiAgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xuICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuICB9XG5cbiAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG4gIH1cblxuICBhc3luYyBkaXNjYXJkQ2hhbmdlcyh2aWV3OiBNYXJrZG93blZpZXcpIHtcbiAgICBjb25zdCBmaWxlID0gdmlldy5maWxlO1xuICAgIGlmIChmaWxlKSB7XG4gICAgICBjb25zdCBmaWxlUGF0aCA9IGZpbGUucGF0aDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZ2l0LmNoZWNrb3V0KFsnLS0nLCBmaWxlUGF0aF0pO1xuICAgICAgICBuZXcgTm90aWNlKCdVbnN0YWdlZCBjaGFuZ2VzIGRpc2NhcmRlZCcpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGlzY2FyZGluZyBjaGFuZ2VzOicsIGVycm9yKTtcbiAgICAgICAgbmV3IE5vdGljZSgnRmFpbGVkIHRvIGRpc2NhcmQgY2hhbmdlcycpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXcgTm90aWNlKCdObyBmaWxlIGlzIGN1cnJlbnRseSBhY3RpdmUnKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZGlzY2FyZEFsbENoYW5nZXMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIERpc2NhcmQgYWxsIHVuc3RhZ2VkIGNoYW5nZXMgaW4gdGhlIHJlcG9zaXRvcnlcbiAgICAgIGF3YWl0IHRoaXMuZ2l0LmNoZWNrb3V0KFsnLS0nLCAnLiddKTtcbiAgICAgIG5ldyBOb3RpY2UoJ0FsbCB1bnN0YWdlZCBjaGFuZ2VzIGRpc2NhcmRlZCcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkaXNjYXJkaW5nIGNoYW5nZXM6JywgZXJyb3IpO1xuICAgICAgbmV3IE5vdGljZSgnRmFpbGVkIHRvIGRpc2NhcmQgYWxsIHVuc3RhZ2VkIGNoYW5nZXMnKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY29tbWl0UHVzaEFuZEZldGNoKCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBTdGFnZSwgY29tbWl0LCBhbmQgcHVzaCBjaGFuZ2VzXG4gICAgICBhd2FpdCB0aGlzLmdpdC5hZGQoJy4vKicpLmNvbW1pdCgnQXV0by1jb21taXQnKS5wdXNoKCk7XG5cbiAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgICAgaGVhZGVycy5hcHBlbmQoXCJBY2NlcHRcIiwgXCJ0ZXh0L3BsYWluXCIpO1xuXHQgIGNvbnN0IGNyZWRlbnRpYWxzID0gYnRvYShgJHt0aGlzLnNldHRpbmdzLnJlZnJlc2hVc2VybmFtZX06JHt0aGlzLnNldHRpbmdzLnJlZnJlc2hQYXNzd29yZH1gKTtcblx0ICBoZWFkZXJzLmFwcGVuZChcIkF1dGhvcml6YXRpb25cIiwgYEJhc2ljICR7Y3JlZGVudGlhbHN9YCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGZldGNoT3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiAnZ2V0JyxcbiAgICAgICAgbW9kZTogJ25vLWNvcnMnLFxuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgfTtcbiAgICAgIC8vIEZldGNoIGRhdGEgZnJvbSBleGFtcGxlLmNvbVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLnNldHRpbmdzLnJlZnJlc2hVUkwsIGZldGNoT3B0aW9ucyk7XG4gICAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuXG4gICAgICAvLyBTaG93IHRoZSByZXNwb25zZSBpbiBhIE5vdGljZVxuICAgICAgbmV3IE5vdGljZShib2R5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIG9wZXJhdGlvbjonLCBlcnJvcik7XG4gICAgICBuZXcgTm90aWNlKCdPcGVyYXRpb24gZmFpbGVkJyk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGhhcmRSZXNldEZvcmNlUHVzaEFuZEZldGNoKCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBIYXJkIHJlc2V0IGFuZCBmb3JjZSBwdXNoXG4gICAgICBhd2FpdCB0aGlzLmdpdC5yZXNldChbJy0taGFyZCcsICdIRUFEfjEnXSk7XG4gICAgICBhd2FpdCB0aGlzLmdpdC5wdXNoKFsnLWYnXSk7XG5cbiAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgICAgaGVhZGVycy5hcHBlbmQoXCJBY2NlcHRcIiwgXCJ0ZXh0L3BsYWluXCIpO1xuXHQgIGNvbnN0IGNyZWRlbnRpYWxzID0gYnRvYShgJHt0aGlzLnNldHRpbmdzLnJlZnJlc2hVc2VybmFtZX06JHt0aGlzLnNldHRpbmdzLnJlZnJlc2hQYXNzd29yZH1gKTtcblx0ICBoZWFkZXJzLmFwcGVuZChcIkF1dGhvcml6YXRpb25cIiwgYEJhc2ljICR7Y3JlZGVudGlhbHN9YCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGZldGNoT3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiAnZ2V0JyxcbiAgICAgICAgbW9kZTogJ25vLWNvcnMnLFxuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgfTtcblxuICAgICAgLy8gRmV0Y2ggZGF0YSBmcm9tIGV4YW1wbGUuY29tXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMuc2V0dGluZ3MucmVmcmVzaFVSTCwgZmV0Y2hPcHRpb25zKTtcbiAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG5cbiAgICAgIC8vIFNob3cgdGhlIHJlc3BvbnNlIGluIGEgTm90aWNlXG4gICAgICBuZXcgTm90aWNlKGJvZHkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkdXJpbmcgb3BlcmF0aW9uOicsIGVycm9yKTtcbiAgICAgIG5ldyBOb3RpY2UoJ09wZXJhdGlvbiBmYWlsZWQ6ICcgKyBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cblxuXG5jbGFzcyBTdW5ldFNldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgcGx1Z2luOiBTdW5ldFBsdWdpbjtcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBTdW5ldFBsdWdpbikge1xuICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgfVxuXG4gIGRpc3BsYXkoKTogdm9pZCB7XG4gICAgY29uc3Qge2NvbnRhaW5lckVsfSA9IHRoaXM7XG5cbiAgICBjb250YWluZXJFbC5lbXB0eSgpO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZSgnU3RhZ2luZyBVUkwnKVxuICAgICAgLnNldERlc2MoJ1VSTCBvZiB0aGUgc3RhZ2luZyBzaXRlIGZvciBzdW5ldC5zZSwgZW5kaW5nIGluIC9yZWZyZXNoLWNvbnRlbnQnKVxuICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgIC5zZXRQbGFjZWhvbGRlcignaHR0cHM6Ly9zdGFnaW5nLnN1bmV0LnNlL3JlZnJlc2gtY29udGVudCcpXG4gICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZWZyZXNoVVJMKVxuICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucmVmcmVzaFVSTCA9IHZhbHVlO1xuICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICB9KSk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKCdTdGFnaW5nIFVzZXJuYW1lJylcbiAgICAgIC5zZXREZXNjKCdCYXNpYyBhdXRoIHVzZXJuYW1lIGZvciB0aGUgL3JlZnJlc2gtY29udGVudCBlbmRwb2ludCcpXG4gICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdlZGl0b3InKVxuICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucmVmcmVzaFVzZXJuYW1lKVxuICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucmVmcmVzaFVzZXJuYW1lID0gdmFsdWU7XG4gICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgIH0pKTtcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgLnNldE5hbWUoJ1N0YWdpbmcgcGFzc3dvcmQnKVxuICAgICAgLnNldERlc2MoJ0Jhc2ljIGF1dGggcGFzc3dvcmQgZm9yIHRoZSAvcmVmcmVzaC1jb250ZW50IGVuZHBvaW50JylcbiAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ2R1bW15JylcbiAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnJlZnJlc2hQYXNzd29yZClcbiAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnJlZnJlc2hQYXNzd29yZCA9IHZhbHVlO1xuICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICB9KSk7XG4gIH1cbn1cbiIsICJjb25zdCBjYWNoZSA9IG5ldyBXZWFrTWFwPFN0cmluZywgc3RyaW5nW10+KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRoc3BlYyguLi5wYXRoczogc3RyaW5nW10pIHtcbiAgIGNvbnN0IGtleSA9IG5ldyBTdHJpbmcocGF0aHMpO1xuICAgY2FjaGUuc2V0KGtleSwgcGF0aHMpO1xuXG4gICByZXR1cm4ga2V5IGFzIHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGF0aFNwZWMocGF0aDogc3RyaW5nIHwgdW5rbm93bik6IHBhdGggaXMgc3RyaW5nIHtcbiAgIHJldHVybiBwYXRoIGluc3RhbmNlb2YgU3RyaW5nICYmIGNhY2hlLmhhcyhwYXRoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvUGF0aHMocGF0aFNwZWM6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgIHJldHVybiBjYWNoZS5nZXQocGF0aFNwZWMpIHx8IFtdO1xufVxuIiwgImltcG9ydCB0eXBlIHsgU2ltcGxlR2l0VGFzayB9IGZyb20gJy4uL3R5cGVzJztcblxuLyoqXG4gKiBUaGUgYEdpdEVycm9yYCBpcyB0aHJvd24gd2hlbiB0aGUgdW5kZXJseWluZyBgZ2l0YCBwcm9jZXNzIHRocm93cyBhXG4gKiBmYXRhbCBleGNlcHRpb24gKGVnIGFuIGBFTk9FTlRgIGV4Y2VwdGlvbiB3aGVuIGF0dGVtcHRpbmcgdG8gdXNlIGFcbiAqIG5vbi13cml0YWJsZSBkaXJlY3RvcnkgYXMgdGhlIHJvb3QgZm9yIHlvdXIgcmVwbyksIGFuZCBhY3RzIGFzIHRoZVxuICogYmFzZSBjbGFzcyBmb3IgbW9yZSBzcGVjaWZpYyBlcnJvcnMgdGhyb3duIGJ5IHRoZSBwYXJzaW5nIG9mIHRoZVxuICogZ2l0IHJlc3BvbnNlIG9yIGVycm9ycyBpbiB0aGUgY29uZmlndXJhdGlvbiBvZiB0aGUgdGFzayBhYm91dCB0b1xuICogYmUgcnVuLlxuICpcbiAqIFdoZW4gYW4gZXhjZXB0aW9uIGlzIHRocm93biwgcGVuZGluZyB0YXNrcyBpbiB0aGUgc2FtZSBpbnN0YW5jZSB3aWxsXG4gKiBub3QgYmUgZXhlY3V0ZWQuIFRoZSByZWNvbW1lbmRlZCB3YXkgdG8gcnVuIGEgc2VyaWVzIG9mIHRhc2tzIHRoYXRcbiAqIGNhbiBpbmRlcGVuZGVudGx5IGZhaWwgd2l0aG91dCBuZWVkaW5nIHRvIHByZXZlbnQgZnV0dXJlIHRhc2tzIGZyb21cbiAqIHJ1bm5pbmcgaXMgdG8gY2F0Y2ggdGhlbSBpbmRpdmlkdWFsbHk6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuIGltcG9ydCB7IGdpdFAsIFNpbXBsZUdpdCwgR2l0RXJyb3IsIFB1bGxSZXN1bHQgfSBmcm9tICdzaW1wbGUtZ2l0JztcblxuIGZ1bmN0aW9uIGNhdGNoVGFzayAoZTogR2l0RXJyb3IpIHtcbiAgIHJldHVybiBlLlxuIH1cblxuIGNvbnN0IGdpdCA9IGdpdFAocmVwb1dvcmtpbmdEaXIpO1xuIGNvbnN0IHB1bGxlZDogUHVsbFJlc3VsdCB8IEdpdEVycm9yID0gYXdhaXQgZ2l0LnB1bGwoKS5jYXRjaChjYXRjaFRhc2spO1xuIGNvbnN0IHB1c2hlZDogc3RyaW5nIHwgR2l0RXJyb3IgPSBhd2FpdCBnaXQucHVzaFRhZ3MoKS5jYXRjaChjYXRjaFRhc2spO1xuIGBgYFxuICovXG5leHBvcnQgY2xhc3MgR2l0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyB0YXNrPzogU2ltcGxlR2l0VGFzazxhbnk+LFxuICAgICAgbWVzc2FnZT86IHN0cmluZ1xuICAgKSB7XG4gICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgR2l0RXJyb3IgfSBmcm9tICcuL2dpdC1lcnJvcic7XG5cbi8qKlxuICogVGhlIGBHaXRSZXNwb25zZUVycm9yYCBpcyB0aGUgd3JhcHBlciBmb3IgYSBwYXJzZWQgcmVzcG9uc2UgdGhhdCBpcyB0cmVhdGVkIGFzXG4gKiBhIGZhdGFsIGVycm9yLCBmb3IgZXhhbXBsZSBhdHRlbXB0aW5nIGEgYG1lcmdlYCBjYW4gbGVhdmUgdGhlIHJlcG8gaW4gYSBjb3JydXB0ZWRcbiAqIHN0YXRlIHdoZW4gdGhlcmUgYXJlIGNvbmZsaWN0cyBzbyB0aGUgdGFzayB3aWxsIHJlamVjdCByYXRoZXIgdGhhbiByZXNvbHZlLlxuICpcbiAqIEZvciBleGFtcGxlLCBjYXRjaGluZyB0aGUgbWVyZ2UgY29uZmxpY3QgZXhjZXB0aW9uOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiBpbXBvcnQgeyBnaXRQLCBTaW1wbGVHaXQsIEdpdFJlc3BvbnNlRXJyb3IsIE1lcmdlU3VtbWFyeSB9IGZyb20gJ3NpbXBsZS1naXQnO1xuXG4gY29uc3QgZ2l0ID0gZ2l0UChyZXBvUm9vdCk7XG4gY29uc3QgbWVyZ2VPcHRpb25zOiBzdHJpbmdbXSA9IFsnLS1uby1mZicsICdvdGhlci1icmFuY2gnXTtcbiBjb25zdCBtZXJnZVN1bW1hcnk6IE1lcmdlU3VtbWFyeSA9IGF3YWl0IGdpdC5tZXJnZShtZXJnZU9wdGlvbnMpXG4gICAgICAuY2F0Y2goKGU6IEdpdFJlc3BvbnNlRXJyb3I8TWVyZ2VTdW1tYXJ5PikgPT4gZS5naXQpO1xuXG4gaWYgKG1lcmdlU3VtbWFyeS5mYWlsZWQpIHtcbiAgIC8vIGRlYWwgd2l0aCB0aGUgZXJyb3JcbiB9XG4gYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBHaXRSZXNwb25zZUVycm9yPFQgPSBhbnk+IGV4dGVuZHMgR2l0RXJyb3Ige1xuICAgY29uc3RydWN0b3IoXG4gICAgICAvKipcbiAgICAgICAqIGAuZ2l0YCBhY2Nlc3MgdGhlIHBhcnNlZCByZXNwb25zZSB0aGF0IGlzIHRyZWF0ZWQgYXMgYmVpbmcgYW4gZXJyb3JcbiAgICAgICAqL1xuICAgICAgcHVibGljIHJlYWRvbmx5IGdpdDogVCxcbiAgICAgIG1lc3NhZ2U/OiBzdHJpbmdcbiAgICkge1xuICAgICAgc3VwZXIodW5kZWZpbmVkLCBtZXNzYWdlIHx8IFN0cmluZyhnaXQpKTtcbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBHaXRFcnJvciB9IGZyb20gJy4vZ2l0LWVycm9yJztcblxuLyoqXG4gKiBUaGUgYFRhc2tDb25maWd1cmF0aW9uRXJyb3JgIGlzIHRocm93biB3aGVuIGEgY29tbWFuZCB3YXMgaW5jb3JyZWN0bHlcbiAqIGNvbmZpZ3VyZWQuIEFuIGVycm9yIG9mIHRoaXMga2luZCBtZWFucyB0aGF0IG5vIGF0dGVtcHQgd2FzIG1hZGUgdG9cbiAqIHJ1biB5b3VyIGNvbW1hbmQgdGhyb3VnaCB0aGUgdW5kZXJseWluZyBgZ2l0YCBiaW5hcnkuXG4gKlxuICogQ2hlY2sgdGhlIGAubWVzc2FnZWAgcHJvcGVydHkgZm9yIG1vcmUgZGV0YWlsIG9uIHdoeSB5b3VyIGNvbmZpZ3VyYXRpb25cbiAqIHJlc3VsdGVkIGluIGFuIGVycm9yLlxuICovXG5leHBvcnQgY2xhc3MgVGFza0NvbmZpZ3VyYXRpb25FcnJvciBleHRlbmRzIEdpdEVycm9yIHtcbiAgIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgICAgIHN1cGVyKHVuZGVmaW5lZCwgbWVzc2FnZSk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgZXhpc3RzLCBGT0xERVIgfSBmcm9tICdAa3dzaXRlcy9maWxlLWV4aXN0cyc7XG5pbXBvcnQgeyBNYXliZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IE5VTEwgPSAnXFwwJztcblxuZXhwb3J0IGNvbnN0IE5PT1A6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCA9ICgpID0+IHt9O1xuXG4vKipcbiAqIFJldHVybnMgZWl0aGVyIHRoZSBzb3VyY2UgYXJndW1lbnQgd2hlbiBpdCBpcyBhIGBGdW5jdGlvbmAsIG9yIHRoZSBkZWZhdWx0XG4gKiBgTk9PUGAgZnVuY3Rpb24gY29uc3RhbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzRnVuY3Rpb248VCBleHRlbmRzICgpID0+IGFueT4oc291cmNlOiBUIHwgYW55KTogVCB7XG4gICByZXR1cm4gdHlwZW9mIHNvdXJjZSA9PT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZSA6IE5PT1A7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzdXBwbGllZCBhcmd1bWVudCBpcyBib3RoIGEgZnVuY3Rpb24sIGFuZCBpcyBub3RcbiAqIHRoZSBgTk9PUGAgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1VzZXJGdW5jdGlvbjxUIGV4dGVuZHMgRnVuY3Rpb24+KHNvdXJjZTogVCB8IGFueSk6IHNvdXJjZSBpcyBUIHtcbiAgIHJldHVybiB0eXBlb2Ygc291cmNlID09PSAnZnVuY3Rpb24nICYmIHNvdXJjZSAhPT0gTk9PUDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0T24oaW5wdXQ6IHN0cmluZywgY2hhcjogc3RyaW5nKTogW3N0cmluZywgc3RyaW5nXSB7XG4gICBjb25zdCBpbmRleCA9IGlucHV0LmluZGV4T2YoY2hhcik7XG4gICBpZiAoaW5kZXggPD0gMCkge1xuICAgICAgcmV0dXJuIFtpbnB1dCwgJyddO1xuICAgfVxuXG4gICByZXR1cm4gW2lucHV0LnN1YnN0cigwLCBpbmRleCksIGlucHV0LnN1YnN0cihpbmRleCArIDEpXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0PFQgZXh0ZW5kcyBhbnlbXT4oaW5wdXQ6IFQsIG9mZnNldD86IG51bWJlcik6IE1heWJlPFRbbnVtYmVyXT47XG5leHBvcnQgZnVuY3Rpb24gZmlyc3Q8VCBleHRlbmRzIElBcmd1bWVudHM+KGlucHV0OiBULCBvZmZzZXQ/OiBudW1iZXIpOiBNYXliZTx1bmtub3duPjtcbmV4cG9ydCBmdW5jdGlvbiBmaXJzdChpbnB1dDogYW55W10gfCBJQXJndW1lbnRzLCBvZmZzZXQgPSAwKTogTWF5YmU8dW5rbm93bj4ge1xuICAgcmV0dXJuIGlzQXJyYXlMaWtlKGlucHV0KSAmJiBpbnB1dC5sZW5ndGggPiBvZmZzZXQgPyBpbnB1dFtvZmZzZXRdIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGFzdDxUIGV4dGVuZHMgYW55W10+KGlucHV0OiBULCBvZmZzZXQ/OiBudW1iZXIpOiBNYXliZTxUW251bWJlcl0+O1xuZXhwb3J0IGZ1bmN0aW9uIGxhc3Q8VCBleHRlbmRzIElBcmd1bWVudHM+KGlucHV0OiBULCBvZmZzZXQ/OiBudW1iZXIpOiBNYXliZTx1bmtub3duPjtcbmV4cG9ydCBmdW5jdGlvbiBsYXN0PFQ+KGlucHV0OiBULCBvZmZzZXQ/OiBudW1iZXIpOiBNYXliZTx1bmtub3duPjtcbmV4cG9ydCBmdW5jdGlvbiBsYXN0KGlucHV0OiB1bmtub3duLCBvZmZzZXQgPSAwKSB7XG4gICBpZiAoaXNBcnJheUxpa2UoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA+IG9mZnNldCkge1xuICAgICAgcmV0dXJuIGlucHV0W2lucHV0Lmxlbmd0aCAtIDEgLSBvZmZzZXRdO1xuICAgfVxufVxuXG50eXBlIEFycmF5TGlrZTxUID0gYW55PiA9IFRbXSB8IElBcmd1bWVudHMgfCB7IFtpbmRleDogbnVtYmVyXTogVDsgbGVuZ3RoOiBudW1iZXIgfTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoaW5wdXQ6IGFueSk6IGlucHV0IGlzIEFycmF5TGlrZSB7XG4gICByZXR1cm4gISEoaW5wdXQgJiYgdHlwZW9mIGlucHV0Lmxlbmd0aCA9PT0gJ251bWJlcicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9MaW5lc1dpdGhDb250ZW50KGlucHV0ID0gJycsIHRyaW1tZWQgPSB0cnVlLCBzZXBhcmF0b3IgPSAnXFxuJyk6IHN0cmluZ1tdIHtcbiAgIHJldHVybiBpbnB1dC5zcGxpdChzZXBhcmF0b3IpLnJlZHVjZSgob3V0cHV0LCBsaW5lKSA9PiB7XG4gICAgICBjb25zdCBsaW5lQ29udGVudCA9IHRyaW1tZWQgPyBsaW5lLnRyaW0oKSA6IGxpbmU7XG4gICAgICBpZiAobGluZUNvbnRlbnQpIHtcbiAgICAgICAgIG91dHB1dC5wdXNoKGxpbmVDb250ZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICB9LCBbXSBhcyBzdHJpbmdbXSk7XG59XG5cbnR5cGUgTGluZVdpdGhDb250ZW50Q2FsbGJhY2s8VCA9IHZvaWQ+ID0gKGxpbmU6IHN0cmluZykgPT4gVDtcblxuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2hMaW5lV2l0aENvbnRlbnQ8VD4oXG4gICBpbnB1dDogc3RyaW5nLFxuICAgY2FsbGJhY2s6IExpbmVXaXRoQ29udGVudENhbGxiYWNrPFQ+XG4pOiBUW10ge1xuICAgcmV0dXJuIHRvTGluZXNXaXRoQ29udGVudChpbnB1dCwgdHJ1ZSkubWFwKChsaW5lKSA9PiBjYWxsYmFjayhsaW5lKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb2xkZXJFeGlzdHMocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICByZXR1cm4gZXhpc3RzKHBhdGgsIEZPTERFUik7XG59XG5cbi8qKlxuICogQWRkcyBgaXRlbWAgaW50byB0aGUgYHRhcmdldGAgYEFycmF5YCBvciBgU2V0YCB3aGVuIGl0IGlzIG5vdCBhbHJlYWR5IHByZXNlbnQgYW5kIHJldHVybnMgdGhlIGBpdGVtYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZDxUPih0YXJnZXQ6IFRbXSB8IFNldDxUPiwgaXRlbTogVCk6IHR5cGVvZiBpdGVtIHtcbiAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgIGlmICghdGFyZ2V0LmluY2x1ZGVzKGl0ZW0pKSB7XG4gICAgICAgICB0YXJnZXQucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQuYWRkKGl0ZW0pO1xuICAgfVxuICAgcmV0dXJuIGl0ZW07XG59XG5cbi8qKlxuICogQWRkcyBgaXRlbWAgaW50byB0aGUgYHRhcmdldGAgYEFycmF5YCB3aGVuIGl0IGlzIG5vdCBhbHJlYWR5IHByZXNlbnQgYW5kIHJldHVybnMgdGhlIGB0YXJnZXRgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5jbHVkaW5nPFQ+KHRhcmdldDogVFtdLCBpdGVtOiBUKTogdHlwZW9mIHRhcmdldCB7XG4gICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmICF0YXJnZXQuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgIHRhcmdldC5wdXNoKGl0ZW0pO1xuICAgfVxuXG4gICByZXR1cm4gdGFyZ2V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlPFQ+KHRhcmdldDogU2V0PFQ+IHwgVFtdLCBpdGVtOiBUKTogVCB7XG4gICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRhcmdldC5pbmRleE9mKGl0ZW0pO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgIHRhcmdldC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5kZWxldGUoaXRlbSk7XG4gICB9XG4gICByZXR1cm4gaXRlbTtcbn1cblxuZXhwb3J0IGNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgYXMgKFxuICAgaW5wdXQ6IGFueVxuKSA9PiBzdHJpbmc7XG5cbmV4cG9ydCBmdW5jdGlvbiBhc0FycmF5PFQ+KHNvdXJjZTogVCB8IFRbXSk6IFRbXSB7XG4gICByZXR1cm4gQXJyYXkuaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogW3NvdXJjZV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc1N0cmluZ0FycmF5PFQ+KHNvdXJjZTogVCB8IFRbXSk6IHN0cmluZ1tdIHtcbiAgIHJldHVybiBhc0FycmF5KHNvdXJjZSkubWFwKFN0cmluZyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc051bWJlcihzb3VyY2U6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQsIG9uTmFOID0gMCkge1xuICAgaWYgKHNvdXJjZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gb25OYU47XG4gICB9XG5cbiAgIGNvbnN0IG51bSA9IHBhcnNlSW50KHNvdXJjZSwgMTApO1xuICAgcmV0dXJuIGlzTmFOKG51bSkgPyBvbk5hTiA6IG51bTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByZWZpeGVkQXJyYXk8VD4oaW5wdXQ6IFRbXSwgcHJlZml4OiBUKTogVFtdIHtcbiAgIGNvbnN0IG91dHB1dDogVFtdID0gW107XG4gICBmb3IgKGxldCBpID0gMCwgbWF4ID0gaW5wdXQubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgIG91dHB1dC5wdXNoKHByZWZpeCwgaW5wdXRbaV0pO1xuICAgfVxuICAgcmV0dXJuIG91dHB1dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlclRvU3RyaW5nKGlucHV0OiBCdWZmZXIgfCBCdWZmZXJbXSk6IHN0cmluZyB7XG4gICByZXR1cm4gKEFycmF5LmlzQXJyYXkoaW5wdXQpID8gQnVmZmVyLmNvbmNhdChpbnB1dCkgOiBpbnB1dCkudG9TdHJpbmcoJ3V0Zi04Jyk7XG59XG5cbi8qKlxuICogR2V0IGEgbmV3IG9iamVjdCBmcm9tIGEgc291cmNlIG9iamVjdCB3aXRoIG9ubHkgdGhlIGxpc3RlZCBwcm9wZXJ0aWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGljayhzb3VyY2U6IFJlY29yZDxzdHJpbmcsIGFueT4sIHByb3BlcnRpZXM6IHN0cmluZ1tdKSB7XG4gICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgIHt9LFxuICAgICAgLi4ucHJvcGVydGllcy5tYXAoKHByb3BlcnR5KSA9PiAocHJvcGVydHkgaW4gc291cmNlID8geyBbcHJvcGVydHldOiBzb3VyY2VbcHJvcGVydHldIH0gOiB7fSkpXG4gICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsYXkoZHVyYXRpb24gPSAwKTogUHJvbWlzZTx2b2lkPiB7XG4gICByZXR1cm4gbmV3IFByb21pc2UoKGRvbmUpID0+IHNldFRpbWVvdXQoZG9uZSwgZHVyYXRpb24pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9yVm9pZDxUPihpbnB1dDogVCB8IGZhbHNlKSB7XG4gICBpZiAoaW5wdXQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgfVxuICAgcmV0dXJuIGlucHV0O1xufVxuIiwgImltcG9ydCB7IE1heWJlLCBPcHRpb25zLCBQcmltaXRpdmVzIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgb2JqZWN0VG9TdHJpbmcgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgaXNQYXRoU3BlYyB9IGZyb20gJy4uL2FyZ3MvcGF0aHNwZWMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEFyZ3VtZW50RmlsdGVyUHJlZGljYXRlPFQ+IHtcbiAgIChpbnB1dDogYW55KTogaW5wdXQgaXMgVDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlclR5cGU8VCwgSz4oXG4gICBpbnB1dDogSyxcbiAgIGZpbHRlcjogQXJndW1lbnRGaWx0ZXJQcmVkaWNhdGU8VD5cbik6IEsgZXh0ZW5kcyBUID8gVCA6IHVuZGVmaW5lZDtcbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJUeXBlPFQsIEs+KGlucHV0OiBLLCBmaWx0ZXI6IEFyZ3VtZW50RmlsdGVyUHJlZGljYXRlPFQ+LCBkZWY6IFQpOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlclR5cGU8VCwgSz4oaW5wdXQ6IEssIGZpbHRlcjogQXJndW1lbnRGaWx0ZXJQcmVkaWNhdGU8VD4sIGRlZj86IFQpOiBNYXliZTxUPiB7XG4gICBpZiAoZmlsdGVyKGlucHV0KSkge1xuICAgICAgcmV0dXJuIGlucHV0O1xuICAgfVxuICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gZGVmIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgY29uc3QgZmlsdGVyQXJyYXk6IEFyZ3VtZW50RmlsdGVyUHJlZGljYXRlPEFycmF5PGFueT4+ID0gKGlucHV0KTogaW5wdXQgaXMgQXJyYXk8YW55PiA9PiB7XG4gICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dCk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyUHJpbWl0aXZlcyhcbiAgIGlucHV0OiB1bmtub3duLFxuICAgb21pdD86IEFycmF5PCdib29sZWFuJyB8ICdzdHJpbmcnIHwgJ251bWJlcic+XG4pOiBpbnB1dCBpcyBQcmltaXRpdmVzIHtcbiAgIGNvbnN0IHR5cGUgPSBpc1BhdGhTcGVjKGlucHV0KSA/ICdzdHJpbmcnIDogdHlwZW9mIGlucHV0O1xuXG4gICByZXR1cm4gKFxuICAgICAgL251bWJlcnxzdHJpbmd8Ym9vbGVhbi8udGVzdCh0eXBlKSAmJlxuICAgICAgKCFvbWl0IHx8ICFvbWl0LmluY2x1ZGVzKHR5cGUgYXMgJ2Jvb2xlYW4nIHwgJ3N0cmluZycgfCAnbnVtYmVyJykpXG4gICApO1xufVxuXG5leHBvcnQgY29uc3QgZmlsdGVyU3RyaW5nOiBBcmd1bWVudEZpbHRlclByZWRpY2F0ZTxzdHJpbmc+ID0gKGlucHV0KTogaW5wdXQgaXMgc3RyaW5nID0+IHtcbiAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnO1xufTtcblxuZXhwb3J0IGNvbnN0IGZpbHRlclN0cmluZ0FycmF5OiBBcmd1bWVudEZpbHRlclByZWRpY2F0ZTxzdHJpbmdbXT4gPSAoaW5wdXQpOiBpbnB1dCBpcyBzdHJpbmdbXSA9PiB7XG4gICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dCkgJiYgaW5wdXQuZXZlcnkoZmlsdGVyU3RyaW5nKTtcbn07XG5cbmV4cG9ydCBjb25zdCBmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5OiBBcmd1bWVudEZpbHRlclByZWRpY2F0ZTxzdHJpbmcgfCBzdHJpbmdbXT4gPSAoXG4gICBpbnB1dFxuKTogaW5wdXQgaXMgc3RyaW5nIHwgc3RyaW5nW10gPT4ge1xuICAgcmV0dXJuIGZpbHRlclN0cmluZyhpbnB1dCkgfHwgKEFycmF5LmlzQXJyYXkoaW5wdXQpICYmIGlucHV0LmV2ZXJ5KGZpbHRlclN0cmluZykpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlclBsYWluT2JqZWN0PFQgZXh0ZW5kcyBPcHRpb25zPihpbnB1dDogVCB8IHVua25vd24pOiBpbnB1dCBpcyBUO1xuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlclBsYWluT2JqZWN0PFQgZXh0ZW5kcyBPYmplY3Q+KGlucHV0OiBUIHwgdW5rbm93bik6IGlucHV0IGlzIFQge1xuICAgcmV0dXJuICEhaW5wdXQgJiYgb2JqZWN0VG9TdHJpbmcoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlckZ1bmN0aW9uKGlucHV0OiB1bmtub3duKTogaW5wdXQgaXMgRnVuY3Rpb24ge1xuICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IGNvbnN0IGZpbHRlckhhc0xlbmd0aDogQXJndW1lbnRGaWx0ZXJQcmVkaWNhdGU8eyBsZW5ndGg6IG51bWJlciB9PiA9IChcbiAgIGlucHV0XG4pOiBpbnB1dCBpcyB7IGxlbmd0aDogbnVtYmVyIH0gPT4ge1xuICAgaWYgKGlucHV0ID09IG51bGwgfHwgJ251bWJlcnxib29sZWFufGZ1bmN0aW9uJy5pbmNsdWRlcyh0eXBlb2YgaW5wdXQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICB9XG4gICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgaW5wdXQubGVuZ3RoID09PSAnbnVtYmVyJztcbn07XG4iLCAiLyoqXG4gKiBLbm93biBwcm9jZXNzIGV4aXQgY29kZXMgdXNlZCBieSB0aGUgdGFzayBwYXJzZXJzIHRvIGRldGVybWluZSB3aGV0aGVyIGFuIGVycm9yXG4gKiB3YXMgb25lIHRoZXkgY2FuIGF1dG9tYXRpY2FsbHkgaGFuZGxlXG4gKi9cbmV4cG9ydCBlbnVtIEV4aXRDb2RlcyB7XG4gICBTVUNDRVNTLFxuICAgRVJST1IsXG4gICBOT1RfRk9VTkQgPSAtMixcbiAgIFVOQ0xFQU4gPSAxMjgsXG59XG4iLCAiaW1wb3J0IHsgVGFza1Jlc3BvbnNlRm9ybWF0IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgR2l0T3V0cHV0U3RyZWFtczxUIGV4dGVuZHMgVGFza1Jlc3BvbnNlRm9ybWF0ID0gQnVmZmVyPiB7XG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyByZWFkb25seSBzdGRPdXQ6IFQsXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgc3RkRXJyOiBUXG4gICApIHt9XG5cbiAgIGFzU3RyaW5ncygpOiBHaXRPdXRwdXRTdHJlYW1zPHN0cmluZz4ge1xuICAgICAgcmV0dXJuIG5ldyBHaXRPdXRwdXRTdHJlYW1zKHRoaXMuc3RkT3V0LnRvU3RyaW5nKCd1dGY4JyksIHRoaXMuc3RkRXJyLnRvU3RyaW5nKCd1dGY4JykpO1xuICAgfVxufVxuIiwgImV4cG9ydCBjbGFzcyBMaW5lUGFyc2VyPFQ+IHtcbiAgIHByb3RlY3RlZCBtYXRjaGVzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICBwcml2YXRlIF9yZWdFeHA6IFJlZ0V4cFtdO1xuXG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHJlZ0V4cDogUmVnRXhwIHwgUmVnRXhwW10sXG4gICAgICB1c2VNYXRjaGVzPzogKHRhcmdldDogVCwgbWF0Y2g6IHN0cmluZ1tdKSA9PiBib29sZWFuIHwgdm9pZFxuICAgKSB7XG4gICAgICB0aGlzLl9yZWdFeHAgPSBBcnJheS5pc0FycmF5KHJlZ0V4cCkgPyByZWdFeHAgOiBbcmVnRXhwXTtcbiAgICAgIGlmICh1c2VNYXRjaGVzKSB7XG4gICAgICAgICB0aGlzLnVzZU1hdGNoZXMgPSB1c2VNYXRjaGVzO1xuICAgICAgfVxuICAgfVxuXG4gICBwYXJzZSA9IChsaW5lOiAob2Zmc2V0OiBudW1iZXIpID0+IHN0cmluZyB8IHVuZGVmaW5lZCwgdGFyZ2V0OiBUKTogYm9vbGVhbiA9PiB7XG4gICAgICB0aGlzLnJlc2V0TWF0Y2hlcygpO1xuXG4gICAgICBpZiAoIXRoaXMuX3JlZ0V4cC5ldmVyeSgocmVnLCBpbmRleCkgPT4gdGhpcy5hZGRNYXRjaChyZWcsIGluZGV4LCBsaW5lKGluZGV4KSkpKSB7XG4gICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnVzZU1hdGNoZXModGFyZ2V0LCB0aGlzLnByZXBhcmVNYXRjaGVzKCkpICE9PSBmYWxzZTtcbiAgIH07XG5cbiAgIC8vIEB0cy1pZ25vcmVcbiAgIHByb3RlY3RlZCB1c2VNYXRjaGVzKHRhcmdldDogVCwgbWF0Y2g6IHN0cmluZ1tdKTogYm9vbGVhbiB8IHZvaWQge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5lUGFyc2VyOnVzZU1hdGNoZXMgbm90IGltcGxlbWVudGVkYCk7XG4gICB9XG5cbiAgIHByb3RlY3RlZCByZXNldE1hdGNoZXMoKSB7XG4gICAgICB0aGlzLm1hdGNoZXMubGVuZ3RoID0gMDtcbiAgIH1cblxuICAgcHJvdGVjdGVkIHByZXBhcmVNYXRjaGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWF0Y2hlcztcbiAgIH1cblxuICAgcHJvdGVjdGVkIGFkZE1hdGNoKHJlZzogUmVnRXhwLCBpbmRleDogbnVtYmVyLCBsaW5lPzogc3RyaW5nKSB7XG4gICAgICBjb25zdCBtYXRjaGVkID0gbGluZSAmJiByZWcuZXhlYyhsaW5lKTtcbiAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICB0aGlzLnB1c2hNYXRjaChpbmRleCwgbWF0Y2hlZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhIW1hdGNoZWQ7XG4gICB9XG5cbiAgIHByb3RlY3RlZCBwdXNoTWF0Y2goX2luZGV4OiBudW1iZXIsIG1hdGNoZWQ6IHN0cmluZ1tdKSB7XG4gICAgICB0aGlzLm1hdGNoZXMucHVzaCguLi5tYXRjaGVkLnNsaWNlKDEpKTtcbiAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlbW90ZUxpbmVQYXJzZXI8VD4gZXh0ZW5kcyBMaW5lUGFyc2VyPFQ+IHtcbiAgIHByb3RlY3RlZCBhZGRNYXRjaChyZWc6IFJlZ0V4cCwgaW5kZXg6IG51bWJlciwgbGluZT86IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIC9ecmVtb3RlOlxccy8udGVzdChTdHJpbmcobGluZSkpICYmIHN1cGVyLmFkZE1hdGNoKHJlZywgaW5kZXgsIGxpbmUpO1xuICAgfVxuXG4gICBwcm90ZWN0ZWQgcHVzaE1hdGNoKGluZGV4OiBudW1iZXIsIG1hdGNoZWQ6IHN0cmluZ1tdKSB7XG4gICAgICBpZiAoaW5kZXggPiAwIHx8IG1hdGNoZWQubGVuZ3RoID4gMSkge1xuICAgICAgICAgc3VwZXIucHVzaE1hdGNoKGluZGV4LCBtYXRjaGVkKTtcbiAgICAgIH1cbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBTaW1wbGVHaXRPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9uczogT21pdDxTaW1wbGVHaXRPcHRpb25zLCAnYmFzZURpcic+ID0ge1xuICAgYmluYXJ5OiAnZ2l0JyxcbiAgIG1heENvbmN1cnJlbnRQcm9jZXNzZXM6IDUsXG4gICBjb25maWc6IFtdLFxuICAgdHJpbW1lZDogZmFsc2UsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VDb25maWcoXG4gICAuLi5vcHRpb25zOiBBcnJheTxQYXJ0aWFsPFNpbXBsZUdpdE9wdGlvbnM+IHwgdW5kZWZpbmVkPlxuKTogU2ltcGxlR2l0T3B0aW9ucyB7XG4gICBjb25zdCBiYXNlRGlyID0gcHJvY2Vzcy5jd2QoKTtcbiAgIGNvbnN0IGNvbmZpZzogU2ltcGxlR2l0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7IGJhc2VEaXIsIC4uLmRlZmF1bHRPcHRpb25zIH0sXG4gICAgICAuLi5vcHRpb25zLmZpbHRlcigobykgPT4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIG8pXG4gICApO1xuXG4gICBjb25maWcuYmFzZURpciA9IGNvbmZpZy5iYXNlRGlyIHx8IGJhc2VEaXI7XG4gICBjb25maWcudHJpbW1lZCA9IGNvbmZpZy50cmltbWVkID09PSB0cnVlO1xuXG4gICByZXR1cm4gY29uZmlnO1xufVxuIiwgImltcG9ydCB7XG4gICBmaWx0ZXJBcnJheSxcbiAgIGZpbHRlckZ1bmN0aW9uLFxuICAgZmlsdGVyUGxhaW5PYmplY3QsXG4gICBmaWx0ZXJQcmltaXRpdmVzLFxuICAgZmlsdGVyVHlwZSxcbn0gZnJvbSAnLi9hcmd1bWVudC1maWx0ZXJzJztcbmltcG9ydCB7IGFzRnVuY3Rpb24sIGlzVXNlckZ1bmN0aW9uLCBsYXN0IH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IE1heWJlLCBPcHRpb25zLCBPcHRpb25zVmFsdWVzIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgaXNQYXRoU3BlYyB9IGZyb20gJy4uL2FyZ3MvcGF0aHNwZWMnO1xuXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kVGFza09wdGlvbnM8VCBleHRlbmRzIE9wdGlvbnMgPSBPcHRpb25zPihcbiAgIG9wdGlvbnM6IE1heWJlPFQ+LFxuICAgY29tbWFuZHM6IHN0cmluZ1tdID0gW11cbik6IHN0cmluZ1tdIHtcbiAgIGlmICghZmlsdGVyUGxhaW5PYmplY3Q8T3B0aW9ucz4ob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBjb21tYW5kcztcbiAgIH1cblxuICAgcmV0dXJuIE9iamVjdC5rZXlzKG9wdGlvbnMpLnJlZHVjZSgoY29tbWFuZHM6IHN0cmluZ1tdLCBrZXk6IHN0cmluZykgPT4ge1xuICAgICAgY29uc3QgdmFsdWU6IE9wdGlvbnNWYWx1ZXMgPSBvcHRpb25zW2tleV07XG5cbiAgICAgIGlmIChpc1BhdGhTcGVjKHZhbHVlKSkge1xuICAgICAgICAgY29tbWFuZHMucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGZpbHRlclByaW1pdGl2ZXModmFsdWUsIFsnYm9vbGVhbiddKSkge1xuICAgICAgICAgY29tbWFuZHMucHVzaChrZXkgKyAnPScgKyB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgY29tbWFuZHMucHVzaChrZXkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29tbWFuZHM7XG4gICB9LCBjb21tYW5kcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFpbGluZ09wdGlvbnMoXG4gICBhcmdzOiBJQXJndW1lbnRzLFxuICAgaW5pdGlhbFByaW1pdGl2ZSA9IDAsXG4gICBvYmplY3RPbmx5ID0gZmFsc2Vcbik6IHN0cmluZ1tdIHtcbiAgIGNvbnN0IGNvbW1hbmQ6IHN0cmluZ1tdID0gW107XG5cbiAgIGZvciAobGV0IGkgPSAwLCBtYXggPSBpbml0aWFsUHJpbWl0aXZlIDwgMCA/IGFyZ3MubGVuZ3RoIDogaW5pdGlhbFByaW1pdGl2ZTsgaSA8IG1heDsgaSsrKSB7XG4gICAgICBpZiAoJ3N0cmluZ3xudW1iZXInLmluY2x1ZGVzKHR5cGVvZiBhcmdzW2ldKSkge1xuICAgICAgICAgY29tbWFuZC5wdXNoKFN0cmluZyhhcmdzW2ldKSk7XG4gICAgICB9XG4gICB9XG5cbiAgIGFwcGVuZFRhc2tPcHRpb25zKHRyYWlsaW5nT3B0aW9uc0FyZ3VtZW50KGFyZ3MpLCBjb21tYW5kKTtcbiAgIGlmICghb2JqZWN0T25seSkge1xuICAgICAgY29tbWFuZC5wdXNoKC4uLnRyYWlsaW5nQXJyYXlBcmd1bWVudChhcmdzKSk7XG4gICB9XG5cbiAgIHJldHVybiBjb21tYW5kO1xufVxuXG5mdW5jdGlvbiB0cmFpbGluZ0FycmF5QXJndW1lbnQoYXJnczogSUFyZ3VtZW50cykge1xuICAgY29uc3QgaGFzVHJhaWxpbmdDYWxsYmFjayA9IHR5cGVvZiBsYXN0KGFyZ3MpID09PSAnZnVuY3Rpb24nO1xuICAgcmV0dXJuIGZpbHRlclR5cGUobGFzdChhcmdzLCBoYXNUcmFpbGluZ0NhbGxiYWNrID8gMSA6IDApLCBmaWx0ZXJBcnJheSwgW10pO1xufVxuXG4vKipcbiAqIEdpdmVuIGFueSBudW1iZXIgb2YgYXJndW1lbnRzLCByZXR1cm5zIHRoZSB0cmFpbGluZyBvcHRpb25zIGFyZ3VtZW50LCBpZ25vcmluZyBhIHRyYWlsaW5nIGZ1bmN0aW9uIGFyZ3VtZW50XG4gKiBpZiB0aGVyZSBpcyBvbmUuIFdoZW4gbm90IGZvdW5kLCB0aGUgcmV0dXJuIHZhbHVlIGlzIG51bGwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFpbGluZ09wdGlvbnNBcmd1bWVudChhcmdzOiBJQXJndW1lbnRzKTogTWF5YmU8T3B0aW9ucz4ge1xuICAgY29uc3QgaGFzVHJhaWxpbmdDYWxsYmFjayA9IGZpbHRlckZ1bmN0aW9uKGxhc3QoYXJncykpO1xuICAgcmV0dXJuIGZpbHRlclR5cGUobGFzdChhcmdzLCBoYXNUcmFpbGluZ0NhbGxiYWNrID8gMSA6IDApLCBmaWx0ZXJQbGFpbk9iamVjdCk7XG59XG5cbi8qKlxuICogUmV0dXJucyBlaXRoZXIgdGhlIHNvdXJjZSBhcmd1bWVudCB3aGVuIGl0IGlzIGEgYEZ1bmN0aW9uYCwgb3IgdGhlIGRlZmF1bHRcbiAqIGBOT09QYCBmdW5jdGlvbiBjb25zdGFudFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KFxuICAgYXJnczogdW5rbm93bltdIHwgSUFyZ3VtZW50cyB8IHVua25vd24sXG4gICBpbmNsdWRlTm9vcCA9IHRydWVcbik6IE1heWJlPCguLi5hcmdzOiBhbnlbXSkgPT4gdW5rbm93bj4ge1xuICAgY29uc3QgY2FsbGJhY2sgPSBhc0Z1bmN0aW9uKGxhc3QoYXJncykpO1xuICAgcmV0dXJuIGluY2x1ZGVOb29wIHx8IGlzVXNlckZ1bmN0aW9uKGNhbGxiYWNrKSA/IGNhbGxiYWNrIDogdW5kZWZpbmVkO1xufVxuIiwgImltcG9ydCB0eXBlIHsgTWF5YmVBcnJheSwgVGFza1BhcnNlciwgVGFza1Jlc3BvbnNlRm9ybWF0IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgR2l0T3V0cHV0U3RyZWFtcyB9IGZyb20gJy4vZ2l0LW91dHB1dC1zdHJlYW1zJztcbmltcG9ydCB7IExpbmVQYXJzZXIgfSBmcm9tICcuL2xpbmUtcGFyc2VyJztcbmltcG9ydCB7IGFzQXJyYXksIHRvTGluZXNXaXRoQ29udGVudCB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxsVGFza1BhcnNlcjxJTlBVVCBleHRlbmRzIFRhc2tSZXNwb25zZUZvcm1hdCwgUkVTUE9OU0U+KFxuICAgcGFyc2VyOiBUYXNrUGFyc2VyPElOUFVULCBSRVNQT05TRT4sXG4gICBzdHJlYW1zOiBHaXRPdXRwdXRTdHJlYW1zPElOUFVUPlxuKSB7XG4gICByZXR1cm4gcGFyc2VyKHN0cmVhbXMuc3RkT3V0LCBzdHJlYW1zLnN0ZEVycik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVN0cmluZ1Jlc3BvbnNlPFQ+KFxuICAgcmVzdWx0OiBULFxuICAgcGFyc2VyczogTGluZVBhcnNlcjxUPltdLFxuICAgdGV4dHM6IE1heWJlQXJyYXk8c3RyaW5nPixcbiAgIHRyaW0gPSB0cnVlXG4pOiBUIHtcbiAgIGFzQXJyYXkodGV4dHMpLmZvckVhY2goKHRleHQpID0+IHtcbiAgICAgIGZvciAobGV0IGxpbmVzID0gdG9MaW5lc1dpdGhDb250ZW50KHRleHQsIHRyaW0pLCBpID0gMCwgbWF4ID0gbGluZXMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgIGNvbnN0IGxpbmUgPSAob2Zmc2V0ID0gMCkgPT4ge1xuICAgICAgICAgICAgaWYgKGkgKyBvZmZzZXQgPj0gbWF4KSB7XG4gICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGluZXNbaSArIG9mZnNldF07XG4gICAgICAgICB9O1xuXG4gICAgICAgICBwYXJzZXJzLnNvbWUoKHsgcGFyc2UgfSkgPT4gcGFyc2UobGluZSwgcmVzdWx0KSk7XG4gICAgICB9XG4gICB9KTtcblxuICAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsICJleHBvcnQgKiBmcm9tICcuL2FyZ3VtZW50LWZpbHRlcnMnO1xuZXhwb3J0ICogZnJvbSAnLi9leGl0LWNvZGVzJztcbmV4cG9ydCAqIGZyb20gJy4vZ2l0LW91dHB1dC1zdHJlYW1zJztcbmV4cG9ydCAqIGZyb20gJy4vbGluZS1wYXJzZXInO1xuZXhwb3J0ICogZnJvbSAnLi9zaW1wbGUtZ2l0LW9wdGlvbnMnO1xuZXhwb3J0ICogZnJvbSAnLi90YXNrLW9wdGlvbnMnO1xuZXhwb3J0ICogZnJvbSAnLi90YXNrLXBhcnNlcic7XG5leHBvcnQgKiBmcm9tICcuL3V0aWwnO1xuIiwgImltcG9ydCB7IEV4aXRDb2RlcyB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IE1heWJlLCBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZW51bSBDaGVja1JlcG9BY3Rpb25zIHtcbiAgIEJBUkUgPSAnYmFyZScsXG4gICBJTl9UUkVFID0gJ3RyZWUnLFxuICAgSVNfUkVQT19ST09UID0gJ3Jvb3QnLFxufVxuXG5jb25zdCBvbkVycm9yOiBTdHJpbmdUYXNrPGJvb2xlYW4+WydvbkVycm9yJ10gPSAoeyBleGl0Q29kZSB9LCBlcnJvciwgZG9uZSwgZmFpbCkgPT4ge1xuICAgaWYgKGV4aXRDb2RlID09PSBFeGl0Q29kZXMuVU5DTEVBTiAmJiBpc05vdFJlcG9NZXNzYWdlKGVycm9yKSkge1xuICAgICAgcmV0dXJuIGRvbmUoQnVmZmVyLmZyb20oJ2ZhbHNlJykpO1xuICAgfVxuXG4gICBmYWlsKGVycm9yKTtcbn07XG5cbmNvbnN0IHBhcnNlcjogU3RyaW5nVGFzazxib29sZWFuPlsncGFyc2VyJ10gPSAodGV4dCkgPT4ge1xuICAgcmV0dXJuIHRleHQudHJpbSgpID09PSAndHJ1ZSc7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tJc1JlcG9UYXNrKGFjdGlvbjogTWF5YmU8Q2hlY2tSZXBvQWN0aW9ucz4pOiBTdHJpbmdUYXNrPGJvb2xlYW4+IHtcbiAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICBjYXNlIENoZWNrUmVwb0FjdGlvbnMuQkFSRTpcbiAgICAgICAgIHJldHVybiBjaGVja0lzQmFyZVJlcG9UYXNrKCk7XG4gICAgICBjYXNlIENoZWNrUmVwb0FjdGlvbnMuSVNfUkVQT19ST09UOlxuICAgICAgICAgcmV0dXJuIGNoZWNrSXNSZXBvUm9vdFRhc2soKTtcbiAgIH1cblxuICAgY29uc3QgY29tbWFuZHMgPSBbJ3Jldi1wYXJzZScsICctLWlzLWluc2lkZS13b3JrLXRyZWUnXTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgb25FcnJvcixcbiAgICAgIHBhcnNlcixcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0lzUmVwb1Jvb3RUYXNrKCk6IFN0cmluZ1Rhc2s8Ym9vbGVhbj4ge1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ3Jldi1wYXJzZScsICctLWdpdC1kaXInXTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgb25FcnJvcixcbiAgICAgIHBhcnNlcihwYXRoKSB7XG4gICAgICAgICByZXR1cm4gL15cXC4oZ2l0KT8kLy50ZXN0KHBhdGgudHJpbSgpKTtcbiAgICAgIH0sXG4gICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tJc0JhcmVSZXBvVGFzaygpOiBTdHJpbmdUYXNrPGJvb2xlYW4+IHtcbiAgIGNvbnN0IGNvbW1hbmRzID0gWydyZXYtcGFyc2UnLCAnLS1pcy1iYXJlLXJlcG9zaXRvcnknXTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgb25FcnJvcixcbiAgICAgIHBhcnNlcixcbiAgIH07XG59XG5cbmZ1bmN0aW9uIGlzTm90UmVwb01lc3NhZ2UoZXJyb3I6IEVycm9yKTogYm9vbGVhbiB7XG4gICByZXR1cm4gLyhOb3QgYSBnaXQgcmVwb3NpdG9yeXxLZWluIEdpdC1SZXBvc2l0b3J5KS9pLnRlc3QoU3RyaW5nKGVycm9yKSk7XG59XG4iLCAiaW1wb3J0IHsgQ2xlYW5TdW1tYXJ5IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyB0b0xpbmVzV2l0aENvbnRlbnQgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBDbGVhblJlc3BvbnNlIGltcGxlbWVudHMgQ2xlYW5TdW1tYXJ5IHtcbiAgIHB1YmxpYyBwYXRoczogc3RyaW5nW10gPSBbXTtcbiAgIHB1YmxpYyBmaWxlczogc3RyaW5nW10gPSBbXTtcbiAgIHB1YmxpYyBmb2xkZXJzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgZHJ5UnVuOiBib29sZWFuKSB7fVxufVxuXG5jb25zdCByZW1vdmFsUmVnZXhwID0gL15bYS16XStcXHMqL2k7XG5jb25zdCBkcnlSdW5SZW1vdmFsUmVnZXhwID0gL15bYS16XStcXHMrW2Etel0rXFxzKi9pO1xuY29uc3QgaXNGb2xkZXJSZWdleHAgPSAvXFwvJC87XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhblN1bW1hcnlQYXJzZXIoZHJ5UnVuOiBib29sZWFuLCB0ZXh0OiBzdHJpbmcpOiBDbGVhblN1bW1hcnkge1xuICAgY29uc3Qgc3VtbWFyeSA9IG5ldyBDbGVhblJlc3BvbnNlKGRyeVJ1bik7XG4gICBjb25zdCByZWdleHAgPSBkcnlSdW4gPyBkcnlSdW5SZW1vdmFsUmVnZXhwIDogcmVtb3ZhbFJlZ2V4cDtcblxuICAgdG9MaW5lc1dpdGhDb250ZW50KHRleHQpLmZvckVhY2goKGxpbmUpID0+IHtcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSBsaW5lLnJlcGxhY2UocmVnZXhwLCAnJyk7XG5cbiAgICAgIHN1bW1hcnkucGF0aHMucHVzaChyZW1vdmVkKTtcbiAgICAgIChpc0ZvbGRlclJlZ2V4cC50ZXN0KHJlbW92ZWQpID8gc3VtbWFyeS5mb2xkZXJzIDogc3VtbWFyeS5maWxlcykucHVzaChyZW1vdmVkKTtcbiAgIH0pO1xuXG4gICByZXR1cm4gc3VtbWFyeTtcbn1cbiIsICJpbXBvcnQgeyBUYXNrQ29uZmlndXJhdGlvbkVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL3Rhc2stY29uZmlndXJhdGlvbi1lcnJvcic7XG5pbXBvcnQgdHlwZSB7IEJ1ZmZlclRhc2ssIEVtcHR5VGFza1BhcnNlciwgU2ltcGxlR2l0VGFzaywgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IEVNUFRZX0NPTU1BTkRTOiBbXSA9IFtdO1xuXG5leHBvcnQgdHlwZSBFbXB0eVRhc2sgPSB7XG4gICBjb21tYW5kczogdHlwZW9mIEVNUFRZX0NPTU1BTkRTO1xuICAgZm9ybWF0OiAnZW1wdHknO1xuICAgcGFyc2VyOiBFbXB0eVRhc2tQYXJzZXI7XG4gICBvbkVycm9yPzogdW5kZWZpbmVkO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFkaG9jRXhlY1Rhc2socGFyc2VyOiBFbXB0eVRhc2tQYXJzZXIpOiBFbXB0eVRhc2sge1xuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzOiBFTVBUWV9DT01NQU5EUyxcbiAgICAgIGZvcm1hdDogJ2VtcHR5JyxcbiAgICAgIHBhcnNlcixcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKGVycm9yOiBFcnJvciB8IHN0cmluZyk6IEVtcHR5VGFzayB7XG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHM6IEVNUFRZX0NPTU1BTkRTLFxuICAgICAgZm9ybWF0OiAnZW1wdHknLFxuICAgICAgcGFyc2VyKCkge1xuICAgICAgICAgdGhyb3cgdHlwZW9mIGVycm9yID09PSAnc3RyaW5nJyA/IG5ldyBUYXNrQ29uZmlndXJhdGlvbkVycm9yKGVycm9yKSA6IGVycm9yO1xuICAgICAgfSxcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzOiBzdHJpbmdbXSwgdHJpbW1lZCA9IGZhbHNlKTogU3RyaW5nVGFzazxzdHJpbmc+IHtcbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kcyxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcih0ZXh0KSB7XG4gICAgICAgICByZXR1cm4gdHJpbW1lZCA/IFN0cmluZyh0ZXh0KS50cmltKCkgOiB0ZXh0O1xuICAgICAgfSxcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJhaWdodFRocm91Z2hCdWZmZXJUYXNrKGNvbW1hbmRzOiBzdHJpbmdbXSk6IEJ1ZmZlclRhc2s8YW55PiB7XG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICdidWZmZXInLFxuICAgICAgcGFyc2VyKGJ1ZmZlcikge1xuICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgIH0sXG4gICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNCdWZmZXJUYXNrPFI+KHRhc2s6IFNpbXBsZUdpdFRhc2s8Uj4pOiB0YXNrIGlzIEJ1ZmZlclRhc2s8Uj4ge1xuICAgcmV0dXJuIHRhc2suZm9ybWF0ID09PSAnYnVmZmVyJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHlUYXNrPFI+KHRhc2s6IFNpbXBsZUdpdFRhc2s8Uj4pOiB0YXNrIGlzIEVtcHR5VGFzayB7XG4gICByZXR1cm4gdGFzay5mb3JtYXQgPT09ICdlbXB0eScgfHwgIXRhc2suY29tbWFuZHMubGVuZ3RoO1xufVxuIiwgImltcG9ydCB7IENsZWFuU3VtbWFyeSB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgY2xlYW5TdW1tYXJ5UGFyc2VyIH0gZnJvbSAnLi4vcmVzcG9uc2VzL0NsZWFuU3VtbWFyeSc7XG5pbXBvcnQgeyBNYXliZSwgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGFzU3RyaW5nQXJyYXkgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBjb25maWd1cmF0aW9uRXJyb3JUYXNrIH0gZnJvbSAnLi90YXNrJztcblxuZXhwb3J0IGNvbnN0IENPTkZJR19FUlJPUl9JTlRFUkFDVElWRV9NT0RFID0gJ0dpdCBjbGVhbiBpbnRlcmFjdGl2ZSBtb2RlIGlzIG5vdCBzdXBwb3J0ZWQnO1xuZXhwb3J0IGNvbnN0IENPTkZJR19FUlJPUl9NT0RFX1JFUVVJUkVEID0gJ0dpdCBjbGVhbiBtb2RlIHBhcmFtZXRlciAoXCJuXCIgb3IgXCJmXCIpIGlzIHJlcXVpcmVkJztcbmV4cG9ydCBjb25zdCBDT05GSUdfRVJST1JfVU5LTk9XTl9PUFRJT04gPSAnR2l0IGNsZWFuIHVua25vd24gb3B0aW9uIGZvdW5kIGluOiAnO1xuXG4vKipcbiAqIEFsbCBzdXBwb3J0ZWQgb3B0aW9uIHN3aXRjaGVzIGF2YWlsYWJsZSBmb3IgdXNlIGluIGEgYGdpdC5jbGVhbmAgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydCBlbnVtIENsZWFuT3B0aW9ucyB7XG4gICBEUllfUlVOID0gJ24nLFxuICAgRk9SQ0UgPSAnZicsXG4gICBJR05PUkVEX0lOQ0xVREVEID0gJ3gnLFxuICAgSUdOT1JFRF9PTkxZID0gJ1gnLFxuICAgRVhDTFVESU5HID0gJ2UnLFxuICAgUVVJRVQgPSAncScsXG4gICBSRUNVUlNJVkUgPSAnZCcsXG59XG5cbi8qKlxuICogVGhlIHR3byBtb2RlcyBgZ2l0LmNsZWFuYCBjYW4gcnVuIGluIC0gb25lIG9mIHRoZXNlIG11c3QgYmUgc3VwcGxpZWQgaW4gb3JkZXJcbiAqIGZvciB0aGUgY29tbWFuZCB0byBub3QgdGhyb3cgYSBgVGFza0NvbmZpZ3VyYXRpb25FcnJvcmBcbiAqL1xuZXhwb3J0IHR5cGUgQ2xlYW5Nb2RlID0gQ2xlYW5PcHRpb25zLkZPUkNFIHwgQ2xlYW5PcHRpb25zLkRSWV9SVU47XG5cbmNvbnN0IENsZWFuT3B0aW9uVmFsdWVzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoW1xuICAgJ2knLFxuICAgLi4uYXNTdHJpbmdBcnJheShPYmplY3QudmFsdWVzKENsZWFuT3B0aW9ucyBhcyBhbnkpKSxcbl0pO1xuXG5leHBvcnQgZnVuY3Rpb24gY2xlYW5XaXRoT3B0aW9uc1Rhc2sobW9kZTogQ2xlYW5Nb2RlIHwgc3RyaW5nLCBjdXN0b21BcmdzOiBzdHJpbmdbXSkge1xuICAgY29uc3QgeyBjbGVhbk1vZGUsIG9wdGlvbnMsIHZhbGlkIH0gPSBnZXRDbGVhbk9wdGlvbnMobW9kZSk7XG5cbiAgIGlmICghY2xlYW5Nb2RlKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhDT05GSUdfRVJST1JfTU9ERV9SRVFVSVJFRCk7XG4gICB9XG5cbiAgIGlmICghdmFsaWQub3B0aW9ucykge1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soQ09ORklHX0VSUk9SX1VOS05PV05fT1BUSU9OICsgSlNPTi5zdHJpbmdpZnkobW9kZSkpO1xuICAgfVxuXG4gICBvcHRpb25zLnB1c2goLi4uY3VzdG9tQXJncyk7XG5cbiAgIGlmIChvcHRpb25zLnNvbWUoaXNJbnRlcmFjdGl2ZU1vZGUpKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhDT05GSUdfRVJST1JfSU5URVJBQ1RJVkVfTU9ERSk7XG4gICB9XG5cbiAgIHJldHVybiBjbGVhblRhc2soY2xlYW5Nb2RlLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuVGFzayhtb2RlOiBDbGVhbk1vZGUsIGN1c3RvbUFyZ3M6IHN0cmluZ1tdKTogU3RyaW5nVGFzazxDbGVhblN1bW1hcnk+IHtcbiAgIGNvbnN0IGNvbW1hbmRzOiBzdHJpbmdbXSA9IFsnY2xlYW4nLCBgLSR7bW9kZX1gLCAuLi5jdXN0b21BcmdzXTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgcGFyc2VyKHRleHQ6IHN0cmluZyk6IENsZWFuU3VtbWFyeSB7XG4gICAgICAgICByZXR1cm4gY2xlYW5TdW1tYXJ5UGFyc2VyKG1vZGUgPT09IENsZWFuT3B0aW9ucy5EUllfUlVOLCB0ZXh0KTtcbiAgICAgIH0sXG4gICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDbGVhbk9wdGlvbnNBcnJheShpbnB1dDogc3RyaW5nW10pOiBpbnB1dCBpcyBDbGVhbk9wdGlvbnNbXSB7XG4gICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dCkgJiYgaW5wdXQuZXZlcnkoKHRlc3QpID0+IENsZWFuT3B0aW9uVmFsdWVzLmhhcyh0ZXN0KSk7XG59XG5cbmZ1bmN0aW9uIGdldENsZWFuT3B0aW9ucyhpbnB1dDogc3RyaW5nKSB7XG4gICBsZXQgY2xlYW5Nb2RlOiBNYXliZTxDbGVhbk1vZGU+O1xuICAgbGV0IG9wdGlvbnM6IHN0cmluZ1tdID0gW107XG4gICBsZXQgdmFsaWQgPSB7IGNsZWFuTW9kZTogZmFsc2UsIG9wdGlvbnM6IHRydWUgfTtcblxuICAgaW5wdXRcbiAgICAgIC5yZXBsYWNlKC9bXmEtel1pL2csICcnKVxuICAgICAgLnNwbGl0KCcnKVxuICAgICAgLmZvckVhY2goKGNoYXIpID0+IHtcbiAgICAgICAgIGlmIChpc0NsZWFuTW9kZShjaGFyKSkge1xuICAgICAgICAgICAgY2xlYW5Nb2RlID0gY2hhcjtcbiAgICAgICAgICAgIHZhbGlkLmNsZWFuTW9kZSA9IHRydWU7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsaWQub3B0aW9ucyA9IHZhbGlkLm9wdGlvbnMgJiYgaXNLbm93bk9wdGlvbigob3B0aW9uc1tvcHRpb25zLmxlbmd0aF0gPSBgLSR7Y2hhcn1gKSk7XG4gICAgICAgICB9XG4gICAgICB9KTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNsZWFuTW9kZSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICB2YWxpZCxcbiAgIH07XG59XG5cbmZ1bmN0aW9uIGlzQ2xlYW5Nb2RlKGNsZWFuTW9kZT86IHN0cmluZyk6IGNsZWFuTW9kZSBpcyBDbGVhbk1vZGUge1xuICAgcmV0dXJuIGNsZWFuTW9kZSA9PT0gQ2xlYW5PcHRpb25zLkZPUkNFIHx8IGNsZWFuTW9kZSA9PT0gQ2xlYW5PcHRpb25zLkRSWV9SVU47XG59XG5cbmZ1bmN0aW9uIGlzS25vd25PcHRpb24ob3B0aW9uOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgIHJldHVybiAvXi1bYS16XSQvaS50ZXN0KG9wdGlvbikgJiYgQ2xlYW5PcHRpb25WYWx1ZXMuaGFzKG9wdGlvbi5jaGFyQXQoMSkpO1xufVxuXG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlTW9kZShvcHRpb246IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgaWYgKC9eLVteXFwtXS8udGVzdChvcHRpb24pKSB7XG4gICAgICByZXR1cm4gb3B0aW9uLmluZGV4T2YoJ2knKSA+IDA7XG4gICB9XG5cbiAgIHJldHVybiBvcHRpb24gPT09ICctLWludGVyYWN0aXZlJztcbn1cbiIsICJpbXBvcnQgeyBDb25maWdHZXRSZXN1bHQsIENvbmZpZ0xpc3RTdW1tYXJ5LCBDb25maWdWYWx1ZXMgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IGxhc3QsIHNwbGl0T24gfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBDb25maWdMaXN0IGltcGxlbWVudHMgQ29uZmlnTGlzdFN1bW1hcnkge1xuICAgcHVibGljIGZpbGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgcHVibGljIHZhbHVlczogeyBbZmlsZU5hbWU6IHN0cmluZ106IENvbmZpZ1ZhbHVlcyB9ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgcHJpdmF0ZSBfYWxsOiBDb25maWdWYWx1ZXMgfCB1bmRlZmluZWQ7XG5cbiAgIHB1YmxpYyBnZXQgYWxsKCk6IENvbmZpZ1ZhbHVlcyB7XG4gICAgICBpZiAoIXRoaXMuX2FsbCkge1xuICAgICAgICAgdGhpcy5fYWxsID0gdGhpcy5maWxlcy5yZWR1Y2UoKGFsbDogQ29uZmlnVmFsdWVzLCBmaWxlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFsbCwgdGhpcy52YWx1ZXNbZmlsZV0pO1xuICAgICAgICAgfSwge30pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fYWxsO1xuICAgfVxuXG4gICBwdWJsaWMgYWRkRmlsZShmaWxlOiBzdHJpbmcpOiBDb25maWdWYWx1ZXMge1xuICAgICAgaWYgKCEoZmlsZSBpbiB0aGlzLnZhbHVlcykpIHtcbiAgICAgICAgIGNvbnN0IGxhdGVzdCA9IGxhc3QodGhpcy5maWxlcyk7XG4gICAgICAgICB0aGlzLnZhbHVlc1tmaWxlXSA9IGxhdGVzdCA/IE9iamVjdC5jcmVhdGUodGhpcy52YWx1ZXNbbGF0ZXN0XSkgOiB7fTtcblxuICAgICAgICAgdGhpcy5maWxlcy5wdXNoKGZpbGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy52YWx1ZXNbZmlsZV07XG4gICB9XG5cbiAgIHB1YmxpYyBhZGRWYWx1ZShmaWxlOiBzdHJpbmcsIGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLmFkZEZpbGUoZmlsZSk7XG5cbiAgICAgIGlmICghdmFsdWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgIHZhbHVlc1trZXldID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzW2tleV0pKSB7XG4gICAgICAgICAodmFsdWVzW2tleV0gYXMgc3RyaW5nW10pLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHZhbHVlc1trZXldID0gW3ZhbHVlc1trZXldIGFzIHN0cmluZywgdmFsdWVdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9hbGwgPSB1bmRlZmluZWQ7XG4gICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25maWdMaXN0UGFyc2VyKHRleHQ6IHN0cmluZyk6IENvbmZpZ0xpc3Qge1xuICAgY29uc3QgY29uZmlnID0gbmV3IENvbmZpZ0xpc3QoKTtcblxuICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbmZpZ1BhcnNlcih0ZXh0KSkge1xuICAgICAgY29uZmlnLmFkZFZhbHVlKGl0ZW0uZmlsZSwgU3RyaW5nKGl0ZW0ua2V5KSwgaXRlbS52YWx1ZSk7XG4gICB9XG5cbiAgIHJldHVybiBjb25maWc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25maWdHZXRQYXJzZXIodGV4dDogc3RyaW5nLCBrZXk6IHN0cmluZyk6IENvbmZpZ0dldFJlc3VsdCB7XG4gICBsZXQgdmFsdWU6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgY29uc3QgdmFsdWVzOiBzdHJpbmdbXSA9IFtdO1xuICAgY29uc3Qgc2NvcGVzOiBNYXA8c3RyaW5nLCBzdHJpbmdbXT4gPSBuZXcgTWFwKCk7XG5cbiAgIGZvciAoY29uc3QgaXRlbSBvZiBjb25maWdQYXJzZXIodGV4dCwga2V5KSkge1xuICAgICAgaWYgKGl0ZW0ua2V5ICE9PSBrZXkpIHtcbiAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZXMucHVzaCgodmFsdWUgPSBpdGVtLnZhbHVlKSk7XG5cbiAgICAgIGlmICghc2NvcGVzLmhhcyhpdGVtLmZpbGUpKSB7XG4gICAgICAgICBzY29wZXMuc2V0KGl0ZW0uZmlsZSwgW10pO1xuICAgICAgfVxuXG4gICAgICBzY29wZXMuZ2V0KGl0ZW0uZmlsZSkhLnB1c2godmFsdWUpO1xuICAgfVxuXG4gICByZXR1cm4ge1xuICAgICAga2V5LFxuICAgICAgcGF0aHM6IEFycmF5LmZyb20oc2NvcGVzLmtleXMoKSksXG4gICAgICBzY29wZXMsXG4gICAgICB2YWx1ZSxcbiAgICAgIHZhbHVlcyxcbiAgIH07XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ0ZpbGVQYXRoKGZpbGVQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgcmV0dXJuIGZpbGVQYXRoLnJlcGxhY2UoL14oZmlsZSk6LywgJycpO1xufVxuXG5mdW5jdGlvbiogY29uZmlnUGFyc2VyKHRleHQ6IHN0cmluZywgcmVxdWVzdGVkS2V5OiBzdHJpbmcgfCBudWxsID0gbnVsbCkge1xuICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXDAnKTtcblxuICAgZm9yIChsZXQgaSA9IDAsIG1heCA9IGxpbmVzLmxlbmd0aCAtIDE7IGkgPCBtYXg7ICkge1xuICAgICAgY29uc3QgZmlsZSA9IGNvbmZpZ0ZpbGVQYXRoKGxpbmVzW2krK10pO1xuXG4gICAgICBsZXQgdmFsdWUgPSBsaW5lc1tpKytdO1xuICAgICAgbGV0IGtleSA9IHJlcXVlc3RlZEtleTtcblxuICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKCdcXG4nKSkge1xuICAgICAgICAgY29uc3QgbGluZSA9IHNwbGl0T24odmFsdWUsICdcXG4nKTtcbiAgICAgICAgIGtleSA9IGxpbmVbMF07XG4gICAgICAgICB2YWx1ZSA9IGxpbmVbMV07XG4gICAgICB9XG5cbiAgICAgIHlpZWxkIHsgZmlsZSwga2V5LCB2YWx1ZSB9O1xuICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgQ29uZmlnR2V0UmVzdWx0LCBDb25maWdMaXN0U3VtbWFyeSwgU2ltcGxlR2l0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBjb25maWdHZXRQYXJzZXIsIGNvbmZpZ0xpc3RQYXJzZXIgfSBmcm9tICcuLi9yZXNwb25zZXMvQ29uZmlnTGlzdCc7XG5pbXBvcnQgdHlwZSB7IFNpbXBsZUdpdEFwaSB9IGZyb20gJy4uL3NpbXBsZS1naXQtYXBpJztcbmltcG9ydCB0eXBlIHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudCB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGVudW0gR2l0Q29uZmlnU2NvcGUge1xuICAgc3lzdGVtID0gJ3N5c3RlbScsXG4gICBnbG9iYWwgPSAnZ2xvYmFsJyxcbiAgIGxvY2FsID0gJ2xvY2FsJyxcbiAgIHdvcmt0cmVlID0gJ3dvcmt0cmVlJyxcbn1cblxuZnVuY3Rpb24gYXNDb25maWdTY29wZTxUIGV4dGVuZHMgR2l0Q29uZmlnU2NvcGUgfCB1bmRlZmluZWQ+KFxuICAgc2NvcGU6IEdpdENvbmZpZ1Njb3BlIHwgdW5rbm93bixcbiAgIGZhbGxiYWNrOiBUXG4pOiBHaXRDb25maWdTY29wZSB8IFQge1xuICAgaWYgKHR5cGVvZiBzY29wZSA9PT0gJ3N0cmluZycgJiYgR2l0Q29uZmlnU2NvcGUuaGFzT3duUHJvcGVydHkoc2NvcGUpKSB7XG4gICAgICByZXR1cm4gc2NvcGUgYXMgR2l0Q29uZmlnU2NvcGU7XG4gICB9XG4gICByZXR1cm4gZmFsbGJhY2s7XG59XG5cbmZ1bmN0aW9uIGFkZENvbmZpZ1Rhc2soXG4gICBrZXk6IHN0cmluZyxcbiAgIHZhbHVlOiBzdHJpbmcsXG4gICBhcHBlbmQ6IGJvb2xlYW4sXG4gICBzY29wZTogR2l0Q29uZmlnU2NvcGVcbik6IFN0cmluZ1Rhc2s8c3RyaW5nPiB7XG4gICBjb25zdCBjb21tYW5kczogc3RyaW5nW10gPSBbJ2NvbmZpZycsIGAtLSR7c2NvcGV9YF07XG5cbiAgIGlmIChhcHBlbmQpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goJy0tYWRkJyk7XG4gICB9XG5cbiAgIGNvbW1hbmRzLnB1c2goa2V5LCB2YWx1ZSk7XG5cbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kcyxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcih0ZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9LFxuICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29uZmlnVGFzayhrZXk6IHN0cmluZywgc2NvcGU/OiBHaXRDb25maWdTY29wZSk6IFN0cmluZ1Rhc2s8Q29uZmlnR2V0UmVzdWx0PiB7XG4gICBjb25zdCBjb21tYW5kczogc3RyaW5nW10gPSBbJ2NvbmZpZycsICctLW51bGwnLCAnLS1zaG93LW9yaWdpbicsICctLWdldC1hbGwnLCBrZXldO1xuXG4gICBpZiAoc2NvcGUpIHtcbiAgICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCBgLS0ke3Njb3BlfWApO1xuICAgfVxuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXIodGV4dCkge1xuICAgICAgICAgcmV0dXJuIGNvbmZpZ0dldFBhcnNlcih0ZXh0LCBrZXkpO1xuICAgICAgfSxcbiAgIH07XG59XG5cbmZ1bmN0aW9uIGxpc3RDb25maWdUYXNrKHNjb3BlPzogR2l0Q29uZmlnU2NvcGUpOiBTdHJpbmdUYXNrPENvbmZpZ0xpc3RTdW1tYXJ5PiB7XG4gICBjb25zdCBjb21tYW5kcyA9IFsnY29uZmlnJywgJy0tbGlzdCcsICctLXNob3ctb3JpZ2luJywgJy0tbnVsbCddO1xuXG4gICBpZiAoc2NvcGUpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goYC0tJHtzY29wZX1gKTtcbiAgIH1cblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgcGFyc2VyKHRleHQ6IHN0cmluZykge1xuICAgICAgICAgcmV0dXJuIGNvbmZpZ0xpc3RQYXJzZXIodGV4dCk7XG4gICAgICB9LFxuICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCk6IFBpY2s8U2ltcGxlR2l0LCAnYWRkQ29uZmlnJyB8ICdnZXRDb25maWcnIHwgJ2xpc3RDb25maWcnPiB7XG4gICByZXR1cm4ge1xuICAgICAgYWRkQ29uZmlnKHRoaXM6IFNpbXBsZUdpdEFwaSwga2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcsIC4uLnJlc3Q6IHVua25vd25bXSkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBhZGRDb25maWdUYXNrKFxuICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICByZXN0WzBdID09PSB0cnVlLFxuICAgICAgICAgICAgICAgYXNDb25maWdTY29wZShyZXN0WzFdLCBHaXRDb25maWdTY29wZS5sb2NhbClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgICAgKTtcbiAgICAgIH0sXG5cbiAgICAgIGdldENvbmZpZyh0aGlzOiBTaW1wbGVHaXRBcGksIGtleTogc3RyaW5nLCBzY29wZT86IEdpdENvbmZpZ1Njb3BlKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIGdldENvbmZpZ1Rhc2soa2V5LCBhc0NvbmZpZ1Njb3BlKHNjb3BlLCB1bmRlZmluZWQpKSxcbiAgICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICApO1xuICAgICAgfSxcblxuICAgICAgbGlzdENvbmZpZyh0aGlzOiBTaW1wbGVHaXRBcGksIC4uLnJlc3Q6IHVua25vd25bXSkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBsaXN0Q29uZmlnVGFzayhhc0NvbmZpZ1Njb3BlKHJlc3RbMF0sIHVuZGVmaW5lZCkpLFxuICAgICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICAgICk7XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJleHBvcnQgZW51bSBEaWZmTmFtZVN0YXR1cyB7XG4gICBBRERFRCA9ICdBJyxcbiAgIENPUElFRCA9ICdDJyxcbiAgIERFTEVURUQgPSAnRCcsXG4gICBNT0RJRklFRCA9ICdNJyxcbiAgIFJFTkFNRUQgPSAnUicsXG4gICBDSEFOR0VEID0gJ1QnLFxuICAgVU5NRVJHRUQgPSAnVScsXG4gICBVTktOT1dOID0gJ1gnLFxuICAgQlJPS0VOID0gJ0InLFxufVxuXG5jb25zdCBkaWZmTmFtZVN0YXR1cyA9IG5ldyBTZXQoT2JqZWN0LnZhbHVlcyhEaWZmTmFtZVN0YXR1cykpO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEaWZmTmFtZVN0YXR1cyhpbnB1dDogc3RyaW5nKTogaW5wdXQgaXMgRGlmZk5hbWVTdGF0dXMge1xuICAgcmV0dXJuIGRpZmZOYW1lU3RhdHVzLmhhcyhpbnB1dCBhcyBEaWZmTmFtZVN0YXR1cyk7XG59XG4iLCAiaW1wb3J0IHsgR3JlcFJlc3VsdCwgU2ltcGxlR2l0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBTaW1wbGVHaXRBcGkgfSBmcm9tICcuLi9zaW1wbGUtZ2l0LWFwaSc7XG5pbXBvcnQge1xuICAgYXNOdW1iZXIsXG4gICBmb3JFYWNoTGluZVdpdGhDb250ZW50LFxuICAgZ2V0VHJhaWxpbmdPcHRpb25zLFxuICAgTlVMTCxcbiAgIHByZWZpeGVkQXJyYXksXG4gICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQsXG59IGZyb20gJy4uL3V0aWxzJztcblxuaW1wb3J0IHsgY29uZmlndXJhdGlvbkVycm9yVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmNvbnN0IGRpc2FsbG93ZWRPcHRpb25zID0gWyctaCddO1xuXG5jb25zdCBRdWVyeSA9IFN5bWJvbCgnZ3JlcFF1ZXJ5Jyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2l0R3JlcFF1ZXJ5IGV4dGVuZHMgSXRlcmFibGU8c3RyaW5nPiB7XG4gICAvKiogQWRkcyBvbmUgb3IgbW9yZSB0ZXJtcyB0byBiZSBncm91cGVkIGFzIGFuIFwiYW5kXCIgdG8gYW55IG90aGVyIHRlcm1zICovXG4gICBhbmQoLi4uYW5kOiBzdHJpbmdbXSk6IHRoaXM7XG5cbiAgIC8qKiBBZGRzIG9uZSBvciBtb3JlIHNlYXJjaCB0ZXJtcyAtIGdpdC5ncmVwIHdpbGwgXCJvclwiIHRoaXMgdG8gb3RoZXIgdGVybXMgKi9cbiAgIHBhcmFtKC4uLnBhcmFtOiBzdHJpbmdbXSk6IHRoaXM7XG59XG5cbmNsYXNzIEdyZXBRdWVyeSBpbXBsZW1lbnRzIEdpdEdyZXBRdWVyeSB7XG4gICBwcml2YXRlIFtRdWVyeV06IHN0cmluZ1tdID0gW107XG5cbiAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgIGZvciAoY29uc3QgcXVlcnkgb2YgdGhpc1tRdWVyeV0pIHtcbiAgICAgICAgIHlpZWxkIHF1ZXJ5O1xuICAgICAgfVxuICAgfVxuXG4gICBhbmQoLi4uYW5kOiBzdHJpbmdbXSkge1xuICAgICAgYW5kLmxlbmd0aCAmJiB0aGlzW1F1ZXJ5XS5wdXNoKCctLWFuZCcsICcoJywgLi4ucHJlZml4ZWRBcnJheShhbmQsICctZScpLCAnKScpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9XG5cbiAgIHBhcmFtKC4uLnBhcmFtOiBzdHJpbmdbXSkge1xuICAgICAgdGhpc1tRdWVyeV0ucHVzaCguLi5wcmVmaXhlZEFycmF5KHBhcmFtLCAnLWUnKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGJ1aWxkZXIgZm9yIGEgYGdpdC5ncmVwYCBxdWVyeSB3aXRoIG9wdGlvbmFsIHBhcmFtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ3JlcFF1ZXJ5QnVpbGRlciguLi5wYXJhbXM6IHN0cmluZ1tdKTogR2l0R3JlcFF1ZXJ5IHtcbiAgIHJldHVybiBuZXcgR3JlcFF1ZXJ5KCkucGFyYW0oLi4ucGFyYW1zKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VHcmVwKGdyZXA6IHN0cmluZyk6IEdyZXBSZXN1bHQge1xuICAgY29uc3QgcGF0aHM6IEdyZXBSZXN1bHRbJ3BhdGhzJ10gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgIGNvbnN0IHJlc3VsdHM6IEdyZXBSZXN1bHRbJ3Jlc3VsdHMnXSA9IHt9O1xuXG4gICBmb3JFYWNoTGluZVdpdGhDb250ZW50KGdyZXAsIChpbnB1dCkgPT4ge1xuICAgICAgY29uc3QgW3BhdGgsIGxpbmUsIHByZXZpZXddID0gaW5wdXQuc3BsaXQoTlVMTCk7XG4gICAgICBwYXRocy5hZGQocGF0aCk7XG4gICAgICAocmVzdWx0c1twYXRoXSA9IHJlc3VsdHNbcGF0aF0gfHwgW10pLnB1c2goe1xuICAgICAgICAgbGluZTogYXNOdW1iZXIobGluZSksXG4gICAgICAgICBwYXRoLFxuICAgICAgICAgcHJldmlldyxcbiAgICAgIH0pO1xuICAgfSk7XG5cbiAgIHJldHVybiB7XG4gICAgICBwYXRocyxcbiAgICAgIHJlc3VsdHMsXG4gICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKTogUGljazxTaW1wbGVHaXQsICdncmVwJz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIGdyZXAodGhpczogU2ltcGxlR2l0QXBpLCBzZWFyY2hUZXJtOiBzdHJpbmcgfCBHaXRHcmVwUXVlcnkpIHtcbiAgICAgICAgIGNvbnN0IHRoZW4gPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKTtcbiAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKTtcblxuICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgZGlzYWxsb3dlZE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVzKG9wdGlvbikpIHtcbiAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbkVycm9yVGFzayhgZ2l0LmdyZXA6IHVzZSBvZiBcIiR7b3B0aW9ufVwiIGlzIG5vdCBzdXBwb3J0ZWQuYCksXG4gICAgICAgICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAodHlwZW9mIHNlYXJjaFRlcm0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzZWFyY2hUZXJtID0gZ3JlcFF1ZXJ5QnVpbGRlcigpLnBhcmFtKHNlYXJjaFRlcm0pO1xuICAgICAgICAgfVxuXG4gICAgICAgICBjb25zdCBjb21tYW5kcyA9IFsnZ3JlcCcsICctLW51bGwnLCAnLW4nLCAnLS1mdWxsLW5hbWUnLCAuLi5vcHRpb25zLCAuLi5zZWFyY2hUZXJtXTtcblxuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICBjb21tYW5kcyxcbiAgICAgICAgICAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgICAgICAgICAgIHBhcnNlcihzdGRPdXQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUdyZXAoc3RkT3V0KTtcbiAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGhlblxuICAgICAgICAgKTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImltcG9ydCB7IHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2sgfSBmcm9tICcuL3Rhc2snO1xuaW1wb3J0IHsgTWF5YmUsIE9wdGlvbkZsYWdzLCBPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZW51bSBSZXNldE1vZGUge1xuICAgTUlYRUQgPSAnbWl4ZWQnLFxuICAgU09GVCA9ICdzb2Z0JyxcbiAgIEhBUkQgPSAnaGFyZCcsXG4gICBNRVJHRSA9ICdtZXJnZScsXG4gICBLRUVQID0gJ2tlZXAnLFxufVxuXG5jb25zdCBSZXNldE1vZGVzID0gQXJyYXkuZnJvbShPYmplY3QudmFsdWVzKFJlc2V0TW9kZSkpO1xuXG5leHBvcnQgdHlwZSBSZXNldE9wdGlvbnMgPSBPcHRpb25zICZcbiAgIE9wdGlvbkZsYWdzPCctcScgfCAnLS1xdWlldCcgfCAnLS1uby1xdWlldCcgfCAnLS1wYXRoc3BlYy1mcm9tLW51bCc+ICZcbiAgIE9wdGlvbkZsYWdzPCctLXBhdGhzcGVjLWZyb20tZmlsZScsIHN0cmluZz47XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldFRhc2sobW9kZTogTWF5YmU8UmVzZXRNb2RlPiwgY3VzdG9tQXJnczogc3RyaW5nW10pIHtcbiAgIGNvbnN0IGNvbW1hbmRzOiBzdHJpbmdbXSA9IFsncmVzZXQnXTtcbiAgIGlmIChpc1ZhbGlkUmVzZXRNb2RlKG1vZGUpKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKGAtLSR7bW9kZX1gKTtcbiAgIH1cbiAgIGNvbW1hbmRzLnB1c2goLi4uY3VzdG9tQXJncyk7XG5cbiAgIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlc2V0TW9kZShtb2RlOiBSZXNldE1vZGUgfCBhbnkpOiBNYXliZTxSZXNldE1vZGU+IHtcbiAgIGlmIChpc1ZhbGlkUmVzZXRNb2RlKG1vZGUpKSB7XG4gICAgICByZXR1cm4gbW9kZTtcbiAgIH1cblxuICAgc3dpdGNoICh0eXBlb2YgbW9kZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICByZXR1cm4gUmVzZXRNb2RlLlNPRlQ7XG4gICB9XG5cbiAgIHJldHVybjtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZFJlc2V0TW9kZShtb2RlOiBSZXNldE1vZGUgfCBhbnkpOiBtb2RlIGlzIFJlc2V0TW9kZSB7XG4gICByZXR1cm4gUmVzZXRNb2Rlcy5pbmNsdWRlcyhtb2RlKTtcbn1cbiIsICJpbXBvcnQgZGVidWcsIHsgRGVidWdnZXIgfSBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQge1xuICAgYXBwZW5kLFxuICAgZmlsdGVySGFzTGVuZ3RoLFxuICAgZmlsdGVyU3RyaW5nLFxuICAgZmlsdGVyVHlwZSxcbiAgIE5PT1AsXG4gICBvYmplY3RUb1N0cmluZyxcbiAgIHJlbW92ZSxcbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBNYXliZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5kZWJ1Zy5mb3JtYXR0ZXJzLkwgPSAodmFsdWU6IGFueSkgPT4gU3RyaW5nKGZpbHRlckhhc0xlbmd0aCh2YWx1ZSkgPyB2YWx1ZS5sZW5ndGggOiAnLScpO1xuZGVidWcuZm9ybWF0dGVycy5CID0gKHZhbHVlOiBCdWZmZXIpID0+IHtcbiAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgIH1cbiAgIHJldHVybiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59O1xuXG50eXBlIE91dHB1dExvZ2dpbmdIYW5kbGVyID0gKG1lc3NhZ2U6IHN0cmluZywgLi4uYXJnczogYW55W10pID0+IHZvaWQ7XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvZygpIHtcbiAgIHJldHVybiBkZWJ1Zygnc2ltcGxlLWdpdCcpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE91dHB1dExvZ2dlciBleHRlbmRzIE91dHB1dExvZ2dpbmdIYW5kbGVyIHtcbiAgIHJlYWRvbmx5IGxhYmVsOiBzdHJpbmc7XG5cbiAgIGluZm86IE91dHB1dExvZ2dpbmdIYW5kbGVyO1xuICAgc3RlcChuZXh0U3RlcD86IHN0cmluZyk6IE91dHB1dExvZ2dlcjtcbiAgIHNpYmxpbmcobmFtZTogc3RyaW5nKTogT3V0cHV0TG9nZ2VyO1xufVxuXG5mdW5jdGlvbiBwcmVmaXhlZExvZ2dlcihcbiAgIHRvOiBEZWJ1Z2dlcixcbiAgIHByZWZpeDogc3RyaW5nLFxuICAgZm9yd2FyZD86IE91dHB1dExvZ2dpbmdIYW5kbGVyXG4pOiBPdXRwdXRMb2dnaW5nSGFuZGxlciB7XG4gICBpZiAoIXByZWZpeCB8fCAhU3RyaW5nKHByZWZpeCkucmVwbGFjZSgvXFxzKi8sICcnKSkge1xuICAgICAgcmV0dXJuICFmb3J3YXJkXG4gICAgICAgICA/IHRvXG4gICAgICAgICA6IChtZXNzYWdlLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgIHRvKG1lc3NhZ2UsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgICBmb3J3YXJkKG1lc3NhZ2UsIC4uLmFyZ3MpO1xuICAgICAgICAgICB9O1xuICAgfVxuXG4gICByZXR1cm4gKG1lc3NhZ2UsIC4uLmFyZ3MpID0+IHtcbiAgICAgIHRvKGAlcyAke21lc3NhZ2V9YCwgcHJlZml4LCAuLi5hcmdzKTtcbiAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICBmb3J3YXJkKG1lc3NhZ2UsIC4uLmFyZ3MpO1xuICAgICAgfVxuICAgfTtcbn1cblxuZnVuY3Rpb24gY2hpbGRMb2dnZXJOYW1lKFxuICAgbmFtZTogTWF5YmU8c3RyaW5nPixcbiAgIGNoaWxkRGVidWdnZXI6IE1heWJlPERlYnVnZ2VyPixcbiAgIHsgbmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UgfTogRGVidWdnZXJcbik6IHN0cmluZyB7XG4gICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgIH1cbiAgIGNvbnN0IGNoaWxkTmFtZXNwYWNlID0gKGNoaWxkRGVidWdnZXIgJiYgY2hpbGREZWJ1Z2dlci5uYW1lc3BhY2UpIHx8ICcnO1xuXG4gICBpZiAoY2hpbGROYW1lc3BhY2Uuc3RhcnRzV2l0aChwYXJlbnROYW1lc3BhY2UpKSB7XG4gICAgICByZXR1cm4gY2hpbGROYW1lc3BhY2Uuc3Vic3RyKHBhcmVudE5hbWVzcGFjZS5sZW5ndGggKyAxKTtcbiAgIH1cblxuICAgcmV0dXJuIGNoaWxkTmFtZXNwYWNlIHx8IHBhcmVudE5hbWVzcGFjZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxvZ2dlcihcbiAgIGxhYmVsOiBzdHJpbmcsXG4gICB2ZXJib3NlPzogc3RyaW5nIHwgRGVidWdnZXIsXG4gICBpbml0aWFsU3RlcD86IHN0cmluZyxcbiAgIGluZm9EZWJ1Z2dlciA9IGNyZWF0ZUxvZygpXG4pOiBPdXRwdXRMb2dnZXIge1xuICAgY29uc3QgbGFiZWxQcmVmaXggPSAobGFiZWwgJiYgYFske2xhYmVsfV1gKSB8fCAnJztcblxuICAgY29uc3Qgc3Bhd25lZDogT3V0cHV0TG9nZ2VyW10gPSBbXTtcbiAgIGNvbnN0IGRlYnVnRGVidWdnZXI6IE1heWJlPERlYnVnZ2VyPiA9XG4gICAgICB0eXBlb2YgdmVyYm9zZSA9PT0gJ3N0cmluZycgPyBpbmZvRGVidWdnZXIuZXh0ZW5kKHZlcmJvc2UpIDogdmVyYm9zZTtcbiAgIGNvbnN0IGtleSA9IGNoaWxkTG9nZ2VyTmFtZShmaWx0ZXJUeXBlKHZlcmJvc2UsIGZpbHRlclN0cmluZyksIGRlYnVnRGVidWdnZXIsIGluZm9EZWJ1Z2dlcik7XG5cbiAgIHJldHVybiBzdGVwKGluaXRpYWxTdGVwKTtcblxuICAgZnVuY3Rpb24gc2libGluZyhuYW1lOiBzdHJpbmcsIGluaXRpYWw/OiBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBhcHBlbmQoXG4gICAgICAgICBzcGF3bmVkLFxuICAgICAgICAgY3JlYXRlTG9nZ2VyKGxhYmVsLCBrZXkucmVwbGFjZSgvXlteOl0rLywgbmFtZSksIGluaXRpYWwsIGluZm9EZWJ1Z2dlcilcbiAgICAgICk7XG4gICB9XG5cbiAgIGZ1bmN0aW9uIHN0ZXAocGhhc2U/OiBzdHJpbmcpIHtcbiAgICAgIGNvbnN0IHN0ZXBQcmVmaXggPSAocGhhc2UgJiYgYFske3BoYXNlfV1gKSB8fCAnJztcbiAgICAgIGNvbnN0IGRlYnVnID0gKGRlYnVnRGVidWdnZXIgJiYgcHJlZml4ZWRMb2dnZXIoZGVidWdEZWJ1Z2dlciwgc3RlcFByZWZpeCkpIHx8IE5PT1A7XG4gICAgICBjb25zdCBpbmZvID0gcHJlZml4ZWRMb2dnZXIoaW5mb0RlYnVnZ2VyLCBgJHtsYWJlbFByZWZpeH0gJHtzdGVwUHJlZml4fWAsIGRlYnVnKTtcblxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGVidWdEZWJ1Z2dlciA/IGRlYnVnIDogaW5mbywge1xuICAgICAgICAgbGFiZWwsXG4gICAgICAgICBzaWJsaW5nLFxuICAgICAgICAgaW5mbyxcbiAgICAgICAgIHN0ZXAsXG4gICAgICB9KTtcbiAgIH1cbn1cblxuLyoqXG4gKiBUaGUgYEdpdExvZ2dlcmAgaXMgdXNlZCBieSB0aGUgbWFpbiBgU2ltcGxlR2l0YCBydW5uZXIgdG8gaGFuZGxlIGxvZ2dpbmdcbiAqIGFueSB3YXJuaW5ncyBvciBlcnJvcnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBHaXRMb2dnZXIge1xuICAgcHVibGljIGVycm9yOiBPdXRwdXRMb2dnaW5nSGFuZGxlcjtcblxuICAgcHVibGljIHdhcm46IE91dHB1dExvZ2dpbmdIYW5kbGVyO1xuXG4gICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9vdXQ6IERlYnVnZ2VyID0gY3JlYXRlTG9nKCkpIHtcbiAgICAgIHRoaXMuZXJyb3IgPSBwcmVmaXhlZExvZ2dlcihfb3V0LCAnW0VSUk9SXScpO1xuICAgICAgdGhpcy53YXJuID0gcHJlZml4ZWRMb2dnZXIoX291dCwgJ1tXQVJOXScpO1xuICAgfVxuXG4gICBzaWxlbnQoc2lsZW5jZSA9IGZhbHNlKSB7XG4gICAgICBpZiAoc2lsZW5jZSAhPT0gdGhpcy5fb3V0LmVuYWJsZWQpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBuYW1lc3BhY2UgfSA9IHRoaXMuX291dDtcbiAgICAgIGNvbnN0IGVudiA9IChwcm9jZXNzLmVudi5ERUJVRyB8fCAnJykuc3BsaXQoJywnKS5maWx0ZXIoKHMpID0+ICEhcyk7XG4gICAgICBjb25zdCBoYXNPbiA9IGVudi5pbmNsdWRlcyhuYW1lc3BhY2UpO1xuICAgICAgY29uc3QgaGFzT2ZmID0gZW52LmluY2x1ZGVzKGAtJHtuYW1lc3BhY2V9YCk7XG5cbiAgICAgIC8vIGVuYWJsaW5nIHRoZSBsb2dcbiAgICAgIGlmICghc2lsZW5jZSkge1xuICAgICAgICAgaWYgKGhhc09mZikge1xuICAgICAgICAgICAgcmVtb3ZlKGVudiwgYC0ke25hbWVzcGFjZX1gKTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnYucHVzaChuYW1lc3BhY2UpO1xuICAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIGlmIChoYXNPbikge1xuICAgICAgICAgICAgcmVtb3ZlKGVudiwgbmFtZXNwYWNlKTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnYucHVzaChgLSR7bmFtZXNwYWNlfWApO1xuICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkZWJ1Zy5lbmFibGUoZW52LmpvaW4oJywnKSk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgU2ltcGxlR2l0VGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEdpdEVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2dpdC1lcnJvcic7XG5pbXBvcnQgeyBjcmVhdGVMb2dnZXIsIE91dHB1dExvZ2dlciB9IGZyb20gJy4uL2dpdC1sb2dnZXInO1xuXG50eXBlIEFueVNpbXBsZUdpdFRhc2sgPSBTaW1wbGVHaXRUYXNrPGFueT47XG5cbnR5cGUgVGFza0luUHJvZ3Jlc3MgPSB7XG4gICBuYW1lOiBzdHJpbmc7XG4gICBsb2dnZXI6IE91dHB1dExvZ2dlcjtcbiAgIHRhc2s6IEFueVNpbXBsZUdpdFRhc2s7XG59O1xuXG5leHBvcnQgY2xhc3MgVGFza3NQZW5kaW5nUXVldWUge1xuICAgcHJpdmF0ZSBfcXVldWU6IE1hcDxBbnlTaW1wbGVHaXRUYXNrLCBUYXNrSW5Qcm9ncmVzcz4gPSBuZXcgTWFwKCk7XG5cbiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbG9nTGFiZWwgPSAnR2l0RXhlY3V0b3InKSB7fVxuXG4gICBwcml2YXRlIHdpdGhQcm9ncmVzcyh0YXNrOiBBbnlTaW1wbGVHaXRUYXNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcXVldWUuZ2V0KHRhc2spO1xuICAgfVxuXG4gICBwcml2YXRlIGNyZWF0ZVByb2dyZXNzKHRhc2s6IEFueVNpbXBsZUdpdFRhc2spOiBUYXNrSW5Qcm9ncmVzcyB7XG4gICAgICBjb25zdCBuYW1lID0gVGFza3NQZW5kaW5nUXVldWUuZ2V0TmFtZSh0YXNrLmNvbW1hbmRzWzBdKTtcbiAgICAgIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcih0aGlzLmxvZ0xhYmVsLCBuYW1lKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgIHRhc2ssXG4gICAgICAgICBsb2dnZXIsXG4gICAgICAgICBuYW1lLFxuICAgICAgfTtcbiAgIH1cblxuICAgcHVzaCh0YXNrOiBBbnlTaW1wbGVHaXRUYXNrKTogVGFza0luUHJvZ3Jlc3Mge1xuICAgICAgY29uc3QgcHJvZ3Jlc3MgPSB0aGlzLmNyZWF0ZVByb2dyZXNzKHRhc2spO1xuICAgICAgcHJvZ3Jlc3MubG9nZ2VyKCdBZGRpbmcgdGFzayB0byB0aGUgcXVldWUsIGNvbW1hbmRzID0gJW8nLCB0YXNrLmNvbW1hbmRzKTtcblxuICAgICAgdGhpcy5fcXVldWUuc2V0KHRhc2ssIHByb2dyZXNzKTtcblxuICAgICAgcmV0dXJuIHByb2dyZXNzO1xuICAgfVxuXG4gICBmYXRhbChlcnI6IEdpdEVycm9yKSB7XG4gICAgICBmb3IgKGNvbnN0IFt0YXNrLCB7IGxvZ2dlciB9XSBvZiBBcnJheS5mcm9tKHRoaXMuX3F1ZXVlLmVudHJpZXMoKSkpIHtcbiAgICAgICAgIGlmICh0YXNrID09PSBlcnIudGFzaykge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYEZhaWxlZCAlb2AsIGVycik7XG4gICAgICAgICAgICBsb2dnZXIoXG4gICAgICAgICAgICAgICBgRmF0YWwgZXhjZXB0aW9uLCBhbnkgYXMteWV0IHVuLXN0YXJ0ZWQgdGFza3MgcnVuIHRocm91Z2ggdGhpcyBleGVjdXRvciB3aWxsIG5vdCBiZSBhdHRlbXB0ZWRgXG4gICAgICAgICAgICApO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICAgYEEgZmF0YWwgZXhjZXB0aW9uIG9jY3VycmVkIGluIGEgcHJldmlvdXMgdGFzaywgdGhlIHF1ZXVlIGhhcyBiZWVuIHB1cmdlZDogJW9gLFxuICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2VcbiAgICAgICAgICAgICk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuY29tcGxldGUodGFzayk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9xdWV1ZS5zaXplICE9PSAwKSB7XG4gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFF1ZXVlIHNpemUgc2hvdWxkIGJlIHplcm8gYWZ0ZXIgZmF0YWw6ICR7dGhpcy5fcXVldWUuc2l6ZX1gKTtcbiAgICAgIH1cbiAgIH1cblxuICAgY29tcGxldGUodGFzazogQW55U2ltcGxlR2l0VGFzaykge1xuICAgICAgY29uc3QgcHJvZ3Jlc3MgPSB0aGlzLndpdGhQcm9ncmVzcyh0YXNrKTtcbiAgICAgIGlmIChwcm9ncmVzcykge1xuICAgICAgICAgdGhpcy5fcXVldWUuZGVsZXRlKHRhc2spO1xuICAgICAgfVxuICAgfVxuXG4gICBhdHRlbXB0KHRhc2s6IEFueVNpbXBsZUdpdFRhc2spOiBUYXNrSW5Qcm9ncmVzcyB7XG4gICAgICBjb25zdCBwcm9ncmVzcyA9IHRoaXMud2l0aFByb2dyZXNzKHRhc2spO1xuICAgICAgaWYgKCFwcm9ncmVzcykge1xuICAgICAgICAgdGhyb3cgbmV3IEdpdEVycm9yKHVuZGVmaW5lZCwgJ1Rhc2tzUGVuZGluZ1F1ZXVlOiBhdHRlbXB0IGNhbGxlZCBmb3IgYW4gdW5rbm93biB0YXNrJyk7XG4gICAgICB9XG4gICAgICBwcm9ncmVzcy5sb2dnZXIoJ1N0YXJ0aW5nIHRhc2snKTtcblxuICAgICAgcmV0dXJuIHByb2dyZXNzO1xuICAgfVxuXG4gICBzdGF0aWMgZ2V0TmFtZShuYW1lID0gJ2VtcHR5Jykge1xuICAgICAgcmV0dXJuIGB0YXNrOiR7bmFtZX06JHsrK1Rhc2tzUGVuZGluZ1F1ZXVlLmNvdW50ZXJ9YDtcbiAgIH1cblxuICAgcHJpdmF0ZSBzdGF0aWMgY291bnRlciA9IDA7XG59XG4iLCAiaW1wb3J0IHsgc3Bhd24sIFNwYXduT3B0aW9ucyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHsgR2l0RXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZ2l0LWVycm9yJztcbmltcG9ydCB7IE91dHB1dExvZ2dlciB9IGZyb20gJy4uL2dpdC1sb2dnZXInO1xuaW1wb3J0IHsgUGx1Z2luU3RvcmUgfSBmcm9tICcuLi9wbHVnaW5zJztcbmltcG9ydCB7IEVtcHR5VGFzaywgaXNCdWZmZXJUYXNrLCBpc0VtcHR5VGFzayB9IGZyb20gJy4uL3Rhc2tzL3Rhc2snO1xuaW1wb3J0IHtcbiAgIEdpdEV4ZWN1dG9yUmVzdWx0LFxuICAgTWF5YmUsXG4gICBvdXRwdXRIYW5kbGVyLFxuICAgUnVubmFibGVUYXNrLFxuICAgU2ltcGxlR2l0RXhlY3V0b3IsXG4gICBTaW1wbGVHaXRUYXNrLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBjYWxsVGFza1BhcnNlciwgZmlyc3QsIEdpdE91dHB1dFN0cmVhbXMsIG9iamVjdFRvU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgU2NoZWR1bGVyIH0gZnJvbSAnLi9zY2hlZHVsZXInO1xuaW1wb3J0IHsgVGFza3NQZW5kaW5nUXVldWUgfSBmcm9tICcuL3Rhc2tzLXBlbmRpbmctcXVldWUnO1xuXG5leHBvcnQgY2xhc3MgR2l0RXhlY3V0b3JDaGFpbiBpbXBsZW1lbnRzIFNpbXBsZUdpdEV4ZWN1dG9yIHtcbiAgIHByaXZhdGUgX2NoYWluOiBQcm9taXNlPGFueT4gPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgIHByaXZhdGUgX3F1ZXVlID0gbmV3IFRhc2tzUGVuZGluZ1F1ZXVlKCk7XG4gICBwcml2YXRlIF9jd2Q6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAgcHVibGljIGdldCBiaW5hcnkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZXhlY3V0b3IuYmluYXJ5O1xuICAgfVxuXG4gICBwdWJsaWMgZ2V0IGN3ZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jd2QgfHwgdGhpcy5fZXhlY3V0b3IuY3dkO1xuICAgfVxuXG4gICBwdWJsaWMgc2V0IGN3ZChjd2Q6IHN0cmluZykge1xuICAgICAgdGhpcy5fY3dkID0gY3dkO1xuICAgfVxuXG4gICBwdWJsaWMgZ2V0IGVudigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9leGVjdXRvci5lbnY7XG4gICB9XG5cbiAgIHB1YmxpYyBnZXQgb3V0cHV0SGFuZGxlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9leGVjdXRvci5vdXRwdXRIYW5kbGVyO1xuICAgfVxuXG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgX2V4ZWN1dG9yOiBTaW1wbGVHaXRFeGVjdXRvcixcbiAgICAgIHByaXZhdGUgX3NjaGVkdWxlcjogU2NoZWR1bGVyLFxuICAgICAgcHJpdmF0ZSBfcGx1Z2luczogUGx1Z2luU3RvcmVcbiAgICkge31cblxuICAgcHVibGljIGNoYWluKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9XG5cbiAgIHB1YmxpYyBwdXNoPFI+KHRhc2s6IFNpbXBsZUdpdFRhc2s8Uj4pOiBQcm9taXNlPFI+IHtcbiAgICAgIHRoaXMuX3F1ZXVlLnB1c2godGFzayk7XG5cbiAgICAgIHJldHVybiAodGhpcy5fY2hhaW4gPSB0aGlzLl9jaGFpbi50aGVuKCgpID0+IHRoaXMuYXR0ZW1wdFRhc2sodGFzaykpKTtcbiAgIH1cblxuICAgcHJpdmF0ZSBhc3luYyBhdHRlbXB0VGFzazxSPih0YXNrOiBTaW1wbGVHaXRUYXNrPFI+KTogUHJvbWlzZTx2b2lkIHwgUj4ge1xuICAgICAgY29uc3Qgb25TY2hlZHVsZUNvbXBsZXRlID0gYXdhaXQgdGhpcy5fc2NoZWR1bGVyLm5leHQoKTtcbiAgICAgIGNvbnN0IG9uUXVldWVDb21wbGV0ZSA9ICgpID0+IHRoaXMuX3F1ZXVlLmNvbXBsZXRlKHRhc2spO1xuXG4gICAgICB0cnkge1xuICAgICAgICAgY29uc3QgeyBsb2dnZXIgfSA9IHRoaXMuX3F1ZXVlLmF0dGVtcHQodGFzayk7XG4gICAgICAgICByZXR1cm4gKGF3YWl0IChpc0VtcHR5VGFzayh0YXNrKVxuICAgICAgICAgICAgPyB0aGlzLmF0dGVtcHRFbXB0eVRhc2sodGFzaywgbG9nZ2VyKVxuICAgICAgICAgICAgOiB0aGlzLmF0dGVtcHRSZW1vdGVUYXNrKHRhc2ssIGxvZ2dlcikpKSBhcyBSO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgdGhyb3cgdGhpcy5vbkZhdGFsRXhjZXB0aW9uKHRhc2ssIGUgYXMgRXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgIG9uUXVldWVDb21wbGV0ZSgpO1xuICAgICAgICAgb25TY2hlZHVsZUNvbXBsZXRlKCk7XG4gICAgICB9XG4gICB9XG5cbiAgIHByaXZhdGUgb25GYXRhbEV4Y2VwdGlvbjxSPih0YXNrOiBTaW1wbGVHaXRUYXNrPFI+LCBlOiBFcnJvcikge1xuICAgICAgY29uc3QgZ2l0RXJyb3IgPVxuICAgICAgICAgZSBpbnN0YW5jZW9mIEdpdEVycm9yID8gT2JqZWN0LmFzc2lnbihlLCB7IHRhc2sgfSkgOiBuZXcgR2l0RXJyb3IodGFzaywgZSAmJiBTdHJpbmcoZSkpO1xuXG4gICAgICB0aGlzLl9jaGFpbiA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgdGhpcy5fcXVldWUuZmF0YWwoZ2l0RXJyb3IpO1xuXG4gICAgICByZXR1cm4gZ2l0RXJyb3I7XG4gICB9XG5cbiAgIHByaXZhdGUgYXN5bmMgYXR0ZW1wdFJlbW90ZVRhc2s8Uj4odGFzazogUnVubmFibGVUYXNrPFI+LCBsb2dnZXI6IE91dHB1dExvZ2dlcikge1xuICAgICAgY29uc3QgYXJncyA9IHRoaXMuX3BsdWdpbnMuZXhlYyhcbiAgICAgICAgICdzcGF3bi5hcmdzJyxcbiAgICAgICAgIFsuLi50YXNrLmNvbW1hbmRzXSxcbiAgICAgICAgIHBsdWdpbkNvbnRleHQodGFzaywgdGFzay5jb21tYW5kcylcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJhdyA9IGF3YWl0IHRoaXMuZ2l0UmVzcG9uc2UoXG4gICAgICAgICB0YXNrLFxuICAgICAgICAgdGhpcy5iaW5hcnksXG4gICAgICAgICBhcmdzLFxuICAgICAgICAgdGhpcy5vdXRwdXRIYW5kbGVyLFxuICAgICAgICAgbG9nZ2VyLnN0ZXAoJ1NQQVdOJylcbiAgICAgICk7XG4gICAgICBjb25zdCBvdXRwdXRTdHJlYW1zID0gYXdhaXQgdGhpcy5oYW5kbGVUYXNrRGF0YSh0YXNrLCBhcmdzLCByYXcsIGxvZ2dlci5zdGVwKCdIQU5ETEUnKSk7XG5cbiAgICAgIGxvZ2dlcihgcGFzc2luZyByZXNwb25zZSB0byB0YXNrJ3MgcGFyc2VyIGFzIGEgJXNgLCB0YXNrLmZvcm1hdCk7XG5cbiAgICAgIGlmIChpc0J1ZmZlclRhc2sodGFzaykpIHtcbiAgICAgICAgIHJldHVybiBjYWxsVGFza1BhcnNlcih0YXNrLnBhcnNlciwgb3V0cHV0U3RyZWFtcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWxsVGFza1BhcnNlcih0YXNrLnBhcnNlciwgb3V0cHV0U3RyZWFtcy5hc1N0cmluZ3MoKSk7XG4gICB9XG5cbiAgIHByaXZhdGUgYXN5bmMgYXR0ZW1wdEVtcHR5VGFzayh0YXNrOiBFbXB0eVRhc2ssIGxvZ2dlcjogT3V0cHV0TG9nZ2VyKSB7XG4gICAgICBsb2dnZXIoYGVtcHR5IHRhc2sgYnlwYXNzaW5nIGNoaWxkIHByb2Nlc3MgdG8gY2FsbCB0byB0YXNrJ3MgcGFyc2VyYCk7XG4gICAgICByZXR1cm4gdGFzay5wYXJzZXIodGhpcyk7XG4gICB9XG5cbiAgIHByaXZhdGUgaGFuZGxlVGFza0RhdGE8Uj4oXG4gICAgICB0YXNrOiBTaW1wbGVHaXRUYXNrPFI+LFxuICAgICAgYXJnczogc3RyaW5nW10sXG4gICAgICByZXN1bHQ6IEdpdEV4ZWN1dG9yUmVzdWx0LFxuICAgICAgbG9nZ2VyOiBPdXRwdXRMb2dnZXJcbiAgICk6IFByb21pc2U8R2l0T3V0cHV0U3RyZWFtcz4ge1xuICAgICAgY29uc3QgeyBleGl0Q29kZSwgcmVqZWN0aW9uLCBzdGRPdXQsIHN0ZEVyciB9ID0gcmVzdWx0O1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKGRvbmUsIGZhaWwpID0+IHtcbiAgICAgICAgIGxvZ2dlcihgUHJlcGFyaW5nIHRvIGhhbmRsZSBwcm9jZXNzIHJlc3BvbnNlIGV4aXRDb2RlPSVkIHN0ZE91dD1gLCBleGl0Q29kZSk7XG5cbiAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IHRoaXMuX3BsdWdpbnMuZXhlYyhcbiAgICAgICAgICAgICd0YXNrLmVycm9yJyxcbiAgICAgICAgICAgIHsgZXJyb3I6IHJlamVjdGlvbiB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgLi4ucGx1Z2luQ29udGV4dCh0YXNrLCBhcmdzKSxcbiAgICAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICk7XG5cbiAgICAgICAgIGlmIChlcnJvciAmJiB0YXNrLm9uRXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBleGl0Q29kZT0lcyBoYW5kbGluZyB3aXRoIGN1c3RvbSBlcnJvciBoYW5kbGVyYCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0YXNrLm9uRXJyb3IoXG4gICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgIChuZXdTdGRPdXQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBjdXN0b20gZXJyb3IgaGFuZGxlciB0cmVhdGVkIGFzIHN1Y2Nlc3NgKTtcbiAgICAgICAgICAgICAgICAgIGxvZ2dlcihgY3VzdG9tIGVycm9yIHJldHVybmVkIGEgJXNgLCBvYmplY3RUb1N0cmluZyhuZXdTdGRPdXQpKTtcblxuICAgICAgICAgICAgICAgICAgZG9uZShcbiAgICAgICAgICAgICAgICAgICAgIG5ldyBHaXRPdXRwdXRTdHJlYW1zKFxuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShuZXdTdGRPdXQpID8gQnVmZmVyLmNvbmNhdChuZXdTdGRPdXQpIDogbmV3U3RkT3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmNvbmNhdChzdGRFcnIpXG4gICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgIGZhaWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICBgaGFuZGxpbmcgYXMgZXJyb3I6IGV4aXRDb2RlPSVzIHN0ZEVycj0lcyByZWplY3Rpb249JW9gLFxuICAgICAgICAgICAgICAgZXhpdENvZGUsXG4gICAgICAgICAgICAgICBzdGRFcnIubGVuZ3RoLFxuICAgICAgICAgICAgICAgcmVqZWN0aW9uXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGZhaWwoZXJyb3IpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBsb2dnZXIuaW5mbyhgcmV0cmlldmluZyB0YXNrIG91dHB1dCBjb21wbGV0ZWApO1xuICAgICAgICAgZG9uZShuZXcgR2l0T3V0cHV0U3RyZWFtcyhCdWZmZXIuY29uY2F0KHN0ZE91dCksIEJ1ZmZlci5jb25jYXQoc3RkRXJyKSkpO1xuICAgICAgfSk7XG4gICB9XG5cbiAgIHByaXZhdGUgYXN5bmMgZ2l0UmVzcG9uc2U8Uj4oXG4gICAgICB0YXNrOiBTaW1wbGVHaXRUYXNrPFI+LFxuICAgICAgY29tbWFuZDogc3RyaW5nLFxuICAgICAgYXJnczogc3RyaW5nW10sXG4gICAgICBvdXRwdXRIYW5kbGVyOiBNYXliZTxvdXRwdXRIYW5kbGVyPixcbiAgICAgIGxvZ2dlcjogT3V0cHV0TG9nZ2VyXG4gICApOiBQcm9taXNlPEdpdEV4ZWN1dG9yUmVzdWx0PiB7XG4gICAgICBjb25zdCBvdXRwdXRMb2dnZXIgPSBsb2dnZXIuc2libGluZygnb3V0cHV0Jyk7XG4gICAgICBjb25zdCBzcGF3bk9wdGlvbnM6IFNwYXduT3B0aW9ucyA9IHRoaXMuX3BsdWdpbnMuZXhlYyhcbiAgICAgICAgICdzcGF3bi5vcHRpb25zJyxcbiAgICAgICAgIHtcbiAgICAgICAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICAgICAgICBlbnY6IHRoaXMuZW52LFxuICAgICAgICAgICAgd2luZG93c0hpZGU6IHRydWUsXG4gICAgICAgICB9LFxuICAgICAgICAgcGx1Z2luQ29udGV4dCh0YXNrLCB0YXNrLmNvbW1hbmRzKVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChkb25lKSA9PiB7XG4gICAgICAgICBjb25zdCBzdGRPdXQ6IEJ1ZmZlcltdID0gW107XG4gICAgICAgICBjb25zdCBzdGRFcnI6IEJ1ZmZlcltdID0gW107XG5cbiAgICAgICAgIGxvZ2dlci5pbmZvKGAlcyAlb2AsIGNvbW1hbmQsIGFyZ3MpO1xuICAgICAgICAgbG9nZ2VyKCclTycsIHNwYXduT3B0aW9ucyk7XG5cbiAgICAgICAgIGxldCByZWplY3Rpb24gPSB0aGlzLl9iZWZvcmVTcGF3bih0YXNrLCBhcmdzKTtcbiAgICAgICAgIGlmIChyZWplY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKHtcbiAgICAgICAgICAgICAgIHN0ZE91dCxcbiAgICAgICAgICAgICAgIHN0ZEVycixcbiAgICAgICAgICAgICAgIGV4aXRDb2RlOiA5OTAxLFxuICAgICAgICAgICAgICAgcmVqZWN0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX3BsdWdpbnMuZXhlYygnc3Bhd24uYmVmb3JlJywgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAuLi5wbHVnaW5Db250ZXh0KHRhc2ssIGFyZ3MpLFxuICAgICAgICAgICAga2lsbChyZWFzb24pIHtcbiAgICAgICAgICAgICAgIHJlamVjdGlvbiA9IHJlYXNvbiB8fCByZWplY3Rpb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgfSk7XG5cbiAgICAgICAgIGNvbnN0IHNwYXduZWQgPSBzcGF3bihjb21tYW5kLCBhcmdzLCBzcGF3bk9wdGlvbnMpO1xuXG4gICAgICAgICBzcGF3bmVkLnN0ZG91dCEub24oXG4gICAgICAgICAgICAnZGF0YScsXG4gICAgICAgICAgICBvbkRhdGFSZWNlaXZlZChzdGRPdXQsICdzdGRPdXQnLCBsb2dnZXIsIG91dHB1dExvZ2dlci5zdGVwKCdzdGRPdXQnKSlcbiAgICAgICAgICk7XG4gICAgICAgICBzcGF3bmVkLnN0ZGVyciEub24oXG4gICAgICAgICAgICAnZGF0YScsXG4gICAgICAgICAgICBvbkRhdGFSZWNlaXZlZChzdGRFcnIsICdzdGRFcnInLCBsb2dnZXIsIG91dHB1dExvZ2dlci5zdGVwKCdzdGRFcnInKSlcbiAgICAgICAgICk7XG5cbiAgICAgICAgIHNwYXduZWQub24oJ2Vycm9yJywgb25FcnJvclJlY2VpdmVkKHN0ZEVyciwgbG9nZ2VyKSk7XG5cbiAgICAgICAgIGlmIChvdXRwdXRIYW5kbGVyKSB7XG4gICAgICAgICAgICBsb2dnZXIoYFBhc3NpbmcgY2hpbGQgcHJvY2VzcyBzdGRPdXQvc3RkRXJyIHRvIGN1c3RvbSBvdXRwdXRIYW5kbGVyYCk7XG4gICAgICAgICAgICBvdXRwdXRIYW5kbGVyKGNvbW1hbmQsIHNwYXduZWQuc3Rkb3V0ISwgc3Bhd25lZC5zdGRlcnIhLCBbLi4uYXJnc10pO1xuICAgICAgICAgfVxuXG4gICAgICAgICB0aGlzLl9wbHVnaW5zLmV4ZWMoJ3NwYXduLmFmdGVyJywgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAuLi5wbHVnaW5Db250ZXh0KHRhc2ssIGFyZ3MpLFxuICAgICAgICAgICAgc3Bhd25lZCxcbiAgICAgICAgICAgIGNsb3NlKGV4aXRDb2RlOiBudW1iZXIsIHJlYXNvbj86IEVycm9yKSB7XG4gICAgICAgICAgICAgICBkb25lKHtcbiAgICAgICAgICAgICAgICAgIHN0ZE91dCxcbiAgICAgICAgICAgICAgICAgIHN0ZEVycixcbiAgICAgICAgICAgICAgICAgIGV4aXRDb2RlLFxuICAgICAgICAgICAgICAgICAgcmVqZWN0aW9uOiByZWplY3Rpb24gfHwgcmVhc29uLFxuICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2lsbChyZWFzb246IEVycm9yKSB7XG4gICAgICAgICAgICAgICBpZiAoc3Bhd25lZC5raWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgcmVqZWN0aW9uID0gcmVhc29uO1xuICAgICAgICAgICAgICAgc3Bhd25lZC5raWxsKCdTSUdJTlQnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgfVxuXG4gICBwcml2YXRlIF9iZWZvcmVTcGF3bjxSPih0YXNrOiBTaW1wbGVHaXRUYXNrPFI+LCBhcmdzOiBzdHJpbmdbXSkge1xuICAgICAgbGV0IHJlamVjdGlvbjogTWF5YmU8RXJyb3I+O1xuICAgICAgdGhpcy5fcGx1Z2lucy5leGVjKCdzcGF3bi5iZWZvcmUnLCB1bmRlZmluZWQsIHtcbiAgICAgICAgIC4uLnBsdWdpbkNvbnRleHQodGFzaywgYXJncyksXG4gICAgICAgICBraWxsKHJlYXNvbikge1xuICAgICAgICAgICAgcmVqZWN0aW9uID0gcmVhc29uIHx8IHJlamVjdGlvbjtcbiAgICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlamVjdGlvbjtcbiAgIH1cbn1cblxuZnVuY3Rpb24gcGx1Z2luQ29udGV4dDxSPih0YXNrOiBTaW1wbGVHaXRUYXNrPFI+LCBjb21tYW5kczogc3RyaW5nW10pIHtcbiAgIHJldHVybiB7XG4gICAgICBtZXRob2Q6IGZpcnN0KHRhc2suY29tbWFuZHMpIHx8ICcnLFxuICAgICAgY29tbWFuZHMsXG4gICB9O1xufVxuXG5mdW5jdGlvbiBvbkVycm9yUmVjZWl2ZWQodGFyZ2V0OiBCdWZmZXJbXSwgbG9nZ2VyOiBPdXRwdXRMb2dnZXIpIHtcbiAgIHJldHVybiAoZXJyOiBFcnJvcikgPT4ge1xuICAgICAgbG9nZ2VyKGBbRVJST1JdIGNoaWxkIHByb2Nlc3MgZXhjZXB0aW9uICVvYCwgZXJyKTtcbiAgICAgIHRhcmdldC5wdXNoKEJ1ZmZlci5mcm9tKFN0cmluZyhlcnIuc3RhY2spLCAnYXNjaWknKSk7XG4gICB9O1xufVxuXG5mdW5jdGlvbiBvbkRhdGFSZWNlaXZlZChcbiAgIHRhcmdldDogQnVmZmVyW10sXG4gICBuYW1lOiBzdHJpbmcsXG4gICBsb2dnZXI6IE91dHB1dExvZ2dlcixcbiAgIG91dHB1dDogT3V0cHV0TG9nZ2VyXG4pIHtcbiAgIHJldHVybiAoYnVmZmVyOiBCdWZmZXIpID0+IHtcbiAgICAgIGxvZ2dlcihgJXMgcmVjZWl2ZWQgJUwgYnl0ZXNgLCBuYW1lLCBidWZmZXIpO1xuICAgICAgb3V0cHV0KGAlQmAsIGJ1ZmZlcik7XG4gICAgICB0YXJnZXQucHVzaChidWZmZXIpO1xuICAgfTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFBsdWdpblN0b3JlIH0gZnJvbSAnLi4vcGx1Z2lucyc7XG5pbXBvcnQgdHlwZSB7IEdpdEV4ZWN1dG9yRW52LCBvdXRwdXRIYW5kbGVyLCBTaW1wbGVHaXRFeGVjdXRvciwgU2ltcGxlR2l0VGFzayB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgR2l0RXhlY3V0b3JDaGFpbiB9IGZyb20gJy4vZ2l0LWV4ZWN1dG9yLWNoYWluJztcbmltcG9ydCB7IFNjaGVkdWxlciB9IGZyb20gJy4vc2NoZWR1bGVyJztcblxuZXhwb3J0IGNsYXNzIEdpdEV4ZWN1dG9yIGltcGxlbWVudHMgU2ltcGxlR2l0RXhlY3V0b3Ige1xuICAgcHJpdmF0ZSBfY2hhaW4gPSBuZXcgR2l0RXhlY3V0b3JDaGFpbih0aGlzLCB0aGlzLl9zY2hlZHVsZXIsIHRoaXMuX3BsdWdpbnMpO1xuXG4gICBwdWJsaWMgZW52OiBHaXRFeGVjdXRvckVudjtcbiAgIHB1YmxpYyBvdXRwdXRIYW5kbGVyPzogb3V0cHV0SGFuZGxlcjtcblxuICAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgYmluYXJ5OiBzdHJpbmcgPSAnZ2l0JyxcbiAgICAgIHB1YmxpYyBjd2Q6IHN0cmluZyxcbiAgICAgIHByaXZhdGUgX3NjaGVkdWxlcjogU2NoZWR1bGVyLFxuICAgICAgcHJpdmF0ZSBfcGx1Z2luczogUGx1Z2luU3RvcmVcbiAgICkge31cblxuICAgY2hhaW4oKTogU2ltcGxlR2l0RXhlY3V0b3Ige1xuICAgICAgcmV0dXJuIG5ldyBHaXRFeGVjdXRvckNoYWluKHRoaXMsIHRoaXMuX3NjaGVkdWxlciwgdGhpcy5fcGx1Z2lucyk7XG4gICB9XG5cbiAgIHB1c2g8Uj4odGFzazogU2ltcGxlR2l0VGFzazxSPik6IFByb21pc2U8Uj4ge1xuICAgICAgcmV0dXJuIHRoaXMuX2NoYWluLnB1c2godGFzayk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgR2l0RXJyb3IgfSBmcm9tICcuL2Vycm9ycy9naXQtZXJyb3InO1xuaW1wb3J0IHsgR2l0UmVzcG9uc2VFcnJvciB9IGZyb20gJy4vZXJyb3JzL2dpdC1yZXNwb25zZS1lcnJvcic7XG5pbXBvcnQgeyBTaW1wbGVHaXRUYXNrLCBTaW1wbGVHaXRUYXNrQ2FsbGJhY2sgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IE5PT1AgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHRhc2tDYWxsYmFjazxSPihcbiAgIHRhc2s6IFNpbXBsZUdpdFRhc2s8Uj4sXG4gICByZXNwb25zZTogUHJvbWlzZTxSPixcbiAgIGNhbGxiYWNrOiBTaW1wbGVHaXRUYXNrQ2FsbGJhY2s8Uj4gPSBOT09QXG4pIHtcbiAgIGNvbnN0IG9uU3VjY2VzcyA9IChkYXRhOiBSKSA9PiB7XG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgIH07XG5cbiAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyOiBHaXRFcnJvciB8IEdpdFJlc3BvbnNlRXJyb3IpID0+IHtcbiAgICAgIGlmIChlcnI/LnRhc2sgPT09IHRhc2spIHtcbiAgICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgICAgZXJyIGluc3RhbmNlb2YgR2l0UmVzcG9uc2VFcnJvciA/IGFkZERlcHJlY2F0aW9uTm90aWNlVG9FcnJvcihlcnIpIDogZXJyLFxuICAgICAgICAgICAgdW5kZWZpbmVkIGFzIGFueVxuICAgICAgICAgKTtcbiAgICAgIH1cbiAgIH07XG5cbiAgIHJlc3BvbnNlLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKTtcbn1cblxuZnVuY3Rpb24gYWRkRGVwcmVjYXRpb25Ob3RpY2VUb0Vycm9yKGVycjogR2l0UmVzcG9uc2VFcnJvcikge1xuICAgbGV0IGxvZyA9IChuYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgIGBzaW1wbGUtZ2l0IGRlcHJlY2F0aW9uIG5vdGljZTogYWNjZXNzaW5nIEdpdFJlc3BvbnNlRXJyb3IuJHtuYW1lfSBzaG91bGQgYmUgR2l0UmVzcG9uc2VFcnJvci5naXQuJHtuYW1lfSwgdGhpcyB3aWxsIG5vIGxvbmdlciBiZSBhdmFpbGFibGUgaW4gdmVyc2lvbiAzYFxuICAgICAgKTtcbiAgICAgIGxvZyA9IE5PT1A7XG4gICB9O1xuXG4gICByZXR1cm4gT2JqZWN0LmNyZWF0ZShlcnIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVyci5naXQpLnJlZHVjZShkZXNjcmlwdG9yUmVkdWNlciwge30pKTtcblxuICAgZnVuY3Rpb24gZGVzY3JpcHRvclJlZHVjZXIoYWxsOiBQcm9wZXJ0eURlc2NyaXB0b3JNYXAsIG5hbWU6IHN0cmluZyk6IHR5cGVvZiBhbGwge1xuICAgICAgaWYgKG5hbWUgaW4gZXJyKSB7XG4gICAgICAgICByZXR1cm4gYWxsO1xuICAgICAgfVxuXG4gICAgICBhbGxbbmFtZV0gPSB7XG4gICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICBsb2cobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZXJyLmdpdFtuYW1lXTtcbiAgICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gYWxsO1xuICAgfVxufVxuIiwgImltcG9ydCB7IGZvbGRlckV4aXN0cyB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IFNpbXBsZUdpdEV4ZWN1dG9yIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgYWRob2NFeGVjVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGFuZ2VXb3JraW5nRGlyZWN0b3J5VGFzayhkaXJlY3Rvcnk6IHN0cmluZywgcm9vdD86IFNpbXBsZUdpdEV4ZWN1dG9yKSB7XG4gICByZXR1cm4gYWRob2NFeGVjVGFzaygoaW5zdGFuY2U6IFNpbXBsZUdpdEV4ZWN1dG9yKSA9PiB7XG4gICAgICBpZiAoIWZvbGRlckV4aXN0cyhkaXJlY3RvcnkpKSB7XG4gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdpdC5jd2Q6IGNhbm5vdCBjaGFuZ2UgdG8gbm9uLWRpcmVjdG9yeSBcIiR7ZGlyZWN0b3J5fVwiYCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoKHJvb3QgfHwgaW5zdGFuY2UpLmN3ZCA9IGRpcmVjdG9yeSk7XG4gICB9KTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFNpbXBsZUdpdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHR5cGUgeyBTaW1wbGVHaXRBcGkgfSBmcm9tICcuLi9zaW1wbGUtZ2l0LWFwaSc7XG5pbXBvcnQgeyBnZXRUcmFpbGluZ09wdGlvbnMsIHJlbW92ZSwgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmZ1bmN0aW9uIGNoZWNrb3V0VGFzayhhcmdzOiBzdHJpbmdbXSkge1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ2NoZWNrb3V0JywgLi4uYXJnc107XG4gICBpZiAoY29tbWFuZHNbMV0gPT09ICctYicgJiYgY29tbWFuZHMuaW5jbHVkZXMoJy1CJykpIHtcbiAgICAgIGNvbW1hbmRzWzFdID0gcmVtb3ZlKGNvbW1hbmRzLCAnLUInKTtcbiAgIH1cblxuICAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKTogUGljazxTaW1wbGVHaXQsICdjaGVja291dCcgfCAnY2hlY2tvdXRCcmFuY2gnIHwgJ2NoZWNrb3V0TG9jYWxCcmFuY2gnPiB7XG4gICByZXR1cm4ge1xuICAgICAgY2hlY2tvdXQodGhpczogU2ltcGxlR2l0QXBpKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIGNoZWNrb3V0VGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzLCAxKSksXG4gICAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgICAgKTtcbiAgICAgIH0sXG5cbiAgICAgIGNoZWNrb3V0QnJhbmNoKHRoaXM6IFNpbXBsZUdpdEFwaSwgYnJhbmNoTmFtZSwgc3RhcnRQb2ludCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBjaGVja291dFRhc2soWyctYicsIGJyYW5jaE5hbWUsIHN0YXJ0UG9pbnQsIC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXSksXG4gICAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgICAgKTtcbiAgICAgIH0sXG5cbiAgICAgIGNoZWNrb3V0TG9jYWxCcmFuY2godGhpczogU2ltcGxlR2l0QXBpLCBicmFuY2hOYW1lKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIGNoZWNrb3V0VGFzayhbJy1iJywgYnJhbmNoTmFtZSwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cyldKSxcbiAgICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICApO1xuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgQ29tbWl0UmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBMaW5lUGFyc2VyLCBwYXJzZVN0cmluZ1Jlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jb25zdCBwYXJzZXJzOiBMaW5lUGFyc2VyPENvbW1pdFJlc3VsdD5bXSA9IFtcbiAgIG5ldyBMaW5lUGFyc2VyKC9eXFxbKFteXFxzXSspKCBcXChbXildK1xcKSk/IChbXlxcXV0rKS8sIChyZXN1bHQsIFticmFuY2gsIHJvb3QsIGNvbW1pdF0pID0+IHtcbiAgICAgIHJlc3VsdC5icmFuY2ggPSBicmFuY2g7XG4gICAgICByZXN1bHQuY29tbWl0ID0gY29tbWl0O1xuICAgICAgcmVzdWx0LnJvb3QgPSAhIXJvb3Q7XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKC9cXHMqQXV0aG9yOlxccyguKykvaSwgKHJlc3VsdCwgW2F1dGhvcl0pID0+IHtcbiAgICAgIGNvbnN0IHBhcnRzID0gYXV0aG9yLnNwbGl0KCc8Jyk7XG4gICAgICBjb25zdCBlbWFpbCA9IHBhcnRzLnBvcCgpO1xuXG4gICAgICBpZiAoIWVtYWlsIHx8ICFlbWFpbC5pbmNsdWRlcygnQCcpKSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5hdXRob3IgPSB7XG4gICAgICAgICBlbWFpbDogZW1haWwuc3Vic3RyKDAsIGVtYWlsLmxlbmd0aCAtIDEpLFxuICAgICAgICAgbmFtZTogcGFydHMuam9pbignPCcpLnRyaW0oKSxcbiAgICAgIH07XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgLyhcXGQrKVteLF0qKD86LFxccyooXFxkKylbXixdKikoPzosXFxzKihcXGQrKSkvZyxcbiAgICAgIChyZXN1bHQsIFtjaGFuZ2VzLCBpbnNlcnRpb25zLCBkZWxldGlvbnNdKSA9PiB7XG4gICAgICAgICByZXN1bHQuc3VtbWFyeS5jaGFuZ2VzID0gcGFyc2VJbnQoY2hhbmdlcywgMTApIHx8IDA7XG4gICAgICAgICByZXN1bHQuc3VtbWFyeS5pbnNlcnRpb25zID0gcGFyc2VJbnQoaW5zZXJ0aW9ucywgMTApIHx8IDA7XG4gICAgICAgICByZXN1bHQuc3VtbWFyeS5kZWxldGlvbnMgPSBwYXJzZUludChkZWxldGlvbnMsIDEwKSB8fCAwO1xuICAgICAgfVxuICAgKSxcbiAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgL14oXFxkKylbXixdKig/OixcXHMqKFxcZCspW14oXStcXCgoWystXSkpPy8sXG4gICAgICAocmVzdWx0LCBbY2hhbmdlcywgbGluZXMsIGRpcmVjdGlvbl0pID0+IHtcbiAgICAgICAgIHJlc3VsdC5zdW1tYXJ5LmNoYW5nZXMgPSBwYXJzZUludChjaGFuZ2VzLCAxMCkgfHwgMDtcbiAgICAgICAgIGNvbnN0IGNvdW50ID0gcGFyc2VJbnQobGluZXMsIDEwKSB8fCAwO1xuICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJy0nKSB7XG4gICAgICAgICAgICByZXN1bHQuc3VtbWFyeS5kZWxldGlvbnMgPSBjb3VudDtcbiAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnKycpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdW1tYXJ5Lmluc2VydGlvbnMgPSBjb3VudDtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICksXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDb21taXRSZXN1bHQoc3RkT3V0OiBzdHJpbmcpOiBDb21taXRSZXN1bHQge1xuICAgY29uc3QgcmVzdWx0OiBDb21taXRSZXN1bHQgPSB7XG4gICAgICBhdXRob3I6IG51bGwsXG4gICAgICBicmFuY2g6ICcnLFxuICAgICAgY29tbWl0OiAnJyxcbiAgICAgIHJvb3Q6IGZhbHNlLFxuICAgICAgc3VtbWFyeToge1xuICAgICAgICAgY2hhbmdlczogMCxcbiAgICAgICAgIGluc2VydGlvbnM6IDAsXG4gICAgICAgICBkZWxldGlvbnM6IDAsXG4gICAgICB9LFxuICAgfTtcbiAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKHJlc3VsdCwgcGFyc2Vycywgc3RkT3V0KTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IENvbW1pdFJlc3VsdCwgU2ltcGxlR2l0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgdHlwZSB7IFNpbXBsZUdpdEFwaSB9IGZyb20gJy4uL3NpbXBsZS1naXQtYXBpJztcbmltcG9ydCB0eXBlIHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IHBhcnNlQ29tbWl0UmVzdWx0IH0gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZS1jb21taXQnO1xuaW1wb3J0IHtcbiAgIGFzQXJyYXksXG4gICBmaWx0ZXJBcnJheSxcbiAgIGZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXksXG4gICBmaWx0ZXJUeXBlLFxuICAgZ2V0VHJhaWxpbmdPcHRpb25zLFxuICAgcHJlZml4ZWRBcnJheSxcbiAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudCxcbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgY29uZmlndXJhdGlvbkVycm9yVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21taXRUYXNrKFxuICAgbWVzc2FnZTogc3RyaW5nW10sXG4gICBmaWxlczogc3RyaW5nW10sXG4gICBjdXN0b21BcmdzOiBzdHJpbmdbXVxuKTogU3RyaW5nVGFzazxDb21taXRSZXN1bHQ+IHtcbiAgIGNvbnN0IGNvbW1hbmRzOiBzdHJpbmdbXSA9IFtcbiAgICAgICctYycsXG4gICAgICAnY29yZS5hYmJyZXY9NDAnLFxuICAgICAgJ2NvbW1pdCcsXG4gICAgICAuLi5wcmVmaXhlZEFycmF5KG1lc3NhZ2UsICctbScpLFxuICAgICAgLi4uZmlsZXMsXG4gICAgICAuLi5jdXN0b21BcmdzLFxuICAgXTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgcGFyc2VyOiBwYXJzZUNvbW1pdFJlc3VsdCxcbiAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpOiBQaWNrPFNpbXBsZUdpdCwgJ2NvbW1pdCc+IHtcbiAgIHJldHVybiB7XG4gICAgICBjb21taXQodGhpczogU2ltcGxlR2l0QXBpLCBtZXNzYWdlOiBzdHJpbmcgfCBzdHJpbmdbXSwgLi4ucmVzdDogdW5rbm93bltdKSB7XG4gICAgICAgICBjb25zdCBuZXh0ID0gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cyk7XG4gICAgICAgICBjb25zdCB0YXNrID1cbiAgICAgICAgICAgIHJlamVjdERlcHJlY2F0ZWRTaWduYXR1cmVzKG1lc3NhZ2UpIHx8XG4gICAgICAgICAgICBjb21taXRUYXNrKFxuICAgICAgICAgICAgICAgYXNBcnJheShtZXNzYWdlKSxcbiAgICAgICAgICAgICAgIGFzQXJyYXkoZmlsdGVyVHlwZShyZXN0WzBdLCBmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5LCBbXSkpLFxuICAgICAgICAgICAgICAgWy4uLmZpbHRlclR5cGUocmVzdFsxXSwgZmlsdGVyQXJyYXksIFtdKSwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgMCwgdHJ1ZSldXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCBuZXh0KTtcbiAgICAgIH0sXG4gICB9O1xuXG4gICBmdW5jdGlvbiByZWplY3REZXByZWNhdGVkU2lnbmF0dXJlcyhtZXNzYWdlPzogdW5rbm93bikge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgICFmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5KG1lc3NhZ2UpICYmXG4gICAgICAgICBjb25maWd1cmF0aW9uRXJyb3JUYXNrKFxuICAgICAgICAgICAgYGdpdC5jb21taXQ6IHJlcXVpcmVzIHRoZSBjb21taXQgbWVzc2FnZSB0byBiZSBzdXBwbGllZCBhcyBhIHN0cmluZy9zdHJpbmdbXWBcbiAgICAgICAgIClcbiAgICAgICk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgUmVzcG9uc2UsIFNpbXBsZUdpdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgU2ltcGxlR2l0QXBpIH0gZnJvbSAnLi4vc2ltcGxlLWdpdC1hcGknO1xuaW1wb3J0IHsgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpOiBQaWNrPFNpbXBsZUdpdCwgJ2ZpcnN0Q29tbWl0Jz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIGZpcnN0Q29tbWl0KHRoaXM6IFNpbXBsZUdpdEFwaSk6IFJlc3BvbnNlPHN0cmluZz4ge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFsncmV2LWxpc3QnLCAnLS1tYXgtcGFyZW50cz0wJywgJ0hFQUQnXSwgdHJ1ZSksXG4gICAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgICAgKTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImltcG9ydCB7IHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2sgfSBmcm9tICcuL3Rhc2snO1xuaW1wb3J0IHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcblxuLyoqXG4gKiBUYXNrIHVzZWQgYnkgYGdpdC5oYXNoT2JqZWN0YFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaE9iamVjdFRhc2soZmlsZVBhdGg6IHN0cmluZywgd3JpdGU6IGJvb2xlYW4pOiBTdHJpbmdUYXNrPHN0cmluZz4ge1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ2hhc2gtb2JqZWN0JywgZmlsZVBhdGhdO1xuICAgaWYgKHdyaXRlKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKCctdycpO1xuICAgfVxuXG4gICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kcywgdHJ1ZSk7XG59XG4iLCAiaW1wb3J0IHsgSW5pdFJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuXG5leHBvcnQgY2xhc3MgSW5pdFN1bW1hcnkgaW1wbGVtZW50cyBJbml0UmVzdWx0IHtcbiAgIGNvbnN0cnVjdG9yKFxuICAgICAgcHVibGljIHJlYWRvbmx5IGJhcmU6IGJvb2xlYW4sXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgcGF0aDogc3RyaW5nLFxuICAgICAgcHVibGljIHJlYWRvbmx5IGV4aXN0aW5nOiBib29sZWFuLFxuICAgICAgcHVibGljIHJlYWRvbmx5IGdpdERpcjogc3RyaW5nXG4gICApIHt9XG59XG5cbmNvbnN0IGluaXRSZXNwb25zZVJlZ2V4ID0gL15Jbml0LisgcmVwb3NpdG9yeSBpbiAoLispJC87XG5jb25zdCByZUluaXRSZXNwb25zZVJlZ2V4ID0gL15SZWluLisgaW4gKC4rKSQvO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJbml0KGJhcmU6IGJvb2xlYW4sIHBhdGg6IHN0cmluZywgdGV4dDogc3RyaW5nKSB7XG4gICBjb25zdCByZXNwb25zZSA9IFN0cmluZyh0ZXh0KS50cmltKCk7XG4gICBsZXQgcmVzdWx0O1xuXG4gICBpZiAoKHJlc3VsdCA9IGluaXRSZXNwb25zZVJlZ2V4LmV4ZWMocmVzcG9uc2UpKSkge1xuICAgICAgcmV0dXJuIG5ldyBJbml0U3VtbWFyeShiYXJlLCBwYXRoLCBmYWxzZSwgcmVzdWx0WzFdKTtcbiAgIH1cblxuICAgaWYgKChyZXN1bHQgPSByZUluaXRSZXNwb25zZVJlZ2V4LmV4ZWMocmVzcG9uc2UpKSkge1xuICAgICAgcmV0dXJuIG5ldyBJbml0U3VtbWFyeShiYXJlLCBwYXRoLCB0cnVlLCByZXN1bHRbMV0pO1xuICAgfVxuXG4gICBsZXQgZ2l0RGlyID0gJyc7XG4gICBjb25zdCB0b2tlbnMgPSByZXNwb25zZS5zcGxpdCgnICcpO1xuICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG4gICAgICBpZiAodG9rZW4gPT09ICdpbicpIHtcbiAgICAgICAgIGdpdERpciA9IHRva2Vucy5qb2luKCcgJyk7XG4gICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgIH1cblxuICAgcmV0dXJuIG5ldyBJbml0U3VtbWFyeShiYXJlLCBwYXRoLCAvXnJlL2kudGVzdChyZXNwb25zZSksIGdpdERpcik7XG59XG4iLCAiaW1wb3J0IHsgSW5pdFJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgcGFyc2VJbml0IH0gZnJvbSAnLi4vcmVzcG9uc2VzL0luaXRTdW1tYXJ5JztcbmltcG9ydCB7IFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IGJhcmVDb21tYW5kID0gJy0tYmFyZSc7XG5cbmZ1bmN0aW9uIGhhc0JhcmVDb21tYW5kKGNvbW1hbmQ6IHN0cmluZ1tdKSB7XG4gICByZXR1cm4gY29tbWFuZC5pbmNsdWRlcyhiYXJlQ29tbWFuZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0VGFzayhiYXJlID0gZmFsc2UsIHBhdGg6IHN0cmluZywgY3VzdG9tQXJnczogc3RyaW5nW10pOiBTdHJpbmdUYXNrPEluaXRSZXN1bHQ+IHtcbiAgIGNvbnN0IGNvbW1hbmRzID0gWydpbml0JywgLi4uY3VzdG9tQXJnc107XG4gICBpZiAoYmFyZSAmJiAhaGFzQmFyZUNvbW1hbmQoY29tbWFuZHMpKSB7XG4gICAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgYmFyZUNvbW1hbmQpO1xuICAgfVxuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXIodGV4dDogc3RyaW5nKTogSW5pdFJlc3VsdCB7XG4gICAgICAgICByZXR1cm4gcGFyc2VJbml0KGNvbW1hbmRzLmluY2x1ZGVzKCctLWJhcmUnKSwgcGF0aCwgdGV4dCk7XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJleHBvcnQgZW51bSBMb2dGb3JtYXQge1xuICAgTk9ORSA9ICcnLFxuICAgU1RBVCA9ICctLXN0YXQnLFxuICAgTlVNX1NUQVQgPSAnLS1udW1zdGF0JyxcbiAgIE5BTUVfT05MWSA9ICctLW5hbWUtb25seScsXG4gICBOQU1FX1NUQVRVUyA9ICctLW5hbWUtc3RhdHVzJyxcbn1cblxuY29uc3QgbG9nRm9ybWF0UmVnZXggPSAvXi0tKHN0YXR8bnVtc3RhdHxuYW1lLW9ubHl8bmFtZS1zdGF0dXMpKD18JCkvO1xuXG5leHBvcnQgZnVuY3Rpb24gbG9nRm9ybWF0RnJvbUNvbW1hbmQoY3VzdG9tQXJnczogc3RyaW5nW10pIHtcbiAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VzdG9tQXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZm9ybWF0ID0gbG9nRm9ybWF0UmVnZXguZXhlYyhjdXN0b21BcmdzW2ldKTtcbiAgICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgIHJldHVybiBgLS0ke2Zvcm1hdFsxXX1gIGFzIExvZ0Zvcm1hdDtcbiAgICAgIH1cbiAgIH1cblxuICAgcmV0dXJuIExvZ0Zvcm1hdC5OT05FO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNMb2dGb3JtYXQoY3VzdG9tQXJnOiBzdHJpbmcgfCB1bmtub3duKSB7XG4gICByZXR1cm4gbG9nRm9ybWF0UmVnZXgudGVzdChjdXN0b21BcmcgYXMgc3RyaW5nKTtcbn1cbiIsICJpbXBvcnQgeyBEaWZmUmVzdWx0LCBEaWZmUmVzdWx0QmluYXJ5RmlsZSwgRGlmZlJlc3VsdFRleHRGaWxlIH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5cbi8qKipcbiAqIFRoZSBEaWZmU3VtbWFyeSBpcyByZXR1cm5lZCBhcyBhIHJlc3BvbnNlIHRvIGdldHRpbmcgYGdpdCgpLnN0YXR1cygpYFxuICovXG5leHBvcnQgY2xhc3MgRGlmZlN1bW1hcnkgaW1wbGVtZW50cyBEaWZmUmVzdWx0IHtcbiAgIGNoYW5nZWQgPSAwO1xuICAgZGVsZXRpb25zID0gMDtcbiAgIGluc2VydGlvbnMgPSAwO1xuXG4gICBmaWxlczogQXJyYXk8RGlmZlJlc3VsdFRleHRGaWxlIHwgRGlmZlJlc3VsdEJpbmFyeUZpbGU+ID0gW107XG59XG4iLCAiaW1wb3J0IHsgRGlmZlJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgTG9nRm9ybWF0IH0gZnJvbSAnLi4vYXJncy9sb2ctZm9ybWF0JztcbmltcG9ydCB7IERpZmZTdW1tYXJ5IH0gZnJvbSAnLi4vcmVzcG9uc2VzL0RpZmZTdW1tYXJ5JztcbmltcG9ydCB7IGlzRGlmZk5hbWVTdGF0dXMgfSBmcm9tICcuLi90YXNrcy9kaWZmLW5hbWUtc3RhdHVzJztcbmltcG9ydCB7IGFzTnVtYmVyLCBMaW5lUGFyc2VyLCBvclZvaWQsIHBhcnNlU3RyaW5nUmVzcG9uc2UgfSBmcm9tICcuLi91dGlscyc7XG5cbmNvbnN0IHN0YXRQYXJzZXIgPSBbXG4gICBuZXcgTGluZVBhcnNlcjxEaWZmUmVzdWx0PihcbiAgICAgIC8oLispXFxzK1xcfFxccysoXFxkKykoXFxzK1srXFwtXSspPyQvLFxuICAgICAgKHJlc3VsdCwgW2ZpbGUsIGNoYW5nZXMsIGFsdGVyYXRpb25zID0gJyddKSA9PiB7XG4gICAgICAgICByZXN1bHQuZmlsZXMucHVzaCh7XG4gICAgICAgICAgICBmaWxlOiBmaWxlLnRyaW0oKSxcbiAgICAgICAgICAgIGNoYW5nZXM6IGFzTnVtYmVyKGNoYW5nZXMpLFxuICAgICAgICAgICAgaW5zZXJ0aW9uczogYWx0ZXJhdGlvbnMucmVwbGFjZSgvW14rXS9nLCAnJykubGVuZ3RoLFxuICAgICAgICAgICAgZGVsZXRpb25zOiBhbHRlcmF0aW9ucy5yZXBsYWNlKC9bXi1dL2csICcnKS5sZW5ndGgsXG4gICAgICAgICAgICBiaW5hcnk6IGZhbHNlLFxuICAgICAgICAgfSk7XG4gICAgICB9XG4gICApLFxuICAgbmV3IExpbmVQYXJzZXI8RGlmZlJlc3VsdD4oXG4gICAgICAvKC4rKSBcXHxcXHMrQmluIChbMC05Ll0rKSAtPiAoWzAtOS5dKykgKFthLXpdKykvLFxuICAgICAgKHJlc3VsdCwgW2ZpbGUsIGJlZm9yZSwgYWZ0ZXJdKSA9PiB7XG4gICAgICAgICByZXN1bHQuZmlsZXMucHVzaCh7XG4gICAgICAgICAgICBmaWxlOiBmaWxlLnRyaW0oKSxcbiAgICAgICAgICAgIGJlZm9yZTogYXNOdW1iZXIoYmVmb3JlKSxcbiAgICAgICAgICAgIGFmdGVyOiBhc051bWJlcihhZnRlciksXG4gICAgICAgICAgICBiaW5hcnk6IHRydWUsXG4gICAgICAgICB9KTtcbiAgICAgIH1cbiAgICksXG4gICBuZXcgTGluZVBhcnNlcjxEaWZmUmVzdWx0PihcbiAgICAgIC8oXFxkKykgZmlsZXM/IGNoYW5nZWRcXHMqKCg/OiwgXFxkKyBbXixdKyl7MCwyfSkvLFxuICAgICAgKHJlc3VsdCwgW2NoYW5nZWQsIHN1bW1hcnldKSA9PiB7XG4gICAgICAgICBjb25zdCBpbnNlcnRlZCA9IC8oXFxkKykgaS8uZXhlYyhzdW1tYXJ5KTtcbiAgICAgICAgIGNvbnN0IGRlbGV0ZWQgPSAvKFxcZCspIGQvLmV4ZWMoc3VtbWFyeSk7XG5cbiAgICAgICAgIHJlc3VsdC5jaGFuZ2VkID0gYXNOdW1iZXIoY2hhbmdlZCk7XG4gICAgICAgICByZXN1bHQuaW5zZXJ0aW9ucyA9IGFzTnVtYmVyKGluc2VydGVkPy5bMV0pO1xuICAgICAgICAgcmVzdWx0LmRlbGV0aW9ucyA9IGFzTnVtYmVyKGRlbGV0ZWQ/LlsxXSk7XG4gICAgICB9XG4gICApLFxuXTtcblxuY29uc3QgbnVtU3RhdFBhcnNlciA9IFtcbiAgIG5ldyBMaW5lUGFyc2VyPERpZmZSZXN1bHQ+KFxuICAgICAgLyhcXGQrKVxcdChcXGQrKVxcdCguKykkLyxcbiAgICAgIChyZXN1bHQsIFtjaGFuZ2VzSW5zZXJ0LCBjaGFuZ2VzRGVsZXRlLCBmaWxlXSkgPT4ge1xuICAgICAgICAgY29uc3QgaW5zZXJ0aW9ucyA9IGFzTnVtYmVyKGNoYW5nZXNJbnNlcnQpO1xuICAgICAgICAgY29uc3QgZGVsZXRpb25zID0gYXNOdW1iZXIoY2hhbmdlc0RlbGV0ZSk7XG5cbiAgICAgICAgIHJlc3VsdC5jaGFuZ2VkKys7XG4gICAgICAgICByZXN1bHQuaW5zZXJ0aW9ucyArPSBpbnNlcnRpb25zO1xuICAgICAgICAgcmVzdWx0LmRlbGV0aW9ucyArPSBkZWxldGlvbnM7XG5cbiAgICAgICAgIHJlc3VsdC5maWxlcy5wdXNoKHtcbiAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICBjaGFuZ2VzOiBpbnNlcnRpb25zICsgZGVsZXRpb25zLFxuICAgICAgICAgICAgaW5zZXJ0aW9ucyxcbiAgICAgICAgICAgIGRlbGV0aW9ucyxcbiAgICAgICAgICAgIGJpbmFyeTogZmFsc2UsXG4gICAgICAgICB9KTtcbiAgICAgIH1cbiAgICksXG4gICBuZXcgTGluZVBhcnNlcjxEaWZmUmVzdWx0PigvLVxcdC1cXHQoLispJC8sIChyZXN1bHQsIFtmaWxlXSkgPT4ge1xuICAgICAgcmVzdWx0LmNoYW5nZWQrKztcblxuICAgICAgcmVzdWx0LmZpbGVzLnB1c2goe1xuICAgICAgICAgZmlsZSxcbiAgICAgICAgIGFmdGVyOiAwLFxuICAgICAgICAgYmVmb3JlOiAwLFxuICAgICAgICAgYmluYXJ5OiB0cnVlLFxuICAgICAgfSk7XG4gICB9KSxcbl07XG5cbmNvbnN0IG5hbWVPbmx5UGFyc2VyID0gW1xuICAgbmV3IExpbmVQYXJzZXI8RGlmZlJlc3VsdD4oLyguKykkLywgKHJlc3VsdCwgW2ZpbGVdKSA9PiB7XG4gICAgICByZXN1bHQuY2hhbmdlZCsrO1xuICAgICAgcmVzdWx0LmZpbGVzLnB1c2goe1xuICAgICAgICAgZmlsZSxcbiAgICAgICAgIGNoYW5nZXM6IDAsXG4gICAgICAgICBpbnNlcnRpb25zOiAwLFxuICAgICAgICAgZGVsZXRpb25zOiAwLFxuICAgICAgICAgYmluYXJ5OiBmYWxzZSxcbiAgICAgIH0pO1xuICAgfSksXG5dO1xuXG5jb25zdCBuYW1lU3RhdHVzUGFyc2VyID0gW1xuICAgbmV3IExpbmVQYXJzZXI8RGlmZlJlc3VsdD4oXG4gICAgICAvKFtBQ0RNUlRVWEJdKShbMC05XXswLDN9KVxcdCguW15cXHRdKikoXFx0KC5bXlxcdF0qKSk/JC8sXG4gICAgICAocmVzdWx0LCBbc3RhdHVzLCBfc2ltaWxhcml0eSwgZnJvbSwgX3RvLCB0b10pID0+IHtcbiAgICAgICAgIHJlc3VsdC5jaGFuZ2VkKys7XG4gICAgICAgICByZXN1bHQuZmlsZXMucHVzaCh7XG4gICAgICAgICAgICBmaWxlOiB0byA/PyBmcm9tLFxuICAgICAgICAgICAgY2hhbmdlczogMCxcbiAgICAgICAgICAgIHN0YXR1czogb3JWb2lkKGlzRGlmZk5hbWVTdGF0dXMoc3RhdHVzKSAmJiBzdGF0dXMpLFxuICAgICAgICAgICAgaW5zZXJ0aW9uczogMCxcbiAgICAgICAgICAgIGRlbGV0aW9uczogMCxcbiAgICAgICAgICAgIGJpbmFyeTogZmFsc2UsXG4gICAgICAgICB9KTtcbiAgICAgIH1cbiAgICksXG5dO1xuXG5jb25zdCBkaWZmU3VtbWFyeVBhcnNlcnM6IFJlY29yZDxMb2dGb3JtYXQsIExpbmVQYXJzZXI8RGlmZlJlc3VsdD5bXT4gPSB7XG4gICBbTG9nRm9ybWF0Lk5PTkVdOiBzdGF0UGFyc2VyLFxuICAgW0xvZ0Zvcm1hdC5TVEFUXTogc3RhdFBhcnNlcixcbiAgIFtMb2dGb3JtYXQuTlVNX1NUQVRdOiBudW1TdGF0UGFyc2VyLFxuICAgW0xvZ0Zvcm1hdC5OQU1FX1NUQVRVU106IG5hbWVTdGF0dXNQYXJzZXIsXG4gICBbTG9nRm9ybWF0Lk5BTUVfT05MWV06IG5hbWVPbmx5UGFyc2VyLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpZmZQYXJzZXIoZm9ybWF0ID0gTG9nRm9ybWF0Lk5PTkUpIHtcbiAgIGNvbnN0IHBhcnNlciA9IGRpZmZTdW1tYXJ5UGFyc2Vyc1tmb3JtYXRdO1xuXG4gICByZXR1cm4gKHN0ZE91dDogc3RyaW5nKSA9PiBwYXJzZVN0cmluZ1Jlc3BvbnNlKG5ldyBEaWZmU3VtbWFyeSgpLCBwYXJzZXIsIHN0ZE91dCwgZmFsc2UpO1xufVxuIiwgImltcG9ydCB7IExpc3RMb2dMaW5lLCBMb2dSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IHRvTGluZXNXaXRoQ29udGVudCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IGdldERpZmZQYXJzZXIgfSBmcm9tICcuL3BhcnNlLWRpZmYtc3VtbWFyeSc7XG5pbXBvcnQgeyBMb2dGb3JtYXQgfSBmcm9tICcuLi9hcmdzL2xvZy1mb3JtYXQnO1xuXG5leHBvcnQgY29uc3QgU1RBUlRfQk9VTkRBUlkgPSAnXHUwMEYyXHUwMEYyXHUwMEYyXHUwMEYyXHUwMEYyXHUwMEYyICc7XG5cbmV4cG9ydCBjb25zdCBDT01NSVRfQk9VTkRBUlkgPSAnIFx1MDBGMlx1MDBGMic7XG5cbmV4cG9ydCBjb25zdCBTUExJVFRFUiA9ICcgXHUwMEYyICc7XG5cbmNvbnN0IGRlZmF1bHRGaWVsZE5hbWVzID0gWydoYXNoJywgJ2RhdGUnLCAnbWVzc2FnZScsICdyZWZzJywgJ2F1dGhvcl9uYW1lJywgJ2F1dGhvcl9lbWFpbCddO1xuXG5mdW5jdGlvbiBsaW5lQnVpbGRlcih0b2tlbnM6IHN0cmluZ1tdLCBmaWVsZHM6IHN0cmluZ1tdKTogYW55IHtcbiAgIHJldHVybiBmaWVsZHMucmVkdWNlKFxuICAgICAgKGxpbmUsIGZpZWxkLCBpbmRleCkgPT4ge1xuICAgICAgICAgbGluZVtmaWVsZF0gPSB0b2tlbnNbaW5kZXhdIHx8ICcnO1xuICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICB9LFxuICAgICAgT2JqZWN0LmNyZWF0ZSh7IGRpZmY6IG51bGwgfSkgYXMgYW55XG4gICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGlzdExvZ1N1bW1hcnlQYXJzZXI8VCA9IGFueT4oXG4gICBzcGxpdHRlciA9IFNQTElUVEVSLFxuICAgZmllbGRzID0gZGVmYXVsdEZpZWxkTmFtZXMsXG4gICBsb2dGb3JtYXQgPSBMb2dGb3JtYXQuTk9ORVxuKSB7XG4gICBjb25zdCBwYXJzZURpZmZSZXN1bHQgPSBnZXREaWZmUGFyc2VyKGxvZ0Zvcm1hdCk7XG5cbiAgIHJldHVybiBmdW5jdGlvbiAoc3RkT3V0OiBzdHJpbmcpOiBMb2dSZXN1bHQ8VD4ge1xuICAgICAgY29uc3QgYWxsOiBSZWFkb25seUFycmF5PFQgJiBMaXN0TG9nTGluZT4gPSB0b0xpbmVzV2l0aENvbnRlbnQoXG4gICAgICAgICBzdGRPdXQsXG4gICAgICAgICB0cnVlLFxuICAgICAgICAgU1RBUlRfQk9VTkRBUllcbiAgICAgICkubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICBjb25zdCBsaW5lRGV0YWlsID0gaXRlbS50cmltKCkuc3BsaXQoQ09NTUlUX0JPVU5EQVJZKTtcbiAgICAgICAgIGNvbnN0IGxpc3RMb2dMaW5lOiBUICYgTGlzdExvZ0xpbmUgPSBsaW5lQnVpbGRlcihcbiAgICAgICAgICAgIGxpbmVEZXRhaWxbMF0udHJpbSgpLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgICAgICAgIGZpZWxkc1xuICAgICAgICAgKTtcblxuICAgICAgICAgaWYgKGxpbmVEZXRhaWwubGVuZ3RoID4gMSAmJiAhIWxpbmVEZXRhaWxbMV0udHJpbSgpKSB7XG4gICAgICAgICAgICBsaXN0TG9nTGluZS5kaWZmID0gcGFyc2VEaWZmUmVzdWx0KGxpbmVEZXRhaWxbMV0pO1xuICAgICAgICAgfVxuXG4gICAgICAgICByZXR1cm4gbGlzdExvZ0xpbmU7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgIGFsbCxcbiAgICAgICAgIGxhdGVzdDogKGFsbC5sZW5ndGggJiYgYWxsWzBdKSB8fCBudWxsLFxuICAgICAgICAgdG90YWw6IGFsbC5sZW5ndGgsXG4gICAgICB9O1xuICAgfTtcbn1cbiIsICJpbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgRGlmZlJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgaXNMb2dGb3JtYXQsIExvZ0Zvcm1hdCwgbG9nRm9ybWF0RnJvbUNvbW1hbmQgfSBmcm9tICcuLi9hcmdzL2xvZy1mb3JtYXQnO1xuaW1wb3J0IHsgZ2V0RGlmZlBhcnNlciB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtZGlmZi1zdW1tYXJ5JztcbmltcG9ydCB7IGNvbmZpZ3VyYXRpb25FcnJvclRhc2ssIEVtcHR5VGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmU3VtbWFyeVRhc2soY3VzdG9tQXJnczogc3RyaW5nW10pOiBTdHJpbmdUYXNrPERpZmZSZXN1bHQ+IHwgRW1wdHlUYXNrIHtcbiAgIGxldCBsb2dGb3JtYXQgPSBsb2dGb3JtYXRGcm9tQ29tbWFuZChjdXN0b21BcmdzKTtcblxuICAgY29uc3QgY29tbWFuZHMgPSBbJ2RpZmYnXTtcblxuICAgaWYgKGxvZ0Zvcm1hdCA9PT0gTG9nRm9ybWF0Lk5PTkUpIHtcbiAgICAgIGxvZ0Zvcm1hdCA9IExvZ0Zvcm1hdC5TVEFUO1xuICAgICAgY29tbWFuZHMucHVzaCgnLS1zdGF0PTQwOTYnKTtcbiAgIH1cblxuICAgY29tbWFuZHMucHVzaCguLi5jdXN0b21BcmdzKTtcblxuICAgcmV0dXJuIChcbiAgICAgIHZhbGlkYXRlTG9nRm9ybWF0Q29uZmlnKGNvbW1hbmRzKSB8fCB7XG4gICAgICAgICBjb21tYW5kcyxcbiAgICAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgICAgIHBhcnNlcjogZ2V0RGlmZlBhcnNlcihsb2dGb3JtYXQpLFxuICAgICAgfVxuICAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTG9nRm9ybWF0Q29uZmlnKGN1c3RvbUFyZ3M6IHVua25vd25bXSk6IEVtcHR5VGFzayB8IHZvaWQge1xuICAgY29uc3QgZmxhZ3MgPSBjdXN0b21BcmdzLmZpbHRlcihpc0xvZ0Zvcm1hdCk7XG5cbiAgIGlmIChmbGFncy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhcbiAgICAgICAgIGBTdW1tYXJ5IGZsYWdzIGFyZSBtdXR1YWxseSBleGNsdXNpdmUgLSBwaWNrIG9uZSBvZiAke2ZsYWdzLmpvaW4oJywnKX1gXG4gICAgICApO1xuICAgfVxuXG4gICBpZiAoZmxhZ3MubGVuZ3RoICYmIGN1c3RvbUFyZ3MuaW5jbHVkZXMoJy16JykpIHtcbiAgICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKFxuICAgICAgICAgYFN1bW1hcnkgZmxhZyAke2ZsYWdzfSBwYXJzaW5nIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggbnVsbCB0ZXJtaW5hdGlvbiBvcHRpb24gJy16J2BcbiAgICAgICk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBPcHRpb25zLCBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHR5cGUgeyBMb2dSZXN1bHQsIFNpbXBsZUdpdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgbG9nRm9ybWF0RnJvbUNvbW1hbmQgfSBmcm9tICcuLi9hcmdzL2xvZy1mb3JtYXQnO1xuaW1wb3J0IHsgcGF0aHNwZWMgfSBmcm9tICcuLi9hcmdzL3BhdGhzcGVjJztcbmltcG9ydCB7XG4gICBDT01NSVRfQk9VTkRBUlksXG4gICBjcmVhdGVMaXN0TG9nU3VtbWFyeVBhcnNlcixcbiAgIFNQTElUVEVSLFxuICAgU1RBUlRfQk9VTkRBUlksXG59IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtbGlzdC1sb2ctc3VtbWFyeSc7XG5pbXBvcnQge1xuICAgYXBwZW5kVGFza09wdGlvbnMsXG4gICBmaWx0ZXJBcnJheSxcbiAgIGZpbHRlclByaW1pdGl2ZXMsXG4gICBmaWx0ZXJTdHJpbmcsXG4gICBmaWx0ZXJUeXBlLFxuICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50LFxuICAgdHJhaWxpbmdPcHRpb25zQXJndW1lbnQsXG59IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IFNpbXBsZUdpdEFwaSB9IGZyb20gJy4uL3NpbXBsZS1naXQtYXBpJztcbmltcG9ydCB7IGNvbmZpZ3VyYXRpb25FcnJvclRhc2sgfSBmcm9tICcuL3Rhc2snO1xuaW1wb3J0IHsgdmFsaWRhdGVMb2dGb3JtYXRDb25maWcgfSBmcm9tICcuL2RpZmYnO1xuXG5lbnVtIGV4Y2x1ZGVPcHRpb25zIHtcbiAgICctLXByZXR0eScsXG4gICAnbWF4LWNvdW50JyxcbiAgICdtYXhDb3VudCcsXG4gICAnbicsXG4gICAnZmlsZScsXG4gICAnZm9ybWF0JyxcbiAgICdmcm9tJyxcbiAgICd0bycsXG4gICAnc3BsaXR0ZXInLFxuICAgJ3N5bW1ldHJpYycsXG4gICAnbWFpbE1hcCcsXG4gICAnbXVsdGlMaW5lJyxcbiAgICdzdHJpY3REYXRlJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZWZhdWx0TG9nRmllbGRzIHtcbiAgIGhhc2g6IHN0cmluZztcbiAgIGRhdGU6IHN0cmluZztcbiAgIG1lc3NhZ2U6IHN0cmluZztcbiAgIHJlZnM6IHN0cmluZztcbiAgIGJvZHk6IHN0cmluZztcbiAgIGF1dGhvcl9uYW1lOiBzdHJpbmc7XG4gICBhdXRob3JfZW1haWw6IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgTG9nT3B0aW9uczxUID0gRGVmYXVsdExvZ0ZpZWxkcz4gPSB7XG4gICBmaWxlPzogc3RyaW5nO1xuICAgZm9ybWF0PzogVDtcbiAgIGZyb20/OiBzdHJpbmc7XG4gICBtYWlsTWFwPzogYm9vbGVhbjtcbiAgIG1heENvdW50PzogbnVtYmVyO1xuICAgbXVsdGlMaW5lPzogYm9vbGVhbjtcbiAgIHNwbGl0dGVyPzogc3RyaW5nO1xuICAgc3RyaWN0RGF0ZT86IGJvb2xlYW47XG4gICBzeW1tZXRyaWM/OiBib29sZWFuO1xuICAgdG8/OiBzdHJpbmc7XG59O1xuXG5pbnRlcmZhY2UgUGFyc2VkTG9nT3B0aW9ucyB7XG4gICBmaWVsZHM6IHN0cmluZ1tdO1xuICAgc3BsaXR0ZXI6IHN0cmluZztcbiAgIGNvbW1hbmRzOiBzdHJpbmdbXTtcbn1cblxuZnVuY3Rpb24gcHJldHR5Rm9ybWF0KFxuICAgZm9ybWF0OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmtub3duPixcbiAgIHNwbGl0dGVyOiBzdHJpbmdcbik6IFtzdHJpbmdbXSwgc3RyaW5nXSB7XG4gICBjb25zdCBmaWVsZHM6IHN0cmluZ1tdID0gW107XG4gICBjb25zdCBmb3JtYXRTdHI6IHN0cmluZ1tdID0gW107XG5cbiAgIE9iamVjdC5rZXlzKGZvcm1hdCkuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgIGZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgIGZvcm1hdFN0ci5wdXNoKFN0cmluZyhmb3JtYXRbZmllbGRdKSk7XG4gICB9KTtcblxuICAgcmV0dXJuIFtmaWVsZHMsIGZvcm1hdFN0ci5qb2luKHNwbGl0dGVyKV07XG59XG5cbmZ1bmN0aW9uIHVzZXJPcHRpb25zPFQgZXh0ZW5kcyBPcHRpb25zPihpbnB1dDogVCk6IE9wdGlvbnMge1xuICAgcmV0dXJuIE9iamVjdC5rZXlzKGlucHV0KS5yZWR1Y2UoKG91dCwga2V5KSA9PiB7XG4gICAgICBpZiAoIShrZXkgaW4gZXhjbHVkZU9wdGlvbnMpKSB7XG4gICAgICAgICBvdXRba2V5XSA9IGlucHV0W2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgfSwge30gYXMgT3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUxvZ09wdGlvbnM8VCBleHRlbmRzIE9wdGlvbnM+KFxuICAgb3B0OiBPcHRpb25zIHwgTG9nT3B0aW9uczxUPiA9IHt9LFxuICAgY3VzdG9tQXJnczogc3RyaW5nW10gPSBbXVxuKTogUGFyc2VkTG9nT3B0aW9ucyB7XG4gICBjb25zdCBzcGxpdHRlciA9IGZpbHRlclR5cGUob3B0LnNwbGl0dGVyLCBmaWx0ZXJTdHJpbmcsIFNQTElUVEVSKTtcbiAgIGNvbnN0IGZvcm1hdCA9XG4gICAgICAhZmlsdGVyUHJpbWl0aXZlcyhvcHQuZm9ybWF0KSAmJiBvcHQuZm9ybWF0XG4gICAgICAgICA/IG9wdC5mb3JtYXRcbiAgICAgICAgIDoge1xuICAgICAgICAgICAgICBoYXNoOiAnJUgnLFxuICAgICAgICAgICAgICBkYXRlOiBvcHQuc3RyaWN0RGF0ZSA9PT0gZmFsc2UgPyAnJWFpJyA6ICclYUknLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnJXMnLFxuICAgICAgICAgICAgICByZWZzOiAnJUQnLFxuICAgICAgICAgICAgICBib2R5OiBvcHQubXVsdGlMaW5lID8gJyVCJyA6ICclYicsXG4gICAgICAgICAgICAgIGF1dGhvcl9uYW1lOiBvcHQubWFpbE1hcCAhPT0gZmFsc2UgPyAnJWFOJyA6ICclYW4nLFxuICAgICAgICAgICAgICBhdXRob3JfZW1haWw6IG9wdC5tYWlsTWFwICE9PSBmYWxzZSA/ICclYUUnIDogJyVhZScsXG4gICAgICAgICAgIH07XG5cbiAgIGNvbnN0IFtmaWVsZHMsIGZvcm1hdFN0cl0gPSBwcmV0dHlGb3JtYXQoZm9ybWF0LCBzcGxpdHRlcik7XG5cbiAgIGNvbnN0IHN1ZmZpeDogc3RyaW5nW10gPSBbXTtcbiAgIGNvbnN0IGNvbW1hbmQ6IHN0cmluZ1tdID0gW1xuICAgICAgYC0tcHJldHR5PWZvcm1hdDoke1NUQVJUX0JPVU5EQVJZfSR7Zm9ybWF0U3RyfSR7Q09NTUlUX0JPVU5EQVJZfWAsXG4gICAgICAuLi5jdXN0b21BcmdzLFxuICAgXTtcblxuICAgY29uc3QgbWF4Q291bnQ6IG51bWJlciB8IHVuZGVmaW5lZCA9IChvcHQgYXMgYW55KS5uIHx8IChvcHQgYXMgYW55KVsnbWF4LWNvdW50J10gfHwgb3B0Lm1heENvdW50O1xuICAgaWYgKG1heENvdW50KSB7XG4gICAgICBjb21tYW5kLnB1c2goYC0tbWF4LWNvdW50PSR7bWF4Q291bnR9YCk7XG4gICB9XG5cbiAgIGlmIChvcHQuZnJvbSB8fCBvcHQudG8pIHtcbiAgICAgIGNvbnN0IHJhbmdlT3BlcmF0b3IgPSBvcHQuc3ltbWV0cmljICE9PSBmYWxzZSA/ICcuLi4nIDogJy4uJztcbiAgICAgIHN1ZmZpeC5wdXNoKGAke29wdC5mcm9tIHx8ICcnfSR7cmFuZ2VPcGVyYXRvcn0ke29wdC50byB8fCAnJ31gKTtcbiAgIH1cblxuICAgaWYgKGZpbHRlclN0cmluZyhvcHQuZmlsZSkpIHtcbiAgICAgIGNvbW1hbmQucHVzaCgnLS1mb2xsb3cnLCBwYXRoc3BlYyhvcHQuZmlsZSkpO1xuICAgfVxuXG4gICBhcHBlbmRUYXNrT3B0aW9ucyh1c2VyT3B0aW9ucyhvcHQgYXMgT3B0aW9ucyksIGNvbW1hbmQpO1xuXG4gICByZXR1cm4ge1xuICAgICAgZmllbGRzLFxuICAgICAgc3BsaXR0ZXIsXG4gICAgICBjb21tYW5kczogWy4uLmNvbW1hbmQsIC4uLnN1ZmZpeF0sXG4gICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9nVGFzazxUPihcbiAgIHNwbGl0dGVyOiBzdHJpbmcsXG4gICBmaWVsZHM6IHN0cmluZ1tdLFxuICAgY3VzdG9tQXJnczogc3RyaW5nW11cbik6IFN0cmluZ1Rhc2s8TG9nUmVzdWx0PFQ+PiB7XG4gICBjb25zdCBwYXJzZXIgPSBjcmVhdGVMaXN0TG9nU3VtbWFyeVBhcnNlcihzcGxpdHRlciwgZmllbGRzLCBsb2dGb3JtYXRGcm9tQ29tbWFuZChjdXN0b21BcmdzKSk7XG5cbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kczogWydsb2cnLCAuLi5jdXN0b21BcmdzXSxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcixcbiAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpOiBQaWNrPFNpbXBsZUdpdCwgJ2xvZyc+IHtcbiAgIHJldHVybiB7XG4gICAgICBsb2c8VCBleHRlbmRzIE9wdGlvbnM+KHRoaXM6IFNpbXBsZUdpdEFwaSwgLi4ucmVzdDogdW5rbm93bltdKSB7XG4gICAgICAgICBjb25zdCBuZXh0ID0gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cyk7XG4gICAgICAgICBjb25zdCBvcHRpb25zID0gcGFyc2VMb2dPcHRpb25zPFQ+KFxuICAgICAgICAgICAgdHJhaWxpbmdPcHRpb25zQXJndW1lbnQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIGZpbHRlclR5cGUoYXJndW1lbnRzWzBdLCBmaWx0ZXJBcnJheSlcbiAgICAgICAgICk7XG4gICAgICAgICBjb25zdCB0YXNrID1cbiAgICAgICAgICAgIHJlamVjdERlcHJlY2F0ZWRTaWduYXR1cmVzKC4uLnJlc3QpIHx8XG4gICAgICAgICAgICB2YWxpZGF0ZUxvZ0Zvcm1hdENvbmZpZyhvcHRpb25zLmNvbW1hbmRzKSB8fFxuICAgICAgICAgICAgY3JlYXRlTG9nVGFzayhvcHRpb25zKTtcblxuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgbmV4dCk7XG4gICAgICB9LFxuICAgfTtcblxuICAgZnVuY3Rpb24gY3JlYXRlTG9nVGFzayhvcHRpb25zOiBQYXJzZWRMb2dPcHRpb25zKSB7XG4gICAgICByZXR1cm4gbG9nVGFzayhvcHRpb25zLnNwbGl0dGVyLCBvcHRpb25zLmZpZWxkcywgb3B0aW9ucy5jb21tYW5kcyk7XG4gICB9XG5cbiAgIGZ1bmN0aW9uIHJlamVjdERlcHJlY2F0ZWRTaWduYXR1cmVzKGZyb20/OiB1bmtub3duLCB0bz86IHVua25vd24pIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgICBmaWx0ZXJTdHJpbmcoZnJvbSkgJiZcbiAgICAgICAgIGZpbHRlclN0cmluZyh0bykgJiZcbiAgICAgICAgIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soXG4gICAgICAgICAgICBgZ2l0LmxvZyhzdHJpbmcsIHN0cmluZykgc2hvdWxkIGJlIHJlcGxhY2VkIHdpdGggZ2l0LmxvZyh7IGZyb206IHN0cmluZywgdG86IHN0cmluZyB9KWBcbiAgICAgICAgIClcbiAgICAgICk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgIE1lcmdlQ29uZmxpY3QsXG4gICBNZXJnZUNvbmZsaWN0RGVsZXRpb24sXG4gICBNZXJnZURldGFpbCxcbiAgIE1lcmdlUmVzdWx0U3RhdHVzLFxufSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcblxuZXhwb3J0IGNsYXNzIE1lcmdlU3VtbWFyeUNvbmZsaWN0IGltcGxlbWVudHMgTWVyZ2VDb25mbGljdCB7XG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyByZWFkb25seSByZWFzb246IHN0cmluZyxcbiAgICAgIHB1YmxpYyByZWFkb25seSBmaWxlOiBzdHJpbmcgfCBudWxsID0gbnVsbCxcbiAgICAgIHB1YmxpYyByZWFkb25seSBtZXRhPzogTWVyZ2VDb25mbGljdERlbGV0aW9uXG4gICApIHt9XG5cbiAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGAke3RoaXMuZmlsZX06JHt0aGlzLnJlYXNvbn1gO1xuICAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWVyZ2VTdW1tYXJ5RGV0YWlsIGltcGxlbWVudHMgTWVyZ2VEZXRhaWwge1xuICAgcHVibGljIGNvbmZsaWN0czogTWVyZ2VDb25mbGljdFtdID0gW107XG4gICBwdWJsaWMgbWVyZ2VzOiBzdHJpbmdbXSA9IFtdO1xuICAgcHVibGljIHJlc3VsdDogTWVyZ2VSZXN1bHRTdGF0dXMgPSAnc3VjY2Vzcyc7XG5cbiAgIGdldCBmYWlsZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25mbGljdHMubGVuZ3RoID4gMDtcbiAgIH1cblxuICAgZ2V0IHJlYXNvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgIH1cblxuICAgdG9TdHJpbmcoKSB7XG4gICAgICBpZiAodGhpcy5jb25mbGljdHMubGVuZ3RoKSB7XG4gICAgICAgICByZXR1cm4gYENPTkZMSUNUUzogJHt0aGlzLmNvbmZsaWN0cy5qb2luKCcsICcpfWA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnT0snO1xuICAgfVxufVxuIiwgImltcG9ydCB7XG4gICBQdWxsRGV0YWlsRmlsZUNoYW5nZXMsXG4gICBQdWxsRGV0YWlsU3VtbWFyeSxcbiAgIFB1bGxGYWlsZWRSZXN1bHQsXG4gICBQdWxsUmVzdWx0LFxufSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcblxuZXhwb3J0IGNsYXNzIFB1bGxTdW1tYXJ5IGltcGxlbWVudHMgUHVsbFJlc3VsdCB7XG4gICBwdWJsaWMgcmVtb3RlTWVzc2FnZXMgPSB7XG4gICAgICBhbGw6IFtdLFxuICAgfTtcbiAgIHB1YmxpYyBjcmVhdGVkID0gW107XG4gICBwdWJsaWMgZGVsZXRlZDogc3RyaW5nW10gPSBbXTtcbiAgIHB1YmxpYyBmaWxlczogc3RyaW5nW10gPSBbXTtcbiAgIHB1YmxpYyBkZWxldGlvbnM6IFB1bGxEZXRhaWxGaWxlQ2hhbmdlcyA9IHt9O1xuICAgcHVibGljIGluc2VydGlvbnM6IFB1bGxEZXRhaWxGaWxlQ2hhbmdlcyA9IHt9O1xuICAgcHVibGljIHN1bW1hcnk6IFB1bGxEZXRhaWxTdW1tYXJ5ID0ge1xuICAgICAgY2hhbmdlczogMCxcbiAgICAgIGRlbGV0aW9uczogMCxcbiAgICAgIGluc2VydGlvbnM6IDAsXG4gICB9O1xufVxuXG5leHBvcnQgY2xhc3MgUHVsbEZhaWxlZFN1bW1hcnkgaW1wbGVtZW50cyBQdWxsRmFpbGVkUmVzdWx0IHtcbiAgIHJlbW90ZSA9ICcnO1xuICAgaGFzaCA9IHtcbiAgICAgIGxvY2FsOiAnJyxcbiAgICAgIHJlbW90ZTogJycsXG4gICB9O1xuICAgYnJhbmNoID0ge1xuICAgICAgbG9jYWw6ICcnLFxuICAgICAgcmVtb3RlOiAnJyxcbiAgIH07XG4gICBtZXNzYWdlID0gJyc7XG5cbiAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgIH1cbn1cbiIsICJpbXBvcnQge1xuICAgUmVtb3RlTWVzc2FnZVJlc3VsdCxcbiAgIFJlbW90ZU1lc3NhZ2VzLFxuICAgUmVtb3RlTWVzc2FnZXNPYmplY3RFbnVtZXJhdGlvbixcbn0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBhc051bWJlciwgUmVtb3RlTGluZVBhcnNlciB9IGZyb20gJy4uL3V0aWxzJztcblxuZnVuY3Rpb24gb2JqZWN0RW51bWVyYXRpb25SZXN1bHQ8VCBleHRlbmRzIFJlbW90ZU1lc3NhZ2VzID0gUmVtb3RlTWVzc2FnZXM+KFxuICAgcmVtb3RlTWVzc2FnZXM6IFRcbik6IFJlbW90ZU1lc3NhZ2VzT2JqZWN0RW51bWVyYXRpb24ge1xuICAgcmV0dXJuIChyZW1vdGVNZXNzYWdlcy5vYmplY3RzID0gcmVtb3RlTWVzc2FnZXMub2JqZWN0cyB8fCB7XG4gICAgICBjb21wcmVzc2luZzogMCxcbiAgICAgIGNvdW50aW5nOiAwLFxuICAgICAgZW51bWVyYXRpbmc6IDAsXG4gICAgICBwYWNrUmV1c2VkOiAwLFxuICAgICAgcmV1c2VkOiB7IGNvdW50OiAwLCBkZWx0YTogMCB9LFxuICAgICAgdG90YWw6IHsgY291bnQ6IDAsIGRlbHRhOiAwIH0sXG4gICB9KTtcbn1cblxuZnVuY3Rpb24gYXNPYmplY3RDb3VudChzb3VyY2U6IHN0cmluZykge1xuICAgY29uc3QgY291bnQgPSAvXlxccyooXFxkKykvLmV4ZWMoc291cmNlKTtcbiAgIGNvbnN0IGRlbHRhID0gL2RlbHRhIChcXGQrKS9pLmV4ZWMoc291cmNlKTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNvdW50OiBhc051bWJlcigoY291bnQgJiYgY291bnRbMV0pIHx8ICcwJyksXG4gICAgICBkZWx0YTogYXNOdW1iZXIoKGRlbHRhICYmIGRlbHRhWzFdKSB8fCAnMCcpLFxuICAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IHJlbW90ZU1lc3NhZ2VzT2JqZWN0UGFyc2VyczogUmVtb3RlTGluZVBhcnNlcjxSZW1vdGVNZXNzYWdlUmVzdWx0PFJlbW90ZU1lc3NhZ2VzPj5bXSA9XG4gICBbXG4gICAgICBuZXcgUmVtb3RlTGluZVBhcnNlcihcbiAgICAgICAgIC9ecmVtb3RlOlxccyooZW51bWVyYXRpbmd8Y291bnRpbmd8Y29tcHJlc3NpbmcpIG9iamVjdHM6IChcXGQrKSwvaSxcbiAgICAgICAgIChyZXN1bHQsIFthY3Rpb24sIGNvdW50XSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYWN0aW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCBlbnVtZXJhdGlvbiA9IG9iamVjdEVudW1lcmF0aW9uUmVzdWx0KHJlc3VsdC5yZW1vdGVNZXNzYWdlcyk7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZW51bWVyYXRpb24sIHsgW2tleV06IGFzTnVtYmVyKGNvdW50KSB9KTtcbiAgICAgICAgIH1cbiAgICAgICksXG4gICAgICBuZXcgUmVtb3RlTGluZVBhcnNlcihcbiAgICAgICAgIC9ecmVtb3RlOlxccyooZW51bWVyYXRpbmd8Y291bnRpbmd8Y29tcHJlc3NpbmcpIG9iamVjdHM6IFxcZCslIFxcKFxcZCtcXC8oXFxkKylcXCksL2ksXG4gICAgICAgICAocmVzdWx0LCBbYWN0aW9uLCBjb3VudF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGFjdGlvbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgZW51bWVyYXRpb24gPSBvYmplY3RFbnVtZXJhdGlvblJlc3VsdChyZXN1bHQucmVtb3RlTWVzc2FnZXMpO1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGVudW1lcmF0aW9uLCB7IFtrZXldOiBhc051bWJlcihjb3VudCkgfSk7XG4gICAgICAgICB9XG4gICAgICApLFxuICAgICAgbmV3IFJlbW90ZUxpbmVQYXJzZXIoXG4gICAgICAgICAvdG90YWwgKFteLF0rKSwgcmV1c2VkIChbXixdKyksIHBhY2stcmV1c2VkIChcXGQrKS9pLFxuICAgICAgICAgKHJlc3VsdCwgW3RvdGFsLCByZXVzZWQsIHBhY2tSZXVzZWRdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvYmplY3RzID0gb2JqZWN0RW51bWVyYXRpb25SZXN1bHQocmVzdWx0LnJlbW90ZU1lc3NhZ2VzKTtcbiAgICAgICAgICAgIG9iamVjdHMudG90YWwgPSBhc09iamVjdENvdW50KHRvdGFsKTtcbiAgICAgICAgICAgIG9iamVjdHMucmV1c2VkID0gYXNPYmplY3RDb3VudChyZXVzZWQpO1xuICAgICAgICAgICAgb2JqZWN0cy5wYWNrUmV1c2VkID0gYXNOdW1iZXIocGFja1JldXNlZCk7XG4gICAgICAgICB9XG4gICAgICApLFxuICAgXTtcbiIsICJpbXBvcnQgeyBQdXNoUmVzdWx0UmVtb3RlTWVzc2FnZXMsIFJlbW90ZU1lc3NhZ2VSZXN1bHQsIFJlbW90ZU1lc3NhZ2VzIH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBhc051bWJlciwgcGFyc2VTdHJpbmdSZXNwb25zZSwgUmVtb3RlTGluZVBhcnNlciB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHJlbW90ZU1lc3NhZ2VzT2JqZWN0UGFyc2VycyB9IGZyb20gJy4vcGFyc2UtcmVtb3RlLW9iamVjdHMnO1xuXG5jb25zdCBwYXJzZXJzOiBSZW1vdGVMaW5lUGFyc2VyPFJlbW90ZU1lc3NhZ2VSZXN1bHQ8UHVzaFJlc3VsdFJlbW90ZU1lc3NhZ2VzIHwgUmVtb3RlTWVzc2FnZXM+PltdID1cbiAgIFtcbiAgICAgIG5ldyBSZW1vdGVMaW5lUGFyc2VyKC9ecmVtb3RlOlxccyooLispJC8sIChyZXN1bHQsIFt0ZXh0XSkgPT4ge1xuICAgICAgICAgcmVzdWx0LnJlbW90ZU1lc3NhZ2VzLmFsbC5wdXNoKHRleHQudHJpbSgpKTtcbiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pLFxuICAgICAgLi4ucmVtb3RlTWVzc2FnZXNPYmplY3RQYXJzZXJzLFxuICAgICAgbmV3IFJlbW90ZUxpbmVQYXJzZXIoXG4gICAgICAgICBbL2NyZWF0ZSBhICg/OnB1bGx8bWVyZ2UpIHJlcXVlc3QvaSwgL1xccyhodHRwcz86XFwvXFwvXFxTKykkL10sXG4gICAgICAgICAocmVzdWx0LCBbcHVsbFJlcXVlc3RVcmxdKSA9PiB7XG4gICAgICAgICAgICAocmVzdWx0LnJlbW90ZU1lc3NhZ2VzIGFzIFB1c2hSZXN1bHRSZW1vdGVNZXNzYWdlcykucHVsbFJlcXVlc3RVcmwgPSBwdWxsUmVxdWVzdFVybDtcbiAgICAgICAgIH1cbiAgICAgICksXG4gICAgICBuZXcgUmVtb3RlTGluZVBhcnNlcihcbiAgICAgICAgIFsvZm91bmQgKFxcZCspIHZ1bG5lcmFiaWxpdGllcy4rXFwoKFteKV0rKVxcKS9pLCAvXFxzKGh0dHBzPzpcXC9cXC9cXFMrKSQvXSxcbiAgICAgICAgIChyZXN1bHQsIFtjb3VudCwgc3VtbWFyeSwgdXJsXSkgPT4ge1xuICAgICAgICAgICAgKHJlc3VsdC5yZW1vdGVNZXNzYWdlcyBhcyBQdXNoUmVzdWx0UmVtb3RlTWVzc2FnZXMpLnZ1bG5lcmFiaWxpdGllcyA9IHtcbiAgICAgICAgICAgICAgIGNvdW50OiBhc051bWJlcihjb3VudCksXG4gICAgICAgICAgICAgICBzdW1tYXJ5LFxuICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgIH1cbiAgICAgICksXG4gICBdO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSZW1vdGVNZXNzYWdlczxUIGV4dGVuZHMgUmVtb3RlTWVzc2FnZXMgPSBSZW1vdGVNZXNzYWdlcz4oXG4gICBfc3RkT3V0OiBzdHJpbmcsXG4gICBzdGRFcnI6IHN0cmluZ1xuKTogUmVtb3RlTWVzc2FnZVJlc3VsdCB7XG4gICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZSh7IHJlbW90ZU1lc3NhZ2VzOiBuZXcgUmVtb3RlTWVzc2FnZVN1bW1hcnkoKSBhcyBUIH0sIHBhcnNlcnMsIHN0ZEVycik7XG59XG5cbmV4cG9ydCBjbGFzcyBSZW1vdGVNZXNzYWdlU3VtbWFyeSBpbXBsZW1lbnRzIFJlbW90ZU1lc3NhZ2VzIHtcbiAgIHB1YmxpYyByZWFkb25seSBhbGw6IHN0cmluZ1tdID0gW107XG59XG4iLCAiaW1wb3J0IHsgUHVsbERldGFpbCwgUHVsbEZhaWxlZFJlc3VsdCwgUHVsbFJlc3VsdCwgUmVtb3RlTWVzc2FnZXMgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IFB1bGxGYWlsZWRTdW1tYXJ5LCBQdWxsU3VtbWFyeSB9IGZyb20gJy4uL3Jlc3BvbnNlcy9QdWxsU3VtbWFyeSc7XG5pbXBvcnQgeyBUYXNrUGFyc2VyIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgYXBwZW5kLCBMaW5lUGFyc2VyLCBwYXJzZVN0cmluZ1Jlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgcGFyc2VSZW1vdGVNZXNzYWdlcyB9IGZyb20gJy4vcGFyc2UtcmVtb3RlLW1lc3NhZ2VzJztcblxuY29uc3QgRklMRV9VUERBVEVfUkVHRVggPSAvXlxccyooLis/KVxccytcXHxcXHMrXFxkK1xccyooXFwrKikoLSopLztcbmNvbnN0IFNVTU1BUllfUkVHRVggPSAvKFxcZCspXFxEKygoXFxkKylcXEQrXFwoXFwrXFwpKT8oXFxEKyhcXGQrKVxcRCtcXCgtXFwpKT8vO1xuY29uc3QgQUNUSU9OX1JFR0VYID0gL14oY3JlYXRlfGRlbGV0ZSkgbW9kZSBcXGQrICguKykvO1xuXG5jb25zdCBwYXJzZXJzOiBMaW5lUGFyc2VyPFB1bGxSZXN1bHQ+W10gPSBbXG4gICBuZXcgTGluZVBhcnNlcihGSUxFX1VQREFURV9SRUdFWCwgKHJlc3VsdCwgW2ZpbGUsIGluc2VydGlvbnMsIGRlbGV0aW9uc10pID0+IHtcbiAgICAgIHJlc3VsdC5maWxlcy5wdXNoKGZpbGUpO1xuXG4gICAgICBpZiAoaW5zZXJ0aW9ucykge1xuICAgICAgICAgcmVzdWx0Lmluc2VydGlvbnNbZmlsZV0gPSBpbnNlcnRpb25zLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlbGV0aW9ucykge1xuICAgICAgICAgcmVzdWx0LmRlbGV0aW9uc1tmaWxlXSA9IGRlbGV0aW9ucy5sZW5ndGg7XG4gICAgICB9XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKFNVTU1BUllfUkVHRVgsIChyZXN1bHQsIFtjaGFuZ2VzLCAsIGluc2VydGlvbnMsICwgZGVsZXRpb25zXSkgPT4ge1xuICAgICAgaWYgKGluc2VydGlvbnMgIT09IHVuZGVmaW5lZCB8fCBkZWxldGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgcmVzdWx0LnN1bW1hcnkuY2hhbmdlcyA9ICtjaGFuZ2VzIHx8IDA7XG4gICAgICAgICByZXN1bHQuc3VtbWFyeS5pbnNlcnRpb25zID0gK2luc2VydGlvbnMgfHwgMDtcbiAgICAgICAgIHJlc3VsdC5zdW1tYXJ5LmRlbGV0aW9ucyA9ICtkZWxldGlvbnMgfHwgMDtcbiAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgfSksXG4gICBuZXcgTGluZVBhcnNlcihBQ1RJT05fUkVHRVgsIChyZXN1bHQsIFthY3Rpb24sIGZpbGVdKSA9PiB7XG4gICAgICBhcHBlbmQocmVzdWx0LmZpbGVzLCBmaWxlKTtcbiAgICAgIGFwcGVuZChhY3Rpb24gPT09ICdjcmVhdGUnID8gcmVzdWx0LmNyZWF0ZWQgOiByZXN1bHQuZGVsZXRlZCwgZmlsZSk7XG4gICB9KSxcbl07XG5cbmNvbnN0IGVycm9yUGFyc2VyczogTGluZVBhcnNlcjxQdWxsRmFpbGVkUmVzdWx0PltdID0gW1xuICAgbmV3IExpbmVQYXJzZXIoL15mcm9tXFxzKC4rKSQvaSwgKHJlc3VsdCwgW3JlbW90ZV0pID0+IHZvaWQgKHJlc3VsdC5yZW1vdGUgPSByZW1vdGUpKSxcbiAgIG5ldyBMaW5lUGFyc2VyKC9eZmF0YWw6XFxzKC4rKSQvLCAocmVzdWx0LCBbbWVzc2FnZV0pID0+IHZvaWQgKHJlc3VsdC5tZXNzYWdlID0gbWVzc2FnZSkpLFxuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvKFthLXowLTldKylcXC5cXC4oW2EtejAtOV0rKVxccysoXFxTKylcXHMrLT5cXHMrKFxcUyspJC8sXG4gICAgICAocmVzdWx0LCBbaGFzaExvY2FsLCBoYXNoUmVtb3RlLCBicmFuY2hMb2NhbCwgYnJhbmNoUmVtb3RlXSkgPT4ge1xuICAgICAgICAgcmVzdWx0LmJyYW5jaC5sb2NhbCA9IGJyYW5jaExvY2FsO1xuICAgICAgICAgcmVzdWx0Lmhhc2gubG9jYWwgPSBoYXNoTG9jYWw7XG4gICAgICAgICByZXN1bHQuYnJhbmNoLnJlbW90ZSA9IGJyYW5jaFJlbW90ZTtcbiAgICAgICAgIHJlc3VsdC5oYXNoLnJlbW90ZSA9IGhhc2hSZW1vdGU7XG4gICAgICB9XG4gICApLFxuXTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlUHVsbERldGFpbDogVGFza1BhcnNlcjxzdHJpbmcsIFB1bGxEZXRhaWw+ID0gKHN0ZE91dCwgc3RkRXJyKSA9PiB7XG4gICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZShuZXcgUHVsbFN1bW1hcnkoKSwgcGFyc2VycywgW3N0ZE91dCwgc3RkRXJyXSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VQdWxsUmVzdWx0OiBUYXNrUGFyc2VyPHN0cmluZywgUHVsbFJlc3VsdD4gPSAoc3RkT3V0LCBzdGRFcnIpID0+IHtcbiAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgbmV3IFB1bGxTdW1tYXJ5KCksXG4gICAgICBwYXJzZVB1bGxEZXRhaWwoc3RkT3V0LCBzdGRFcnIpLFxuICAgICAgcGFyc2VSZW1vdGVNZXNzYWdlczxSZW1vdGVNZXNzYWdlcz4oc3RkT3V0LCBzdGRFcnIpXG4gICApO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUHVsbEVycm9yUmVzdWx0KHN0ZE91dDogc3RyaW5nLCBzdGRFcnI6IHN0cmluZykge1xuICAgY29uc3QgcHVsbEVycm9yID0gcGFyc2VTdHJpbmdSZXNwb25zZShuZXcgUHVsbEZhaWxlZFN1bW1hcnkoKSwgZXJyb3JQYXJzZXJzLCBbc3RkT3V0LCBzdGRFcnJdKTtcblxuICAgcmV0dXJuIHB1bGxFcnJvci5tZXNzYWdlICYmIHB1bGxFcnJvcjtcbn1cbiIsICJpbXBvcnQgeyBNZXJnZURldGFpbCwgTWVyZ2VSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IE1lcmdlU3VtbWFyeUNvbmZsaWN0LCBNZXJnZVN1bW1hcnlEZXRhaWwgfSBmcm9tICcuLi9yZXNwb25zZXMvTWVyZ2VTdW1tYXJ5JztcbmltcG9ydCB7IFRhc2tQYXJzZXIgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBMaW5lUGFyc2VyLCBwYXJzZVN0cmluZ1Jlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgcGFyc2VQdWxsUmVzdWx0IH0gZnJvbSAnLi9wYXJzZS1wdWxsJztcblxuY29uc3QgcGFyc2VyczogTGluZVBhcnNlcjxNZXJnZURldGFpbD5bXSA9IFtcbiAgIG5ldyBMaW5lUGFyc2VyKC9eQXV0by1tZXJnaW5nXFxzKyguKykkLywgKHN1bW1hcnksIFthdXRvTWVyZ2VdKSA9PiB7XG4gICAgICBzdW1tYXJ5Lm1lcmdlcy5wdXNoKGF1dG9NZXJnZSk7XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKC9eQ09ORkxJQ1RcXHMrXFwoKC4rKVxcKTogTWVyZ2UgY29uZmxpY3QgaW4gKC4rKSQvLCAoc3VtbWFyeSwgW3JlYXNvbiwgZmlsZV0pID0+IHtcbiAgICAgIHN1bW1hcnkuY29uZmxpY3RzLnB1c2gobmV3IE1lcmdlU3VtbWFyeUNvbmZsaWN0KHJlYXNvbiwgZmlsZSkpO1xuICAgfSksXG4gICBuZXcgTGluZVBhcnNlcihcbiAgICAgIC9eQ09ORkxJQ1RcXHMrXFwoKC4rXFwvZGVsZXRlKVxcKTogKC4rKSBkZWxldGVkIGluICguKykgYW5kLyxcbiAgICAgIChzdW1tYXJ5LCBbcmVhc29uLCBmaWxlLCBkZWxldGVSZWZdKSA9PiB7XG4gICAgICAgICBzdW1tYXJ5LmNvbmZsaWN0cy5wdXNoKG5ldyBNZXJnZVN1bW1hcnlDb25mbGljdChyZWFzb24sIGZpbGUsIHsgZGVsZXRlUmVmIH0pKTtcbiAgICAgIH1cbiAgICksXG4gICBuZXcgTGluZVBhcnNlcigvXkNPTkZMSUNUXFxzK1xcKCguKylcXCk6LywgKHN1bW1hcnksIFtyZWFzb25dKSA9PiB7XG4gICAgICBzdW1tYXJ5LmNvbmZsaWN0cy5wdXNoKG5ldyBNZXJnZVN1bW1hcnlDb25mbGljdChyZWFzb24sIG51bGwpKTtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoL15BdXRvbWF0aWMgbWVyZ2UgZmFpbGVkO1xccysoLispJC8sIChzdW1tYXJ5LCBbcmVzdWx0XSkgPT4ge1xuICAgICAgc3VtbWFyeS5yZXN1bHQgPSByZXN1bHQ7XG4gICB9KSxcbl07XG5cbi8qKlxuICogUGFyc2UgdGhlIGNvbXBsZXRlIHJlc3BvbnNlIGZyb20gYGdpdC5tZXJnZWBcbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlTWVyZ2VSZXN1bHQ6IFRhc2tQYXJzZXI8c3RyaW5nLCBNZXJnZVJlc3VsdD4gPSAoc3RkT3V0LCBzdGRFcnIpID0+IHtcbiAgIHJldHVybiBPYmplY3QuYXNzaWduKHBhcnNlTWVyZ2VEZXRhaWwoc3RkT3V0LCBzdGRFcnIpLCBwYXJzZVB1bGxSZXN1bHQoc3RkT3V0LCBzdGRFcnIpKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIG1lcmdlIHNwZWNpZmljIGRldGFpbCAoaWU6IG5vdCB0aGUgY29udGVudCBhbHNvIGF2YWlsYWJsZSBpbiB0aGUgcHVsbCBkZXRhaWwpIGZyb20gYGdpdC5tbmVyZ2VgXG4gKiBAcGFyYW0gc3RkT3V0XG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZU1lcmdlRGV0YWlsOiBUYXNrUGFyc2VyPHN0cmluZywgTWVyZ2VEZXRhaWw+ID0gKHN0ZE91dCkgPT4ge1xuICAgcmV0dXJuIHBhcnNlU3RyaW5nUmVzcG9uc2UobmV3IE1lcmdlU3VtbWFyeURldGFpbCgpLCBwYXJzZXJzLCBzdGRPdXQpO1xufTtcbiIsICJpbXBvcnQgeyBNZXJnZVJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgR2l0UmVzcG9uc2VFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9naXQtcmVzcG9uc2UtZXJyb3InO1xuaW1wb3J0IHsgcGFyc2VNZXJnZVJlc3VsdCB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtbWVyZ2UnO1xuaW1wb3J0IHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGNvbmZpZ3VyYXRpb25FcnJvclRhc2ssIEVtcHR5VGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVRhc2soY3VzdG9tQXJnczogc3RyaW5nW10pOiBFbXB0eVRhc2sgfCBTdHJpbmdUYXNrPE1lcmdlUmVzdWx0PiB7XG4gICBpZiAoIWN1c3RvbUFyZ3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzaygnR2l0Lm1lcmdlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBvcHRpb24nKTtcbiAgIH1cblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzOiBbJ21lcmdlJywgLi4uY3VzdG9tQXJnc10sXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXIoc3RkT3V0LCBzdGRFcnIpOiBNZXJnZVJlc3VsdCB7XG4gICAgICAgICBjb25zdCBtZXJnZSA9IHBhcnNlTWVyZ2VSZXN1bHQoc3RkT3V0LCBzdGRFcnIpO1xuICAgICAgICAgaWYgKG1lcmdlLmZhaWxlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdpdFJlc3BvbnNlRXJyb3IobWVyZ2UpO1xuICAgICAgICAgfVxuXG4gICAgICAgICByZXR1cm4gbWVyZ2U7XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJpbXBvcnQge1xuICAgUHVzaERldGFpbCxcbiAgIFB1c2hSZXN1bHQsXG4gICBQdXNoUmVzdWx0UHVzaGVkSXRlbSxcbiAgIFB1c2hSZXN1bHRSZW1vdGVNZXNzYWdlcyxcbn0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBUYXNrUGFyc2VyIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgTGluZVBhcnNlciwgcGFyc2VTdHJpbmdSZXNwb25zZSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHBhcnNlUmVtb3RlTWVzc2FnZXMgfSBmcm9tICcuL3BhcnNlLXJlbW90ZS1tZXNzYWdlcyc7XG5cbmZ1bmN0aW9uIHB1c2hSZXN1bHRQdXNoZWRJdGVtKGxvY2FsOiBzdHJpbmcsIHJlbW90ZTogc3RyaW5nLCBzdGF0dXM6IHN0cmluZyk6IFB1c2hSZXN1bHRQdXNoZWRJdGVtIHtcbiAgIGNvbnN0IGRlbGV0ZWQgPSBzdGF0dXMuaW5jbHVkZXMoJ2RlbGV0ZWQnKTtcbiAgIGNvbnN0IHRhZyA9IHN0YXR1cy5pbmNsdWRlcygndGFnJykgfHwgL15yZWZzXFwvdGFncy8udGVzdChsb2NhbCk7XG4gICBjb25zdCBhbHJlYWR5VXBkYXRlZCA9ICFzdGF0dXMuaW5jbHVkZXMoJ25ldycpO1xuXG4gICByZXR1cm4ge1xuICAgICAgZGVsZXRlZCxcbiAgICAgIHRhZyxcbiAgICAgIGJyYW5jaDogIXRhZyxcbiAgICAgIG5ldzogIWFscmVhZHlVcGRhdGVkLFxuICAgICAgYWxyZWFkeVVwZGF0ZWQsXG4gICAgICBsb2NhbCxcbiAgICAgIHJlbW90ZSxcbiAgIH07XG59XG5cbmNvbnN0IHBhcnNlcnM6IExpbmVQYXJzZXI8UHVzaERldGFpbD5bXSA9IFtcbiAgIG5ldyBMaW5lUGFyc2VyKC9eUHVzaGluZyB0byAoLispJC8sIChyZXN1bHQsIFtyZXBvXSkgPT4ge1xuICAgICAgcmVzdWx0LnJlcG8gPSByZXBvO1xuICAgfSksXG4gICBuZXcgTGluZVBhcnNlcigvXnVwZGF0aW5nIGxvY2FsIHRyYWNraW5nIHJlZiAnKC4rKScvLCAocmVzdWx0LCBbbG9jYWxdKSA9PiB7XG4gICAgICByZXN1bHQucmVmID0ge1xuICAgICAgICAgLi4uKHJlc3VsdC5yZWYgfHwge30pLFxuICAgICAgICAgbG9jYWwsXG4gICAgICB9O1xuICAgfSksXG4gICBuZXcgTGluZVBhcnNlcigvXls9Ki1dXFxzKyhbXjpdKyk6KFxcUyspXFxzK1xcWyguKyldJC8sIChyZXN1bHQsIFtsb2NhbCwgcmVtb3RlLCB0eXBlXSkgPT4ge1xuICAgICAgcmVzdWx0LnB1c2hlZC5wdXNoKHB1c2hSZXN1bHRQdXNoZWRJdGVtKGxvY2FsLCByZW1vdGUsIHR5cGUpKTtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvXkJyYW5jaCAnKFteJ10rKScgc2V0IHVwIHRvIHRyYWNrIHJlbW90ZSBicmFuY2ggJyhbXiddKyknIGZyb20gJyhbXiddKyknLyxcbiAgICAgIChyZXN1bHQsIFtsb2NhbCwgcmVtb3RlLCByZW1vdGVOYW1lXSkgPT4ge1xuICAgICAgICAgcmVzdWx0LmJyYW5jaCA9IHtcbiAgICAgICAgICAgIC4uLihyZXN1bHQuYnJhbmNoIHx8IHt9KSxcbiAgICAgICAgICAgIGxvY2FsLFxuICAgICAgICAgICAgcmVtb3RlLFxuICAgICAgICAgICAgcmVtb3RlTmFtZSxcbiAgICAgICAgIH07XG4gICAgICB9XG4gICApLFxuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvXihbXjpdKyk6KFxcUyspXFxzKyhbYS16MC05XSspXFwuXFwuKFthLXowLTldKykkLyxcbiAgICAgIChyZXN1bHQsIFtsb2NhbCwgcmVtb3RlLCBmcm9tLCB0b10pID0+IHtcbiAgICAgICAgIHJlc3VsdC51cGRhdGUgPSB7XG4gICAgICAgICAgICBoZWFkOiB7XG4gICAgICAgICAgICAgICBsb2NhbCxcbiAgICAgICAgICAgICAgIHJlbW90ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXNoOiB7XG4gICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgfTtcbiAgICAgIH1cbiAgICksXG5dO1xuXG5leHBvcnQgY29uc3QgcGFyc2VQdXNoUmVzdWx0OiBUYXNrUGFyc2VyPHN0cmluZywgUHVzaFJlc3VsdD4gPSAoc3RkT3V0LCBzdGRFcnIpID0+IHtcbiAgIGNvbnN0IHB1c2hEZXRhaWwgPSBwYXJzZVB1c2hEZXRhaWwoc3RkT3V0LCBzdGRFcnIpO1xuICAgY29uc3QgcmVzcG9uc2VEZXRhaWwgPSBwYXJzZVJlbW90ZU1lc3NhZ2VzPFB1c2hSZXN1bHRSZW1vdGVNZXNzYWdlcz4oc3RkT3V0LCBzdGRFcnIpO1xuXG4gICByZXR1cm4ge1xuICAgICAgLi4ucHVzaERldGFpbCxcbiAgICAgIC4uLnJlc3BvbnNlRGV0YWlsLFxuICAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVB1c2hEZXRhaWw6IFRhc2tQYXJzZXI8c3RyaW5nLCBQdXNoRGV0YWlsPiA9IChzdGRPdXQsIHN0ZEVycikgPT4ge1xuICAgcmV0dXJuIHBhcnNlU3RyaW5nUmVzcG9uc2UoeyBwdXNoZWQ6IFtdIH0sIHBhcnNlcnMsIFtzdGRPdXQsIHN0ZEVycl0pO1xufTtcbiIsICJpbXBvcnQgeyBQdXNoUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBwYXJzZVB1c2hSZXN1bHQgYXMgcGFyc2VyIH0gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZS1wdXNoJztcbmltcG9ydCB7IFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBhcHBlbmQsIHJlbW92ZSB9IGZyb20gJy4uL3V0aWxzJztcblxudHlwZSBQdXNoUmVmID0geyByZW1vdGU/OiBzdHJpbmc7IGJyYW5jaD86IHN0cmluZyB9O1xuXG5leHBvcnQgZnVuY3Rpb24gcHVzaFRhZ3NUYXNrKHJlZjogUHVzaFJlZiA9IHt9LCBjdXN0b21BcmdzOiBzdHJpbmdbXSk6IFN0cmluZ1Rhc2s8UHVzaFJlc3VsdD4ge1xuICAgYXBwZW5kKGN1c3RvbUFyZ3MsICctLXRhZ3MnKTtcbiAgIHJldHVybiBwdXNoVGFzayhyZWYsIGN1c3RvbUFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHVzaFRhc2socmVmOiBQdXNoUmVmID0ge30sIGN1c3RvbUFyZ3M6IHN0cmluZ1tdKTogU3RyaW5nVGFzazxQdXNoUmVzdWx0PiB7XG4gICBjb25zdCBjb21tYW5kcyA9IFsncHVzaCcsIC4uLmN1c3RvbUFyZ3NdO1xuICAgaWYgKHJlZi5icmFuY2gpIHtcbiAgICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCByZWYuYnJhbmNoKTtcbiAgIH1cbiAgIGlmIChyZWYucmVtb3RlKSB7XG4gICAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgcmVmLnJlbW90ZSk7XG4gICB9XG5cbiAgIHJlbW92ZShjb21tYW5kcywgJy12Jyk7XG4gICBhcHBlbmQoY29tbWFuZHMsICctLXZlcmJvc2UnKTtcbiAgIGFwcGVuZChjb21tYW5kcywgJy0tcG9yY2VsYWluJyk7XG5cbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kcyxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcixcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgU2ltcGxlR2l0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBTaW1wbGVHaXRBcGkgfSBmcm9tICcuLi9zaW1wbGUtZ2l0LWFwaSc7XG5pbXBvcnQgeyBnZXRUcmFpbGluZ09wdGlvbnMsIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2ssIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2sgfSBmcm9tICcuL3Rhc2snO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKTogUGljazxTaW1wbGVHaXQsICdzaG93QnVmZmVyJyB8ICdzaG93Jz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIHNob3dCdWZmZXIodGhpczogU2ltcGxlR2l0QXBpKSB7XG4gICAgICAgICBjb25zdCBjb21tYW5kcyA9IFsnc2hvdycsIC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMsIDEpXTtcbiAgICAgICAgIGlmICghY29tbWFuZHMuaW5jbHVkZXMoJy0tYmluYXJ5JykpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCAnLS1iaW5hcnknKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBzdHJhaWdodFRocm91Z2hCdWZmZXJUYXNrKGNvbW1hbmRzKSxcbiAgICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICApO1xuICAgICAgfSxcblxuICAgICAgc2hvdyh0aGlzOiBTaW1wbGVHaXRBcGkpIHtcbiAgICAgICAgIGNvbnN0IGNvbW1hbmRzID0gWydzaG93JywgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgMSldO1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzKSxcbiAgICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICApO1xuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgRmlsZVN0YXR1c1Jlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuXG5leHBvcnQgY29uc3QgZnJvbVBhdGhSZWdleCA9IC9eKC4rKSAtPiAoLispJC87XG5cbmV4cG9ydCBjbGFzcyBGaWxlU3RhdHVzU3VtbWFyeSBpbXBsZW1lbnRzIEZpbGVTdGF0dXNSZXN1bHQge1xuICAgcHVibGljIHJlYWRvbmx5IGZyb206IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgcGF0aDogc3RyaW5nLFxuICAgICAgcHVibGljIGluZGV4OiBzdHJpbmcsXG4gICAgICBwdWJsaWMgd29ya2luZ19kaXI6IHN0cmluZ1xuICAgKSB7XG4gICAgICBpZiAoJ1InID09PSBpbmRleCArIHdvcmtpbmdfZGlyKSB7XG4gICAgICAgICBjb25zdCBkZXRhaWwgPSBmcm9tUGF0aFJlZ2V4LmV4ZWMocGF0aCkgfHwgW251bGwsIHBhdGgsIHBhdGhdO1xuICAgICAgICAgdGhpcy5mcm9tID0gZGV0YWlsWzFdIHx8ICcnO1xuICAgICAgICAgdGhpcy5wYXRoID0gZGV0YWlsWzJdIHx8ICcnO1xuICAgICAgfVxuICAgfVxufVxuIiwgImltcG9ydCB7IFN0YXR1c1Jlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgYXBwZW5kLCBOVUxMIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgRmlsZVN0YXR1c1N1bW1hcnkgfSBmcm9tICcuL0ZpbGVTdGF0dXNTdW1tYXJ5JztcblxudHlwZSBTdGF0dXNMaW5lUGFyc2VyID0gKHJlc3VsdDogU3RhdHVzUmVzdWx0LCBmaWxlOiBzdHJpbmcpID0+IHZvaWQ7XG5cbmV4cG9ydCBjbGFzcyBTdGF0dXNTdW1tYXJ5IGltcGxlbWVudHMgU3RhdHVzUmVzdWx0IHtcbiAgIHB1YmxpYyBub3RfYWRkZWQgPSBbXTtcbiAgIHB1YmxpYyBjb25mbGljdGVkID0gW107XG4gICBwdWJsaWMgY3JlYXRlZCA9IFtdO1xuICAgcHVibGljIGRlbGV0ZWQgPSBbXTtcbiAgIHB1YmxpYyBpZ25vcmVkID0gdW5kZWZpbmVkO1xuICAgcHVibGljIG1vZGlmaWVkID0gW107XG4gICBwdWJsaWMgcmVuYW1lZCA9IFtdO1xuICAgcHVibGljIGZpbGVzID0gW107XG4gICBwdWJsaWMgc3RhZ2VkID0gW107XG4gICBwdWJsaWMgYWhlYWQgPSAwO1xuICAgcHVibGljIGJlaGluZCA9IDA7XG4gICBwdWJsaWMgY3VycmVudCA9IG51bGw7XG4gICBwdWJsaWMgdHJhY2tpbmcgPSBudWxsO1xuICAgcHVibGljIGRldGFjaGVkID0gZmFsc2U7XG5cbiAgIHB1YmxpYyBpc0NsZWFuID0gKCkgPT4ge1xuICAgICAgcmV0dXJuICF0aGlzLmZpbGVzLmxlbmd0aDtcbiAgIH07XG59XG5cbmVudW0gUG9yY2VsYWluRmlsZVN0YXR1cyB7XG4gICBBRERFRCA9ICdBJyxcbiAgIERFTEVURUQgPSAnRCcsXG4gICBNT0RJRklFRCA9ICdNJyxcbiAgIFJFTkFNRUQgPSAnUicsXG4gICBDT1BJRUQgPSAnQycsXG4gICBVTk1FUkdFRCA9ICdVJyxcbiAgIFVOVFJBQ0tFRCA9ICc/JyxcbiAgIElHTk9SRUQgPSAnIScsXG4gICBOT05FID0gJyAnLFxufVxuXG5mdW5jdGlvbiByZW5hbWVkRmlsZShsaW5lOiBzdHJpbmcpIHtcbiAgIGNvbnN0IFt0bywgZnJvbV0gPSBsaW5lLnNwbGl0KE5VTEwpO1xuXG4gICByZXR1cm4ge1xuICAgICAgZnJvbTogZnJvbSB8fCB0byxcbiAgICAgIHRvLFxuICAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VyKFxuICAgaW5kZXhYOiBQb3JjZWxhaW5GaWxlU3RhdHVzLFxuICAgaW5kZXhZOiBQb3JjZWxhaW5GaWxlU3RhdHVzLFxuICAgaGFuZGxlcjogU3RhdHVzTGluZVBhcnNlclxuKTogW3N0cmluZywgU3RhdHVzTGluZVBhcnNlcl0ge1xuICAgcmV0dXJuIFtgJHtpbmRleFh9JHtpbmRleFl9YCwgaGFuZGxlcl07XG59XG5cbmZ1bmN0aW9uIGNvbmZsaWN0cyhpbmRleFg6IFBvcmNlbGFpbkZpbGVTdGF0dXMsIC4uLmluZGV4WTogUG9yY2VsYWluRmlsZVN0YXR1c1tdKSB7XG4gICByZXR1cm4gaW5kZXhZLm1hcCgoeSkgPT4gcGFyc2VyKGluZGV4WCwgeSwgKHJlc3VsdCwgZmlsZSkgPT4gYXBwZW5kKHJlc3VsdC5jb25mbGljdGVkLCBmaWxlKSkpO1xufVxuXG5jb25zdCBwYXJzZXJzOiBNYXA8c3RyaW5nLCBTdGF0dXNMaW5lUGFyc2VyPiA9IG5ldyBNYXAoW1xuICAgcGFyc2VyKFBvcmNlbGFpbkZpbGVTdGF0dXMuTk9ORSwgUG9yY2VsYWluRmlsZVN0YXR1cy5BRERFRCwgKHJlc3VsdCwgZmlsZSkgPT5cbiAgICAgIGFwcGVuZChyZXN1bHQuY3JlYXRlZCwgZmlsZSlcbiAgICksXG4gICBwYXJzZXIoUG9yY2VsYWluRmlsZVN0YXR1cy5OT05FLCBQb3JjZWxhaW5GaWxlU3RhdHVzLkRFTEVURUQsIChyZXN1bHQsIGZpbGUpID0+XG4gICAgICBhcHBlbmQocmVzdWx0LmRlbGV0ZWQsIGZpbGUpXG4gICApLFxuICAgcGFyc2VyKFBvcmNlbGFpbkZpbGVTdGF0dXMuTk9ORSwgUG9yY2VsYWluRmlsZVN0YXR1cy5NT0RJRklFRCwgKHJlc3VsdCwgZmlsZSkgPT5cbiAgICAgIGFwcGVuZChyZXN1bHQubW9kaWZpZWQsIGZpbGUpXG4gICApLFxuXG4gICBwYXJzZXIoXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLkFEREVELFxuICAgICAgUG9yY2VsYWluRmlsZVN0YXR1cy5OT05FLFxuICAgICAgKHJlc3VsdCwgZmlsZSkgPT4gYXBwZW5kKHJlc3VsdC5jcmVhdGVkLCBmaWxlKSAmJiBhcHBlbmQocmVzdWx0LnN0YWdlZCwgZmlsZSlcbiAgICksXG4gICBwYXJzZXIoXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLkFEREVELFxuICAgICAgUG9yY2VsYWluRmlsZVN0YXR1cy5NT0RJRklFRCxcbiAgICAgIChyZXN1bHQsIGZpbGUpID0+XG4gICAgICAgICBhcHBlbmQocmVzdWx0LmNyZWF0ZWQsIGZpbGUpICYmXG4gICAgICAgICBhcHBlbmQocmVzdWx0LnN0YWdlZCwgZmlsZSkgJiZcbiAgICAgICAgIGFwcGVuZChyZXN1bHQubW9kaWZpZWQsIGZpbGUpXG4gICApLFxuXG4gICBwYXJzZXIoXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLkRFTEVURUQsXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLk5PTkUsXG4gICAgICAocmVzdWx0LCBmaWxlKSA9PiBhcHBlbmQocmVzdWx0LmRlbGV0ZWQsIGZpbGUpICYmIGFwcGVuZChyZXN1bHQuc3RhZ2VkLCBmaWxlKVxuICAgKSxcblxuICAgcGFyc2VyKFxuICAgICAgUG9yY2VsYWluRmlsZVN0YXR1cy5NT0RJRklFRCxcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuTk9ORSxcbiAgICAgIChyZXN1bHQsIGZpbGUpID0+IGFwcGVuZChyZXN1bHQubW9kaWZpZWQsIGZpbGUpICYmIGFwcGVuZChyZXN1bHQuc3RhZ2VkLCBmaWxlKVxuICAgKSxcbiAgIHBhcnNlcihcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuTU9ESUZJRUQsXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLk1PRElGSUVELFxuICAgICAgKHJlc3VsdCwgZmlsZSkgPT4gYXBwZW5kKHJlc3VsdC5tb2RpZmllZCwgZmlsZSkgJiYgYXBwZW5kKHJlc3VsdC5zdGFnZWQsIGZpbGUpXG4gICApLFxuXG4gICBwYXJzZXIoUG9yY2VsYWluRmlsZVN0YXR1cy5SRU5BTUVELCBQb3JjZWxhaW5GaWxlU3RhdHVzLk5PTkUsIChyZXN1bHQsIGZpbGUpID0+IHtcbiAgICAgIGFwcGVuZChyZXN1bHQucmVuYW1lZCwgcmVuYW1lZEZpbGUoZmlsZSkpO1xuICAgfSksXG4gICBwYXJzZXIoUG9yY2VsYWluRmlsZVN0YXR1cy5SRU5BTUVELCBQb3JjZWxhaW5GaWxlU3RhdHVzLk1PRElGSUVELCAocmVzdWx0LCBmaWxlKSA9PiB7XG4gICAgICBjb25zdCByZW5hbWVkID0gcmVuYW1lZEZpbGUoZmlsZSk7XG4gICAgICBhcHBlbmQocmVzdWx0LnJlbmFtZWQsIHJlbmFtZWQpO1xuICAgICAgYXBwZW5kKHJlc3VsdC5tb2RpZmllZCwgcmVuYW1lZC50byk7XG4gICB9KSxcbiAgIHBhcnNlcihQb3JjZWxhaW5GaWxlU3RhdHVzLklHTk9SRUQsIFBvcmNlbGFpbkZpbGVTdGF0dXMuSUdOT1JFRCwgKF9yZXN1bHQsIF9maWxlKSA9PiB7XG4gICAgICBhcHBlbmQoKF9yZXN1bHQuaWdub3JlZCA9IF9yZXN1bHQuaWdub3JlZCB8fCBbXSksIF9maWxlKTtcbiAgIH0pLFxuXG4gICBwYXJzZXIoUG9yY2VsYWluRmlsZVN0YXR1cy5VTlRSQUNLRUQsIFBvcmNlbGFpbkZpbGVTdGF0dXMuVU5UUkFDS0VELCAocmVzdWx0LCBmaWxlKSA9PlxuICAgICAgYXBwZW5kKHJlc3VsdC5ub3RfYWRkZWQsIGZpbGUpXG4gICApLFxuXG4gICAuLi5jb25mbGljdHMoUG9yY2VsYWluRmlsZVN0YXR1cy5BRERFRCwgUG9yY2VsYWluRmlsZVN0YXR1cy5BRERFRCwgUG9yY2VsYWluRmlsZVN0YXR1cy5VTk1FUkdFRCksXG4gICAuLi5jb25mbGljdHMoXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLkRFTEVURUQsXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLkRFTEVURUQsXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLlVOTUVSR0VEXG4gICApLFxuICAgLi4uY29uZmxpY3RzKFxuICAgICAgUG9yY2VsYWluRmlsZVN0YXR1cy5VTk1FUkdFRCxcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuQURERUQsXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLkRFTEVURUQsXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLlVOTUVSR0VEXG4gICApLFxuXG4gICBbXG4gICAgICAnIyMnLFxuICAgICAgKHJlc3VsdCwgbGluZSkgPT4ge1xuICAgICAgICAgY29uc3QgYWhlYWRSZWcgPSAvYWhlYWQgKFxcZCspLztcbiAgICAgICAgIGNvbnN0IGJlaGluZFJlZyA9IC9iZWhpbmQgKFxcZCspLztcbiAgICAgICAgIGNvbnN0IGN1cnJlbnRSZWcgPSAvXiguKz8oPz0oPzpcXC57M318XFxzfCQpKSkvO1xuICAgICAgICAgY29uc3QgdHJhY2tpbmdSZWcgPSAvXFwuezN9KFxcUyopLztcbiAgICAgICAgIGNvbnN0IG9uRW1wdHlCcmFuY2hSZWcgPSAvXFxzb25cXHMoW1xcU10rKSQvO1xuICAgICAgICAgbGV0IHJlZ2V4UmVzdWx0O1xuXG4gICAgICAgICByZWdleFJlc3VsdCA9IGFoZWFkUmVnLmV4ZWMobGluZSk7XG4gICAgICAgICByZXN1bHQuYWhlYWQgPSAocmVnZXhSZXN1bHQgJiYgK3JlZ2V4UmVzdWx0WzFdKSB8fCAwO1xuXG4gICAgICAgICByZWdleFJlc3VsdCA9IGJlaGluZFJlZy5leGVjKGxpbmUpO1xuICAgICAgICAgcmVzdWx0LmJlaGluZCA9IChyZWdleFJlc3VsdCAmJiArcmVnZXhSZXN1bHRbMV0pIHx8IDA7XG5cbiAgICAgICAgIHJlZ2V4UmVzdWx0ID0gY3VycmVudFJlZy5leGVjKGxpbmUpO1xuICAgICAgICAgcmVzdWx0LmN1cnJlbnQgPSByZWdleFJlc3VsdCAmJiByZWdleFJlc3VsdFsxXTtcblxuICAgICAgICAgcmVnZXhSZXN1bHQgPSB0cmFja2luZ1JlZy5leGVjKGxpbmUpO1xuICAgICAgICAgcmVzdWx0LnRyYWNraW5nID0gcmVnZXhSZXN1bHQgJiYgcmVnZXhSZXN1bHRbMV07XG5cbiAgICAgICAgIHJlZ2V4UmVzdWx0ID0gb25FbXB0eUJyYW5jaFJlZy5leGVjKGxpbmUpO1xuICAgICAgICAgcmVzdWx0LmN1cnJlbnQgPSAocmVnZXhSZXN1bHQgJiYgcmVnZXhSZXN1bHRbMV0pIHx8IHJlc3VsdC5jdXJyZW50O1xuXG4gICAgICAgICByZXN1bHQuZGV0YWNoZWQgPSAvXFwobm8gYnJhbmNoXFwpLy50ZXN0KGxpbmUpO1xuICAgICAgfSxcbiAgIF0sXG5dKTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU3RhdHVzU3VtbWFyeSA9IGZ1bmN0aW9uICh0ZXh0OiBzdHJpbmcpOiBTdGF0dXNSZXN1bHQge1xuICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KE5VTEwpO1xuICAgY29uc3Qgc3RhdHVzID0gbmV3IFN0YXR1c1N1bW1hcnkoKTtcblxuICAgZm9yIChsZXQgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyApIHtcbiAgICAgIGxldCBsaW5lID0gbGluZXNbaSsrXS50cmltKCk7XG5cbiAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW5lLmNoYXJBdCgwKSA9PT0gUG9yY2VsYWluRmlsZVN0YXR1cy5SRU5BTUVEKSB7XG4gICAgICAgICBsaW5lICs9IE5VTEwgKyAobGluZXNbaSsrXSB8fCAnJyk7XG4gICAgICB9XG5cbiAgICAgIHNwbGl0TGluZShzdGF0dXMsIGxpbmUpO1xuICAgfVxuXG4gICByZXR1cm4gc3RhdHVzO1xufTtcblxuZnVuY3Rpb24gc3BsaXRMaW5lKHJlc3VsdDogU3RhdHVzUmVzdWx0LCBsaW5lU3RyOiBzdHJpbmcpIHtcbiAgIGNvbnN0IHRyaW1tZWQgPSBsaW5lU3RyLnRyaW0oKTtcbiAgIHN3aXRjaCAoJyAnKSB7XG4gICAgICBjYXNlIHRyaW1tZWQuY2hhckF0KDIpOlxuICAgICAgICAgcmV0dXJuIGRhdGEodHJpbW1lZC5jaGFyQXQoMCksIHRyaW1tZWQuY2hhckF0KDEpLCB0cmltbWVkLnN1YnN0cigzKSk7XG4gICAgICBjYXNlIHRyaW1tZWQuY2hhckF0KDEpOlxuICAgICAgICAgcmV0dXJuIGRhdGEoUG9yY2VsYWluRmlsZVN0YXR1cy5OT05FLCB0cmltbWVkLmNoYXJBdCgwKSwgdHJpbW1lZC5zdWJzdHIoMikpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgIHJldHVybjtcbiAgIH1cblxuICAgZnVuY3Rpb24gZGF0YShpbmRleDogc3RyaW5nLCB3b3JraW5nRGlyOiBzdHJpbmcsIHBhdGg6IHN0cmluZykge1xuICAgICAgY29uc3QgcmF3ID0gYCR7aW5kZXh9JHt3b3JraW5nRGlyfWA7XG4gICAgICBjb25zdCBoYW5kbGVyID0gcGFyc2Vycy5nZXQocmF3KTtcblxuICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgIGhhbmRsZXIocmVzdWx0LCBwYXRoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJhdyAhPT0gJyMjJyAmJiByYXcgIT09ICchIScpIHtcbiAgICAgICAgIHJlc3VsdC5maWxlcy5wdXNoKG5ldyBGaWxlU3RhdHVzU3VtbWFyeShwYXRoLnJlcGxhY2UoL1xcMC4rJC8sICcnKSwgaW5kZXgsIHdvcmtpbmdEaXIpKTtcbiAgICAgIH1cbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBTdGF0dXNSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IHBhcnNlU3RhdHVzU3VtbWFyeSB9IGZyb20gJy4uL3Jlc3BvbnNlcy9TdGF0dXNTdW1tYXJ5JztcbmltcG9ydCB7IFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IGlnbm9yZWRPcHRpb25zID0gWyctLW51bGwnLCAnLXonXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXR1c1Rhc2soY3VzdG9tQXJnczogc3RyaW5nW10pOiBTdHJpbmdUYXNrPFN0YXR1c1Jlc3VsdD4ge1xuICAgY29uc3QgY29tbWFuZHMgPSBbXG4gICAgICAnc3RhdHVzJyxcbiAgICAgICctLXBvcmNlbGFpbicsXG4gICAgICAnLWInLFxuICAgICAgJy11JyxcbiAgICAgICctLW51bGwnLFxuICAgICAgLi4uY3VzdG9tQXJncy5maWx0ZXIoKGFyZykgPT4gIWlnbm9yZWRPcHRpb25zLmluY2x1ZGVzKGFyZykpLFxuICAgXTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgcGFyc2VyKHRleHQ6IHN0cmluZykge1xuICAgICAgICAgcmV0dXJuIHBhcnNlU3RhdHVzU3VtbWFyeSh0ZXh0KTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImltcG9ydCB0eXBlIHsgU2ltcGxlR2l0QXBpIH0gZnJvbSAnLi4vc2ltcGxlLWdpdC1hcGknO1xuaW1wb3J0IHR5cGUgeyBTaW1wbGVHaXQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IGFzTnVtYmVyLCBFeGl0Q29kZXMsIExpbmVQYXJzZXIsIHBhcnNlU3RyaW5nUmVzcG9uc2UgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVyc2lvblJlc3VsdCB7XG4gICBtYWpvcjogbnVtYmVyO1xuICAgbWlub3I6IG51bWJlcjtcbiAgIHBhdGNoOiBudW1iZXIgfCBzdHJpbmc7XG4gICBhZ2VudDogc3RyaW5nO1xuICAgaW5zdGFsbGVkOiBib29sZWFuO1xufVxuXG5jb25zdCBOT1RfSU5TVEFMTEVEID0gJ2luc3RhbGxlZD1mYWxzZSc7XG5cbmZ1bmN0aW9uIHZlcnNpb25SZXNwb25zZShcbiAgIG1ham9yID0gMCxcbiAgIG1pbm9yID0gMCxcbiAgIHBhdGNoOiBzdHJpbmcgfCBudW1iZXIgPSAwLFxuICAgYWdlbnQgPSAnJyxcbiAgIGluc3RhbGxlZCA9IHRydWVcbik6IFZlcnNpb25SZXN1bHQge1xuICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgIHtcbiAgICAgICAgIG1ham9yLFxuICAgICAgICAgbWlub3IsXG4gICAgICAgICBwYXRjaCxcbiAgICAgICAgIGFnZW50LFxuICAgICAgICAgaW5zdGFsbGVkLFxuICAgICAgfSxcbiAgICAgICd0b1N0cmluZycsXG4gICAgICB7XG4gICAgICAgICB2YWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLm1ham9yfS4ke3RoaXMubWlub3J9LiR7dGhpcy5wYXRjaH1gO1xuICAgICAgICAgfSxcbiAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIH1cbiAgICk7XG59XG5cbmZ1bmN0aW9uIG5vdEluc3RhbGxlZFJlc3BvbnNlKCkge1xuICAgcmV0dXJuIHZlcnNpb25SZXNwb25zZSgwLCAwLCAwLCAnJywgZmFsc2UpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKTogUGljazxTaW1wbGVHaXQsICd2ZXJzaW9uJz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIHZlcnNpb24odGhpczogU2ltcGxlR2l0QXBpKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh7XG4gICAgICAgICAgICBjb21tYW5kczogWyctLXZlcnNpb24nXSxcbiAgICAgICAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgICAgICAgIHBhcnNlcjogdmVyc2lvblBhcnNlcixcbiAgICAgICAgICAgIG9uRXJyb3IocmVzdWx0LCBlcnJvciwgZG9uZSwgZmFpbCkge1xuICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5leGl0Q29kZSA9PT0gRXhpdENvZGVzLk5PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvbmUoQnVmZmVyLmZyb20oTk9UX0lOU1RBTExFRCkpO1xuICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICBmYWlsKGVycm9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICB9KTtcbiAgICAgIH0sXG4gICB9O1xufVxuXG5jb25zdCBwYXJzZXJzOiBMaW5lUGFyc2VyPFZlcnNpb25SZXN1bHQ+W10gPSBbXG4gICBuZXcgTGluZVBhcnNlcihcbiAgICAgIC92ZXJzaW9uIChcXGQrKVxcLihcXGQrKVxcLihcXGQrKSg/OlxccypcXCgoLispXFwpKT8vLFxuICAgICAgKHJlc3VsdCwgW21ham9yLCBtaW5vciwgcGF0Y2gsIGFnZW50ID0gJyddKSA9PiB7XG4gICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgdmVyc2lvblJlc3BvbnNlKGFzTnVtYmVyKG1ham9yKSwgYXNOdW1iZXIobWlub3IpLCBhc051bWJlcihwYXRjaCksIGFnZW50KVxuICAgICAgICAgKTtcbiAgICAgIH1cbiAgICksXG4gICBuZXcgTGluZVBhcnNlcihcbiAgICAgIC92ZXJzaW9uIChcXGQrKVxcLihcXGQrKVxcLihcXEQrKSguKyk/JC8sXG4gICAgICAocmVzdWx0LCBbbWFqb3IsIG1pbm9yLCBwYXRjaCwgYWdlbnQgPSAnJ10pID0+IHtcbiAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2ZXJzaW9uUmVzcG9uc2UoYXNOdW1iZXIobWFqb3IpLCBhc051bWJlcihtaW5vciksIHBhdGNoLCBhZ2VudCkpO1xuICAgICAgfVxuICAgKSxcbl07XG5cbmZ1bmN0aW9uIHZlcnNpb25QYXJzZXIoc3RkT3V0OiBzdHJpbmcpIHtcbiAgIGlmIChzdGRPdXQgPT09IE5PVF9JTlNUQUxMRUQpIHtcbiAgICAgIHJldHVybiBub3RJbnN0YWxsZWRSZXNwb25zZSgpO1xuICAgfVxuXG4gICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZSh2ZXJzaW9uUmVzcG9uc2UoMCwgMCwgMCwgc3RkT3V0KSwgcGFyc2Vycywgc3RkT3V0KTtcbn1cbiIsICJpbXBvcnQgeyBTaW1wbGVHaXRCYXNlIH0gZnJvbSAnLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyB0YXNrQ2FsbGJhY2sgfSBmcm9tICcuL3Rhc2stY2FsbGJhY2snO1xuaW1wb3J0IHsgY2hhbmdlV29ya2luZ0RpcmVjdG9yeVRhc2sgfSBmcm9tICcuL3Rhc2tzL2NoYW5nZS13b3JraW5nLWRpcmVjdG9yeSc7XG5pbXBvcnQgY2hlY2tvdXQgZnJvbSAnLi90YXNrcy9jaGVja291dCc7XG5pbXBvcnQgY29tbWl0IGZyb20gJy4vdGFza3MvY29tbWl0JztcbmltcG9ydCBjb25maWcgZnJvbSAnLi90YXNrcy9jb25maWcnO1xuaW1wb3J0IGZpcnN0Q29tbWl0IGZyb20gJy4vdGFza3MvZmlyc3QtY29tbWl0JztcbmltcG9ydCBncmVwIGZyb20gJy4vdGFza3MvZ3JlcCc7XG5pbXBvcnQgeyBoYXNoT2JqZWN0VGFzayB9IGZyb20gJy4vdGFza3MvaGFzaC1vYmplY3QnO1xuaW1wb3J0IHsgaW5pdFRhc2sgfSBmcm9tICcuL3Rhc2tzL2luaXQnO1xuaW1wb3J0IGxvZyBmcm9tICcuL3Rhc2tzL2xvZyc7XG5pbXBvcnQgeyBtZXJnZVRhc2sgfSBmcm9tICcuL3Rhc2tzL21lcmdlJztcbmltcG9ydCB7IHB1c2hUYXNrIH0gZnJvbSAnLi90YXNrcy9wdXNoJztcbmltcG9ydCBzaG93IGZyb20gJy4vdGFza3Mvc2hvdyc7XG5pbXBvcnQgeyBzdGF0dXNUYXNrIH0gZnJvbSAnLi90YXNrcy9zdGF0dXMnO1xuaW1wb3J0IHsgY29uZmlndXJhdGlvbkVycm9yVGFzaywgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFza3MvdGFzayc7XG5pbXBvcnQgdmVyc2lvbiBmcm9tICcuL3Rhc2tzL3ZlcnNpb24nO1xuaW1wb3J0IHsgb3V0cHV0SGFuZGxlciwgU2ltcGxlR2l0RXhlY3V0b3IsIFNpbXBsZUdpdFRhc2ssIFNpbXBsZUdpdFRhc2tDYWxsYmFjayB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgIGFzQXJyYXksXG4gICBmaWx0ZXJTdHJpbmcsXG4gICBmaWx0ZXJUeXBlLFxuICAgZ2V0VHJhaWxpbmdPcHRpb25zLFxuICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50LFxufSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGNsYXNzIFNpbXBsZUdpdEFwaSBpbXBsZW1lbnRzIFNpbXBsZUdpdEJhc2Uge1xuICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZXhlY3V0b3I6IFNpbXBsZUdpdEV4ZWN1dG9yKSB7fVxuXG4gICBwcm90ZWN0ZWQgX3J1blRhc2s8VD4odGFzazogU2ltcGxlR2l0VGFzazxUPiwgdGhlbj86IFNpbXBsZUdpdFRhc2tDYWxsYmFjazxUPikge1xuICAgICAgY29uc3QgY2hhaW4gPSB0aGlzLl9leGVjdXRvci5jaGFpbigpO1xuICAgICAgY29uc3QgcHJvbWlzZSA9IGNoYWluLnB1c2godGFzayk7XG5cbiAgICAgIGlmICh0aGVuKSB7XG4gICAgICAgICB0YXNrQ2FsbGJhY2sodGFzaywgcHJvbWlzZSwgdGhlbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKHRoaXMsIHtcbiAgICAgICAgIHRoZW46IHsgdmFsdWU6IHByb21pc2UudGhlbi5iaW5kKHByb21pc2UpIH0sXG4gICAgICAgICBjYXRjaDogeyB2YWx1ZTogcHJvbWlzZS5jYXRjaC5iaW5kKHByb21pc2UpIH0sXG4gICAgICAgICBfZXhlY3V0b3I6IHsgdmFsdWU6IGNoYWluIH0sXG4gICAgICB9KTtcbiAgIH1cblxuICAgYWRkKGZpbGVzOiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFsnYWRkJywgLi4uYXNBcnJheShmaWxlcyldKSxcbiAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICApO1xuICAgfVxuXG4gICBjd2QoZGlyZWN0b3J5OiBzdHJpbmcgfCB7IHBhdGg6IHN0cmluZzsgcm9vdD86IGJvb2xlYW4gfSkge1xuICAgICAgY29uc3QgbmV4dCA9IHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpO1xuXG4gICAgICBpZiAodHlwZW9mIGRpcmVjdG9yeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKGNoYW5nZVdvcmtpbmdEaXJlY3RvcnlUYXNrKGRpcmVjdG9yeSwgdGhpcy5fZXhlY3V0b3IpLCBuZXh0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBkaXJlY3Rvcnk/LnBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIGNoYW5nZVdvcmtpbmdEaXJlY3RvcnlUYXNrKFxuICAgICAgICAgICAgICAgZGlyZWN0b3J5LnBhdGgsXG4gICAgICAgICAgICAgICAoZGlyZWN0b3J5LnJvb3QgJiYgdGhpcy5fZXhlY3V0b3IpIHx8IHVuZGVmaW5lZFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG5leHRcbiAgICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgY29uZmlndXJhdGlvbkVycm9yVGFzaygnR2l0LmN3ZDogd29ya2luZ0RpcmVjdG9yeSBtdXN0IGJlIHN1cHBsaWVkIGFzIGEgc3RyaW5nJyksXG4gICAgICAgICBuZXh0XG4gICAgICApO1xuICAgfVxuXG4gICBoYXNoT2JqZWN0KHBhdGg6IHN0cmluZywgd3JpdGU6IGJvb2xlYW4gfCB1bmtub3duKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgIGhhc2hPYmplY3RUYXNrKHBhdGgsIHdyaXRlID09PSB0cnVlKSxcbiAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICApO1xuICAgfVxuXG4gICBpbml0KGJhcmU/OiBib29sZWFuIHwgdW5rbm93bikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICBpbml0VGFzayhiYXJlID09PSB0cnVlLCB0aGlzLl9leGVjdXRvci5jd2QsIGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpKSxcbiAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICApO1xuICAgfVxuXG4gICBtZXJnZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgbWVyZ2VUYXNrKGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpKSxcbiAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICApO1xuICAgfVxuXG4gICBtZXJnZUZyb21UbyhyZW1vdGU6IHN0cmluZywgYnJhbmNoOiBzdHJpbmcpIHtcbiAgICAgIGlmICghKGZpbHRlclN0cmluZyhyZW1vdGUpICYmIGZpbHRlclN0cmluZyhicmFuY2gpKSkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBjb25maWd1cmF0aW9uRXJyb3JUYXNrKFxuICAgICAgICAgICAgICAgYEdpdC5tZXJnZUZyb21UbyByZXF1aXJlcyB0aGF0IHRoZSAncmVtb3RlJyBhbmQgJ2JyYW5jaCcgYXJndW1lbnRzIGFyZSBzdXBwbGllZCBhcyBzdHJpbmdzYFxuICAgICAgICAgICAgKVxuICAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICBtZXJnZVRhc2soW3JlbW90ZSwgYnJhbmNoLCAuLi5nZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKV0pLFxuICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cywgZmFsc2UpXG4gICAgICApO1xuICAgfVxuXG4gICBvdXRwdXRIYW5kbGVyKGhhbmRsZXI6IG91dHB1dEhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2V4ZWN1dG9yLm91dHB1dEhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9XG5cbiAgIHB1c2goKSB7XG4gICAgICBjb25zdCB0YXNrID0gcHVzaFRhc2soXG4gICAgICAgICB7XG4gICAgICAgICAgICByZW1vdGU6IGZpbHRlclR5cGUoYXJndW1lbnRzWzBdLCBmaWx0ZXJTdHJpbmcpLFxuICAgICAgICAgICAgYnJhbmNoOiBmaWx0ZXJUeXBlKGFyZ3VtZW50c1sxXSwgZmlsdGVyU3RyaW5nKSxcbiAgICAgICAgIH0sXG4gICAgICAgICBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cykpO1xuICAgfVxuXG4gICBzdGFzaCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbJ3N0YXNoJywgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cyldKSxcbiAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICApO1xuICAgfVxuXG4gICBzdGF0dXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgIHN0YXR1c1Rhc2soZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cykpLFxuICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICk7XG4gICB9XG59XG5cbk9iamVjdC5hc3NpZ24oXG4gICBTaW1wbGVHaXRBcGkucHJvdG90eXBlLFxuICAgY2hlY2tvdXQoKSxcbiAgIGNvbW1pdCgpLFxuICAgY29uZmlnKCksXG4gICBmaXJzdENvbW1pdCgpLFxuICAgZ3JlcCgpLFxuICAgbG9nKCksXG4gICBzaG93KCksXG4gICB2ZXJzaW9uKClcbik7XG4iLCAiaW1wb3J0IHsgYXBwZW5kLCByZW1vdmUgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBjcmVhdGVEZWZlcnJlZCwgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAnQGt3c2l0ZXMvcHJvbWlzZS1kZWZlcnJlZCc7XG5pbXBvcnQgeyBjcmVhdGVMb2dnZXIgfSBmcm9tICcuLi9naXQtbG9nZ2VyJztcblxudHlwZSBTY2hlZHVsZUNvbXBsZXRlQ2FsbGJhY2sgPSAoKSA9PiB2b2lkO1xudHlwZSBTY2hlZHVsZWRUYXNrID0gUGljazxEZWZlcnJlZFByb21pc2U8U2NoZWR1bGVDb21wbGV0ZUNhbGxiYWNrPiwgJ3Byb21pc2UnIHwgJ2RvbmUnPiAmIHtcbiAgIGlkOiBudW1iZXI7XG59O1xuXG5jb25zdCBjcmVhdGVTY2hlZHVsZWRUYXNrOiAoKSA9PiBTY2hlZHVsZWRUYXNrID0gKCgpID0+IHtcbiAgIGxldCBpZCA9IDA7XG4gICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWQrKztcbiAgICAgIGNvbnN0IHsgcHJvbWlzZSwgZG9uZSB9ID0gY3JlYXRlRGVmZXJyZWQ8U2NoZWR1bGVDb21wbGV0ZUNhbGxiYWNrPigpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgIGRvbmUsXG4gICAgICAgICBpZCxcbiAgICAgIH07XG4gICB9O1xufSkoKTtcblxuZXhwb3J0IGNsYXNzIFNjaGVkdWxlciB7XG4gICBwcml2YXRlIGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcignJywgJ3NjaGVkdWxlcicpO1xuICAgcHJpdmF0ZSBwZW5kaW5nOiBTY2hlZHVsZWRUYXNrW10gPSBbXTtcbiAgIHByaXZhdGUgcnVubmluZzogU2NoZWR1bGVkVGFza1tdID0gW107XG5cbiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgY29uY3VycmVuY3kgPSAyKSB7XG4gICAgICB0aGlzLmxvZ2dlcihgQ29uc3RydWN0ZWQsIGNvbmN1cnJlbmN5PSVzYCwgY29uY3VycmVuY3kpO1xuICAgfVxuXG4gICBwcml2YXRlIHNjaGVkdWxlKCkge1xuICAgICAgaWYgKCF0aGlzLnBlbmRpbmcubGVuZ3RoIHx8IHRoaXMucnVubmluZy5sZW5ndGggPj0gdGhpcy5jb25jdXJyZW5jeSkge1xuICAgICAgICAgdGhpcy5sb2dnZXIoXG4gICAgICAgICAgICBgU2NoZWR1bGUgYXR0ZW1wdCBpZ25vcmVkLCBwZW5kaW5nPSVzIHJ1bm5pbmc9JXMgY29uY3VycmVuY3k9JXNgLFxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRoaXMucnVubmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0aGlzLmNvbmN1cnJlbmN5XG4gICAgICAgICApO1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0YXNrID0gYXBwZW5kKHRoaXMucnVubmluZywgdGhpcy5wZW5kaW5nLnNoaWZ0KCkhKTtcbiAgICAgIHRoaXMubG9nZ2VyKGBBdHRlbXB0aW5nIGlkPSVzYCwgdGFzay5pZCk7XG4gICAgICB0YXNrLmRvbmUoKCkgPT4ge1xuICAgICAgICAgdGhpcy5sb2dnZXIoYENvbXBsZXRpbmcgaWQ9YCwgdGFzay5pZCk7XG4gICAgICAgICByZW1vdmUodGhpcy5ydW5uaW5nLCB0YXNrKTtcbiAgICAgICAgIHRoaXMuc2NoZWR1bGUoKTtcbiAgICAgIH0pO1xuICAgfVxuXG4gICBuZXh0KCk6IFByb21pc2U8U2NoZWR1bGVDb21wbGV0ZUNhbGxiYWNrPiB7XG4gICAgICBjb25zdCB7IHByb21pc2UsIGlkIH0gPSBhcHBlbmQodGhpcy5wZW5kaW5nLCBjcmVhdGVTY2hlZHVsZWRUYXNrKCkpO1xuICAgICAgdGhpcy5sb2dnZXIoYFNjaGVkdWxpbmcgaWQ9JXNgLCBpZCk7XG5cbiAgICAgIHRoaXMuc2NoZWR1bGUoKTtcblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5pbXBvcnQgeyBPcHRpb25GbGFncywgT3B0aW9ucywgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IHR5cGUgQXBwbHlPcHRpb25zID0gT3B0aW9ucyAmXG4gICBPcHRpb25GbGFnczxcbiAgICAgIHwgJy0tc3RhdCdcbiAgICAgIHwgJy0tbnVtc3RhdCdcbiAgICAgIHwgJy0tc3VtbWFyeSdcbiAgICAgIHwgJy0tY2hlY2snXG4gICAgICB8ICctLWluZGV4J1xuICAgICAgfCAnLS1pbnRlbnQtdG8tYWRkJ1xuICAgICAgfCAnLS0zd2F5J1xuICAgICAgfCAnLS1hcHBseSdcbiAgICAgIHwgJy0tbm8tYWRkJ1xuICAgICAgfCAnLVInXG4gICAgICB8ICctLXJldmVyc2UnXG4gICAgICB8ICctLWFsbG93LWJpbmFyeS1yZXBsYWNlbWVudCdcbiAgICAgIHwgJy0tYmluYXJ5J1xuICAgICAgfCAnLS1yZWplY3QnXG4gICAgICB8ICcteidcbiAgICAgIHwgJy0taW5hY2N1cmF0ZS1lb2YnXG4gICAgICB8ICctLXJlY291bnQnXG4gICAgICB8ICctLWNhY2hlZCdcbiAgICAgIHwgJy0taWdub3JlLXNwYWNlLWNoYW5nZSdcbiAgICAgIHwgJy0taWdub3JlLXdoaXRlc3BhY2UnXG4gICAgICB8ICctLXZlcmJvc2UnXG4gICAgICB8ICctLXVuc2FmZS1wYXRocydcbiAgID4gJlxuICAgT3B0aW9uRmxhZ3M8Jy0td2hpdGVzcGFjZScsICdub3dhcm4nIHwgJ3dhcm4nIHwgJ2ZpeCcgfCAnZXJyb3InIHwgJ2Vycm9yLWFsbCc+ICZcbiAgIE9wdGlvbkZsYWdzPCctLWJ1aWxkLWZha2UtYW5jZXN0b3InIHwgJy0tZXhjbHVkZScgfCAnLS1pbmNsdWRlJyB8ICctLWRpcmVjdG9yeScsIHN0cmluZz4gJlxuICAgT3B0aW9uRmxhZ3M8Jy1wJyB8ICctQycsIG51bWJlcj47XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhdGNoVGFzayhwYXRjaGVzOiBzdHJpbmdbXSwgY3VzdG9tQXJnczogc3RyaW5nW10pOiBTdHJpbmdUYXNrPHN0cmluZz4ge1xuICAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soWydhcHBseScsIC4uLmN1c3RvbUFyZ3MsIC4uLnBhdGNoZXNdKTtcbn1cbiIsICJpbXBvcnQge1xuICAgQnJhbmNoTXVsdGlEZWxldGVSZXN1bHQsXG4gICBCcmFuY2hTaW5nbGVEZWxldGVGYWlsdXJlLFxuICAgQnJhbmNoU2luZ2xlRGVsZXRlUmVzdWx0LFxuICAgQnJhbmNoU2luZ2xlRGVsZXRlU3VjY2Vzcyxcbn0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5cbmV4cG9ydCBjbGFzcyBCcmFuY2hEZWxldGlvbkJhdGNoIGltcGxlbWVudHMgQnJhbmNoTXVsdGlEZWxldGVSZXN1bHQge1xuICAgYWxsOiBCcmFuY2hTaW5nbGVEZWxldGVSZXN1bHRbXSA9IFtdO1xuICAgYnJhbmNoZXM6IHsgW2JyYW5jaE5hbWU6IHN0cmluZ106IEJyYW5jaFNpbmdsZURlbGV0ZVJlc3VsdCB9ID0ge307XG4gICBlcnJvcnM6IEJyYW5jaFNpbmdsZURlbGV0ZVJlc3VsdFtdID0gW107XG5cbiAgIGdldCBzdWNjZXNzKCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuICF0aGlzLmVycm9ycy5sZW5ndGg7XG4gICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBicmFuY2hEZWxldGlvblN1Y2Nlc3MoYnJhbmNoOiBzdHJpbmcsIGhhc2g6IHN0cmluZyk6IEJyYW5jaFNpbmdsZURlbGV0ZVN1Y2Nlc3Mge1xuICAgcmV0dXJuIHtcbiAgICAgIGJyYW5jaCxcbiAgICAgIGhhc2gsXG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJyYW5jaERlbGV0aW9uRmFpbHVyZShicmFuY2g6IHN0cmluZyk6IEJyYW5jaFNpbmdsZURlbGV0ZUZhaWx1cmUge1xuICAgcmV0dXJuIHtcbiAgICAgIGJyYW5jaCxcbiAgICAgIGhhc2g6IG51bGwsXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1NpbmdsZUJyYW5jaERlbGV0ZUZhaWx1cmUoXG4gICB0ZXN0OiBCcmFuY2hTaW5nbGVEZWxldGVSZXN1bHRcbik6IHRlc3QgaXMgQnJhbmNoU2luZ2xlRGVsZXRlU3VjY2VzcyB7XG4gICByZXR1cm4gdGVzdC5zdWNjZXNzO1xufVxuIiwgImltcG9ydCB7IEJyYW5jaE11bHRpRGVsZXRlUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQge1xuICAgQnJhbmNoRGVsZXRpb25CYXRjaCxcbiAgIGJyYW5jaERlbGV0aW9uRmFpbHVyZSxcbiAgIGJyYW5jaERlbGV0aW9uU3VjY2Vzcyxcbn0gZnJvbSAnLi4vcmVzcG9uc2VzL0JyYW5jaERlbGV0ZVN1bW1hcnknO1xuaW1wb3J0IHsgVGFza1BhcnNlciB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEV4aXRDb2RlcywgTGluZVBhcnNlciwgcGFyc2VTdHJpbmdSZXNwb25zZSB9IGZyb20gJy4uL3V0aWxzJztcblxuY29uc3QgZGVsZXRlU3VjY2Vzc1JlZ2V4ID0gLyhcXFMrKVxccytcXChcXFMrXFxzKFteKV0rKVxcKS87XG5jb25zdCBkZWxldGVFcnJvclJlZ2V4ID0gL15lcnJvclteJ10rJyhbXiddKyknL207XG5cbmNvbnN0IHBhcnNlcnM6IExpbmVQYXJzZXI8QnJhbmNoTXVsdGlEZWxldGVSZXN1bHQ+W10gPSBbXG4gICBuZXcgTGluZVBhcnNlcihkZWxldGVTdWNjZXNzUmVnZXgsIChyZXN1bHQsIFticmFuY2gsIGhhc2hdKSA9PiB7XG4gICAgICBjb25zdCBkZWxldGlvbiA9IGJyYW5jaERlbGV0aW9uU3VjY2VzcyhicmFuY2gsIGhhc2gpO1xuXG4gICAgICByZXN1bHQuYWxsLnB1c2goZGVsZXRpb24pO1xuICAgICAgcmVzdWx0LmJyYW5jaGVzW2JyYW5jaF0gPSBkZWxldGlvbjtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoZGVsZXRlRXJyb3JSZWdleCwgKHJlc3VsdCwgW2JyYW5jaF0pID0+IHtcbiAgICAgIGNvbnN0IGRlbGV0aW9uID0gYnJhbmNoRGVsZXRpb25GYWlsdXJlKGJyYW5jaCk7XG5cbiAgICAgIHJlc3VsdC5lcnJvcnMucHVzaChkZWxldGlvbik7XG4gICAgICByZXN1bHQuYWxsLnB1c2goZGVsZXRpb24pO1xuICAgICAgcmVzdWx0LmJyYW5jaGVzW2JyYW5jaF0gPSBkZWxldGlvbjtcbiAgIH0pLFxuXTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQnJhbmNoRGVsZXRpb25zOiBUYXNrUGFyc2VyPHN0cmluZywgQnJhbmNoTXVsdGlEZWxldGVSZXN1bHQ+ID0gKFxuICAgc3RkT3V0LFxuICAgc3RkRXJyXG4pID0+IHtcbiAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKG5ldyBCcmFuY2hEZWxldGlvbkJhdGNoKCksIHBhcnNlcnMsIFtzdGRPdXQsIHN0ZEVycl0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0JyYW5jaERlbGV0aW9uRXJyb3IoZGF0YTogc3RyaW5nLCBwcm9jZXNzRXhpdENvZGU6IEV4aXRDb2Rlcyk6IGJvb2xlYW4ge1xuICAgcmV0dXJuIHByb2Nlc3NFeGl0Q29kZSA9PT0gRXhpdENvZGVzLkVSUk9SICYmIGRlbGV0ZUVycm9yUmVnZXgudGVzdChkYXRhKTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IEJyYW5jaFN1bW1hcnksIEJyYW5jaFN1bW1hcnlCcmFuY2ggfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcblxuZXhwb3J0IGVudW0gQnJhbmNoU3RhdHVzSWRlbnRpZmllciB7XG4gICBDVVJSRU5UID0gJyonLFxuICAgTElOS0VEID0gJysnLFxufVxuXG5leHBvcnQgY2xhc3MgQnJhbmNoU3VtbWFyeVJlc3VsdCBpbXBsZW1lbnRzIEJyYW5jaFN1bW1hcnkge1xuICAgcHVibGljIGFsbDogc3RyaW5nW10gPSBbXTtcbiAgIHB1YmxpYyBicmFuY2hlczogeyBbcDogc3RyaW5nXTogQnJhbmNoU3VtbWFyeUJyYW5jaCB9ID0ge307XG4gICBwdWJsaWMgY3VycmVudDogc3RyaW5nID0gJyc7XG4gICBwdWJsaWMgZGV0YWNoZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgcHVzaChcbiAgICAgIHN0YXR1czogQnJhbmNoU3RhdHVzSWRlbnRpZmllciB8IHVua25vd24sXG4gICAgICBkZXRhY2hlZDogYm9vbGVhbixcbiAgICAgIG5hbWU6IHN0cmluZyxcbiAgICAgIGNvbW1pdDogc3RyaW5nLFxuICAgICAgbGFiZWw6IHN0cmluZ1xuICAgKSB7XG4gICAgICBpZiAoc3RhdHVzID09PSBCcmFuY2hTdGF0dXNJZGVudGlmaWVyLkNVUlJFTlQpIHtcbiAgICAgICAgIHRoaXMuZGV0YWNoZWQgPSBkZXRhY2hlZDtcbiAgICAgICAgIHRoaXMuY3VycmVudCA9IG5hbWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWxsLnB1c2gobmFtZSk7XG4gICAgICB0aGlzLmJyYW5jaGVzW25hbWVdID0ge1xuICAgICAgICAgY3VycmVudDogc3RhdHVzID09PSBCcmFuY2hTdGF0dXNJZGVudGlmaWVyLkNVUlJFTlQsXG4gICAgICAgICBsaW5rZWRXb3JrVHJlZTogc3RhdHVzID09PSBCcmFuY2hTdGF0dXNJZGVudGlmaWVyLkxJTktFRCxcbiAgICAgICAgIG5hbWUsXG4gICAgICAgICBjb21taXQsXG4gICAgICAgICBsYWJlbCxcbiAgICAgIH07XG4gICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBCcmFuY2hTdW1tYXJ5IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBCcmFuY2hTdW1tYXJ5UmVzdWx0IH0gZnJvbSAnLi4vcmVzcG9uc2VzL0JyYW5jaFN1bW1hcnknO1xuaW1wb3J0IHsgTGluZVBhcnNlciwgcGFyc2VTdHJpbmdSZXNwb25zZSB9IGZyb20gJy4uL3V0aWxzJztcblxuY29uc3QgcGFyc2VyczogTGluZVBhcnNlcjxCcmFuY2hTdW1tYXJ5UmVzdWx0PltdID0gW1xuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvXihbKitdXFxzKT9cXCgoPzpIRUFEICk/ZGV0YWNoZWQgKD86ZnJvbXxhdCkgKFxcUyspXFwpXFxzKyhbYS16MC05XSspXFxzKC4qKSQvLFxuICAgICAgKHJlc3VsdCwgW2N1cnJlbnQsIG5hbWUsIGNvbW1pdCwgbGFiZWxdKSA9PiB7XG4gICAgICAgICByZXN1bHQucHVzaChicmFuY2hTdGF0dXMoY3VycmVudCksIHRydWUsIG5hbWUsIGNvbW1pdCwgbGFiZWwpO1xuICAgICAgfVxuICAgKSxcbiAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgL14oWyorXVxccyk/KFxcUyspXFxzKyhbYS16MC05XSspXFxzPyguKikkL3MsXG4gICAgICAocmVzdWx0LCBbY3VycmVudCwgbmFtZSwgY29tbWl0LCBsYWJlbF0pID0+IHtcbiAgICAgICAgIHJlc3VsdC5wdXNoKGJyYW5jaFN0YXR1cyhjdXJyZW50KSwgZmFsc2UsIG5hbWUsIGNvbW1pdCwgbGFiZWwpO1xuICAgICAgfVxuICAgKSxcbl07XG5cbmZ1bmN0aW9uIGJyYW5jaFN0YXR1cyhpbnB1dD86IHN0cmluZykge1xuICAgcmV0dXJuIGlucHV0ID8gaW5wdXQuY2hhckF0KDApIDogJyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUJyYW5jaFN1bW1hcnkoc3RkT3V0OiBzdHJpbmcpOiBCcmFuY2hTdW1tYXJ5IHtcbiAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKG5ldyBCcmFuY2hTdW1tYXJ5UmVzdWx0KCksIHBhcnNlcnMsIHN0ZE91dCk7XG59XG4iLCAiaW1wb3J0IHsgQnJhbmNoTXVsdGlEZWxldGVSZXN1bHQsIEJyYW5jaFNpbmdsZURlbGV0ZVJlc3VsdCwgQnJhbmNoU3VtbWFyeSB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEdpdFJlc3BvbnNlRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZ2l0LXJlc3BvbnNlLWVycm9yJztcbmltcG9ydCB7IGhhc0JyYW5jaERlbGV0aW9uRXJyb3IsIHBhcnNlQnJhbmNoRGVsZXRpb25zIH0gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZS1icmFuY2gtZGVsZXRlJztcbmltcG9ydCB7IHBhcnNlQnJhbmNoU3VtbWFyeSB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtYnJhbmNoJztcbmltcG9ydCB7IGJ1ZmZlclRvU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnNEZWxldGVCcmFuY2hDb21tYW5kKGNvbW1hbmRzOiBzdHJpbmdbXSkge1xuICAgY29uc3QgZGVsZXRlQ29tbWFuZHMgPSBbJy1kJywgJy1EJywgJy0tZGVsZXRlJ107XG4gICByZXR1cm4gY29tbWFuZHMuc29tZSgoY29tbWFuZCkgPT4gZGVsZXRlQ29tbWFuZHMuaW5jbHVkZXMoY29tbWFuZCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnJhbmNoVGFzayhcbiAgIGN1c3RvbUFyZ3M6IHN0cmluZ1tdXG4pOiBTdHJpbmdUYXNrPEJyYW5jaFN1bW1hcnkgfCBCcmFuY2hTaW5nbGVEZWxldGVSZXN1bHQ+IHtcbiAgIGNvbnN0IGlzRGVsZXRlID0gY29udGFpbnNEZWxldGVCcmFuY2hDb21tYW5kKGN1c3RvbUFyZ3MpO1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ2JyYW5jaCcsIC4uLmN1c3RvbUFyZ3NdO1xuXG4gICBpZiAoY29tbWFuZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKCctYScpO1xuICAgfVxuXG4gICBpZiAoIWNvbW1hbmRzLmluY2x1ZGVzKCctdicpKSB7XG4gICAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgJy12Jyk7XG4gICB9XG5cbiAgIHJldHVybiB7XG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBjb21tYW5kcyxcbiAgICAgIHBhcnNlcihzdGRPdXQsIHN0ZEVycikge1xuICAgICAgICAgaWYgKGlzRGVsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VCcmFuY2hEZWxldGlvbnMoc3RkT3V0LCBzdGRFcnIpLmFsbFswXTtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIHBhcnNlQnJhbmNoU3VtbWFyeShzdGRPdXQpO1xuICAgICAgfSxcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBicmFuY2hMb2NhbFRhc2soKTogU3RyaW5nVGFzazxCcmFuY2hTdW1tYXJ5PiB7XG4gICBjb25zdCBwYXJzZXIgPSBwYXJzZUJyYW5jaFN1bW1hcnk7XG5cbiAgIHJldHVybiB7XG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBjb21tYW5kczogWydicmFuY2gnLCAnLXYnXSxcbiAgICAgIHBhcnNlcixcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVCcmFuY2hlc1Rhc2soXG4gICBicmFuY2hlczogc3RyaW5nW10sXG4gICBmb3JjZURlbGV0ZSA9IGZhbHNlXG4pOiBTdHJpbmdUYXNrPEJyYW5jaE11bHRpRGVsZXRlUmVzdWx0PiB7XG4gICByZXR1cm4ge1xuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgY29tbWFuZHM6IFsnYnJhbmNoJywgJy12JywgZm9yY2VEZWxldGUgPyAnLUQnIDogJy1kJywgLi4uYnJhbmNoZXNdLFxuICAgICAgcGFyc2VyKHN0ZE91dCwgc3RkRXJyKSB7XG4gICAgICAgICByZXR1cm4gcGFyc2VCcmFuY2hEZWxldGlvbnMoc3RkT3V0LCBzdGRFcnIpO1xuICAgICAgfSxcbiAgICAgIG9uRXJyb3IoeyBleGl0Q29kZSwgc3RkT3V0IH0sIGVycm9yLCBkb25lLCBmYWlsKSB7XG4gICAgICAgICBpZiAoIWhhc0JyYW5jaERlbGV0aW9uRXJyb3IoU3RyaW5nKGVycm9yKSwgZXhpdENvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbChlcnJvcik7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGRvbmUoc3RkT3V0KTtcbiAgICAgIH0sXG4gICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsZXRlQnJhbmNoVGFzayhcbiAgIGJyYW5jaDogc3RyaW5nLFxuICAgZm9yY2VEZWxldGUgPSBmYWxzZVxuKTogU3RyaW5nVGFzazxCcmFuY2hTaW5nbGVEZWxldGVSZXN1bHQ+IHtcbiAgIGNvbnN0IHRhc2s6IFN0cmluZ1Rhc2s8QnJhbmNoU2luZ2xlRGVsZXRlUmVzdWx0PiA9IHtcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIGNvbW1hbmRzOiBbJ2JyYW5jaCcsICctdicsIGZvcmNlRGVsZXRlID8gJy1EJyA6ICctZCcsIGJyYW5jaF0sXG4gICAgICBwYXJzZXIoc3RkT3V0LCBzdGRFcnIpIHtcbiAgICAgICAgIHJldHVybiBwYXJzZUJyYW5jaERlbGV0aW9ucyhzdGRPdXQsIHN0ZEVycikuYnJhbmNoZXNbYnJhbmNoXSE7XG4gICAgICB9LFxuICAgICAgb25FcnJvcih7IGV4aXRDb2RlLCBzdGRFcnIsIHN0ZE91dCB9LCBlcnJvciwgXywgZmFpbCkge1xuICAgICAgICAgaWYgKCFoYXNCcmFuY2hEZWxldGlvbkVycm9yKFN0cmluZyhlcnJvciksIGV4aXRDb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWwoZXJyb3IpO1xuICAgICAgICAgfVxuXG4gICAgICAgICB0aHJvdyBuZXcgR2l0UmVzcG9uc2VFcnJvcihcbiAgICAgICAgICAgIHRhc2sucGFyc2VyKGJ1ZmZlclRvU3RyaW5nKHN0ZE91dCksIGJ1ZmZlclRvU3RyaW5nKHN0ZEVycikpLFxuICAgICAgICAgICAgU3RyaW5nKGVycm9yKVxuICAgICAgICAgKTtcbiAgICAgIH0sXG4gICB9O1xuXG4gICByZXR1cm4gdGFzaztcbn1cbiIsICIvKipcbiAqIFBhcnNlciBmb3IgdGhlIGBjaGVjay1pZ25vcmVgIGNvbW1hbmQgLSByZXR1cm5zIGVhY2ggZmlsZSBhcyBhIHN0cmluZyBhcnJheVxuICovXG5leHBvcnQgY29uc3QgcGFyc2VDaGVja0lnbm9yZSA9ICh0ZXh0OiBzdHJpbmcpOiBzdHJpbmdbXSA9PiB7XG4gICByZXR1cm4gdGV4dFxuICAgICAgLnNwbGl0KC9cXG4vZylcbiAgICAgIC5tYXAoKGxpbmUpID0+IGxpbmUudHJpbSgpKVxuICAgICAgLmZpbHRlcigoZmlsZSkgPT4gISFmaWxlKTtcbn07XG4iLCAiaW1wb3J0IHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IHBhcnNlQ2hlY2tJZ25vcmUgfSBmcm9tICcuLi9yZXNwb25zZXMvQ2hlY2tJZ25vcmUnO1xuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tJZ25vcmVUYXNrKHBhdGhzOiBzdHJpbmdbXSk6IFN0cmluZ1Rhc2s8c3RyaW5nW10+IHtcbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kczogWydjaGVjay1pZ25vcmUnLCAuLi5wYXRoc10sXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXI6IHBhcnNlQ2hlY2tJZ25vcmUsXG4gICB9O1xufVxuIiwgImltcG9ydCB7IGNvbmZpZ3VyYXRpb25FcnJvclRhc2ssIEVtcHR5VGFzaywgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5pbXBvcnQgeyBPcHRpb25GbGFncywgT3B0aW9ucywgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGFwcGVuZCwgZmlsdGVyU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgdHlwZSBDbG9uZU9wdGlvbnMgPSBPcHRpb25zICZcbiAgIE9wdGlvbkZsYWdzPFxuICAgICAgfCAnLS1iYXJlJ1xuICAgICAgfCAnLS1kaXNzb2NpYXRlJ1xuICAgICAgfCAnLS1taXJyb3InXG4gICAgICB8ICctLW5vLWNoZWNrb3V0J1xuICAgICAgfCAnLS1uby1yZW1vdGUtc3VibW9kdWxlcydcbiAgICAgIHwgJy0tbm8tc2hhbGxvdy1zdWJtb2R1bGVzJ1xuICAgICAgfCAnLS1uby1zaW5nbGUtYnJhbmNoJ1xuICAgICAgfCAnLS1uby10YWdzJ1xuICAgICAgfCAnLS1yZW1vdGUtc3VibW9kdWxlcydcbiAgICAgIHwgJy0tc2luZ2xlLWJyYW5jaCdcbiAgICAgIHwgJy0tc2hhbGxvdy1zdWJtb2R1bGVzJ1xuICAgICAgfCAnLS12ZXJib3NlJ1xuICAgPiAmXG4gICBPcHRpb25GbGFnczwnLS1kZXB0aCcgfCAnLWonIHwgJy0tam9icycsIG51bWJlcj4gJlxuICAgT3B0aW9uRmxhZ3M8XG4gICAgICB8ICctLWJyYW5jaCdcbiAgICAgIHwgJy0tb3JpZ2luJ1xuICAgICAgfCAnLS1yZWN1cnNlLXN1Ym1vZHVsZXMnXG4gICAgICB8ICctLXNlcGFyYXRlLWdpdC1kaXInXG4gICAgICB8ICctLXNoYWxsb3ctZXhjbHVkZSdcbiAgICAgIHwgJy0tc2hhbGxvdy1zaW5jZSdcbiAgICAgIHwgJy0tdGVtcGxhdGUnLFxuICAgICAgc3RyaW5nXG4gICA+O1xuXG5mdW5jdGlvbiBkaXNhbGxvd2VkQ29tbWFuZChjb21tYW5kOiBzdHJpbmcpIHtcbiAgIHJldHVybiAvXi0tdXBsb2FkLXBhY2soPXwkKS8udGVzdChjb21tYW5kKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lVGFzayhcbiAgIHJlcG86IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgIGRpcmVjdG9yeTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgY3VzdG9tQXJnczogc3RyaW5nW11cbik6IFN0cmluZ1Rhc2s8c3RyaW5nPiB8IEVtcHR5VGFzayB7XG4gICBjb25zdCBjb21tYW5kcyA9IFsnY2xvbmUnLCAuLi5jdXN0b21BcmdzXTtcblxuICAgZmlsdGVyU3RyaW5nKHJlcG8pICYmIGNvbW1hbmRzLnB1c2gocmVwbyk7XG4gICBmaWx0ZXJTdHJpbmcoZGlyZWN0b3J5KSAmJiBjb21tYW5kcy5wdXNoKGRpcmVjdG9yeSk7XG5cbiAgIGNvbnN0IGJhbm5lZCA9IGNvbW1hbmRzLmZpbmQoZGlzYWxsb3dlZENvbW1hbmQpO1xuICAgaWYgKGJhbm5lZCkge1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soYGdpdC5mZXRjaDogcG90ZW50aWFsIGV4cGxvaXQgYXJndW1lbnQgYmxvY2tlZC5gKTtcbiAgIH1cblxuICAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVNaXJyb3JUYXNrKFxuICAgcmVwbzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgZGlyZWN0b3J5OiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICBjdXN0b21BcmdzOiBzdHJpbmdbXVxuKSB7XG4gICBhcHBlbmQoY3VzdG9tQXJncywgJy0tbWlycm9yJyk7XG5cbiAgIHJldHVybiBjbG9uZVRhc2socmVwbywgZGlyZWN0b3J5LCBjdXN0b21BcmdzKTtcbn1cbiIsICJpbXBvcnQgeyBGZXRjaFJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgTGluZVBhcnNlciwgcGFyc2VTdHJpbmdSZXNwb25zZSB9IGZyb20gJy4uL3V0aWxzJztcblxuY29uc3QgcGFyc2VyczogTGluZVBhcnNlcjxGZXRjaFJlc3VsdD5bXSA9IFtcbiAgIG5ldyBMaW5lUGFyc2VyKC9Gcm9tICguKykkLywgKHJlc3VsdCwgW3JlbW90ZV0pID0+IHtcbiAgICAgIHJlc3VsdC5yZW1vdGUgPSByZW1vdGU7XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKC9cXCogXFxbbmV3IGJyYW5jaF1cXHMrKFxcUyspXFxzKi0+ICguKykkLywgKHJlc3VsdCwgW25hbWUsIHRyYWNraW5nXSkgPT4ge1xuICAgICAgcmVzdWx0LmJyYW5jaGVzLnB1c2goe1xuICAgICAgICAgbmFtZSxcbiAgICAgICAgIHRyYWNraW5nLFxuICAgICAgfSk7XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKC9cXCogXFxbbmV3IHRhZ11cXHMrKFxcUyspXFxzKi0+ICguKykkLywgKHJlc3VsdCwgW25hbWUsIHRyYWNraW5nXSkgPT4ge1xuICAgICAgcmVzdWx0LnRhZ3MucHVzaCh7XG4gICAgICAgICBuYW1lLFxuICAgICAgICAgdHJhY2tpbmcsXG4gICAgICB9KTtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoLy0gXFxbZGVsZXRlZF1cXHMrXFxTK1xccyotPiAoLispJC8sIChyZXN1bHQsIFt0cmFja2luZ10pID0+IHtcbiAgICAgIHJlc3VsdC5kZWxldGVkLnB1c2goe1xuICAgICAgICAgdHJhY2tpbmcsXG4gICAgICB9KTtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvXFxzKihbXi5dKylcXC5cXC4oXFxTKylcXHMrKFxcUyspXFxzKi0+ICguKykkLyxcbiAgICAgIChyZXN1bHQsIFtmcm9tLCB0bywgbmFtZSwgdHJhY2tpbmddKSA9PiB7XG4gICAgICAgICByZXN1bHQudXBkYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0cmFja2luZyxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgIH0pO1xuICAgICAgfVxuICAgKSxcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZldGNoUmVzdWx0KHN0ZE91dDogc3RyaW5nLCBzdGRFcnI6IHN0cmluZyk6IEZldGNoUmVzdWx0IHtcbiAgIGNvbnN0IHJlc3VsdDogRmV0Y2hSZXN1bHQgPSB7XG4gICAgICByYXc6IHN0ZE91dCxcbiAgICAgIHJlbW90ZTogbnVsbCxcbiAgICAgIGJyYW5jaGVzOiBbXSxcbiAgICAgIHRhZ3M6IFtdLFxuICAgICAgdXBkYXRlZDogW10sXG4gICAgICBkZWxldGVkOiBbXSxcbiAgIH07XG4gICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZShyZXN1bHQsIHBhcnNlcnMsIFtzdGRPdXQsIHN0ZEVycl0pO1xufVxuIiwgImltcG9ydCB7IEZldGNoUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBwYXJzZUZldGNoUmVzdWx0IH0gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZS1mZXRjaCc7XG5pbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjb25maWd1cmF0aW9uRXJyb3JUYXNrLCBFbXB0eVRhc2sgfSBmcm9tICcuL3Rhc2snO1xuXG5mdW5jdGlvbiBkaXNhbGxvd2VkQ29tbWFuZChjb21tYW5kOiBzdHJpbmcpIHtcbiAgIHJldHVybiAvXi0tdXBsb2FkLXBhY2soPXwkKS8udGVzdChjb21tYW5kKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZldGNoVGFzayhcbiAgIHJlbW90ZTogc3RyaW5nLFxuICAgYnJhbmNoOiBzdHJpbmcsXG4gICBjdXN0b21BcmdzOiBzdHJpbmdbXVxuKTogU3RyaW5nVGFzazxGZXRjaFJlc3VsdD4gfCBFbXB0eVRhc2sge1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ2ZldGNoJywgLi4uY3VzdG9tQXJnc107XG4gICBpZiAocmVtb3RlICYmIGJyYW5jaCkge1xuICAgICAgY29tbWFuZHMucHVzaChyZW1vdGUsIGJyYW5jaCk7XG4gICB9XG5cbiAgIGNvbnN0IGJhbm5lZCA9IGNvbW1hbmRzLmZpbmQoZGlzYWxsb3dlZENvbW1hbmQpO1xuICAgaWYgKGJhbm5lZCkge1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soYGdpdC5mZXRjaDogcG90ZW50aWFsIGV4cGxvaXQgYXJndW1lbnQgYmxvY2tlZC5gKTtcbiAgIH1cblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgcGFyc2VyOiBwYXJzZUZldGNoUmVzdWx0LFxuICAgfTtcbn1cbiIsICJpbXBvcnQgeyBNb3ZlUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBMaW5lUGFyc2VyLCBwYXJzZVN0cmluZ1Jlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jb25zdCBwYXJzZXJzOiBMaW5lUGFyc2VyPE1vdmVSZXN1bHQ+W10gPSBbXG4gICBuZXcgTGluZVBhcnNlcigvXlJlbmFtaW5nICguKykgdG8gKC4rKSQvLCAocmVzdWx0LCBbZnJvbSwgdG9dKSA9PiB7XG4gICAgICByZXN1bHQubW92ZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgfSksXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VNb3ZlUmVzdWx0KHN0ZE91dDogc3RyaW5nKTogTW92ZVJlc3VsdCB7XG4gICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZSh7IG1vdmVzOiBbXSB9LCBwYXJzZXJzLCBzdGRPdXQpO1xufVxuIiwgImltcG9ydCB7IE1vdmVSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IHBhcnNlTW92ZVJlc3VsdCB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtbW92ZSc7XG5pbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgYXNBcnJheSB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIG1vdmVUYXNrKGZyb206IHN0cmluZyB8IHN0cmluZ1tdLCB0bzogc3RyaW5nKTogU3RyaW5nVGFzazxNb3ZlUmVzdWx0PiB7XG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHM6IFsnbXYnLCAnLXYnLCAuLi5hc0FycmF5KGZyb20pLCB0b10sXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXI6IHBhcnNlTW92ZVJlc3VsdCxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgUHVsbFJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgR2l0UmVzcG9uc2VFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9naXQtcmVzcG9uc2UtZXJyb3InO1xuaW1wb3J0IHsgcGFyc2VQdWxsRXJyb3JSZXN1bHQsIHBhcnNlUHVsbFJlc3VsdCB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtcHVsbCc7XG5pbXBvcnQgeyBNYXliZSwgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGJ1ZmZlclRvU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gcHVsbFRhc2soXG4gICByZW1vdGU6IE1heWJlPHN0cmluZz4sXG4gICBicmFuY2g6IE1heWJlPHN0cmluZz4sXG4gICBjdXN0b21BcmdzOiBzdHJpbmdbXVxuKTogU3RyaW5nVGFzazxQdWxsUmVzdWx0PiB7XG4gICBjb25zdCBjb21tYW5kczogc3RyaW5nW10gPSBbJ3B1bGwnLCAuLi5jdXN0b21BcmdzXTtcbiAgIGlmIChyZW1vdGUgJiYgYnJhbmNoKSB7XG4gICAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgcmVtb3RlLCBicmFuY2gpO1xuICAgfVxuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXIoc3RkT3V0LCBzdGRFcnIpOiBQdWxsUmVzdWx0IHtcbiAgICAgICAgIHJldHVybiBwYXJzZVB1bGxSZXN1bHQoc3RkT3V0LCBzdGRFcnIpO1xuICAgICAgfSxcbiAgICAgIG9uRXJyb3IocmVzdWx0LCBfZXJyb3IsIF9kb25lLCBmYWlsKSB7XG4gICAgICAgICBjb25zdCBwdWxsRXJyb3IgPSBwYXJzZVB1bGxFcnJvclJlc3VsdChcbiAgICAgICAgICAgIGJ1ZmZlclRvU3RyaW5nKHJlc3VsdC5zdGRPdXQpLFxuICAgICAgICAgICAgYnVmZmVyVG9TdHJpbmcocmVzdWx0LnN0ZEVycilcbiAgICAgICAgICk7XG4gICAgICAgICBpZiAocHVsbEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbChuZXcgR2l0UmVzcG9uc2VFcnJvcihwdWxsRXJyb3IpKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgZmFpbChfZXJyb3IpO1xuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgZm9yRWFjaExpbmVXaXRoQ29udGVudCB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGludGVyZmFjZSBSZW1vdGVXaXRob3V0UmVmcyB7XG4gICBuYW1lOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVtb3RlV2l0aFJlZnMgZXh0ZW5kcyBSZW1vdGVXaXRob3V0UmVmcyB7XG4gICByZWZzOiB7XG4gICAgICBmZXRjaDogc3RyaW5nO1xuICAgICAgcHVzaDogc3RyaW5nO1xuICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlR2V0UmVtb3Rlcyh0ZXh0OiBzdHJpbmcpOiBSZW1vdGVXaXRob3V0UmVmc1tdIHtcbiAgIGNvbnN0IHJlbW90ZXM6IHsgW25hbWU6IHN0cmluZ106IFJlbW90ZVdpdGhvdXRSZWZzIH0gPSB7fTtcblxuICAgZm9yRWFjaCh0ZXh0LCAoW25hbWVdKSA9PiAocmVtb3Rlc1tuYW1lXSA9IHsgbmFtZSB9KSk7XG5cbiAgIHJldHVybiBPYmplY3QudmFsdWVzKHJlbW90ZXMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VHZXRSZW1vdGVzVmVyYm9zZSh0ZXh0OiBzdHJpbmcpOiBSZW1vdGVXaXRoUmVmc1tdIHtcbiAgIGNvbnN0IHJlbW90ZXM6IHsgW25hbWU6IHN0cmluZ106IFJlbW90ZVdpdGhSZWZzIH0gPSB7fTtcblxuICAgZm9yRWFjaCh0ZXh0LCAoW25hbWUsIHVybCwgcHVycG9zZV0pID0+IHtcbiAgICAgIGlmICghcmVtb3Rlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgcmVtb3Rlc1tuYW1lXSA9IHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICByZWZzOiB7IGZldGNoOiAnJywgcHVzaDogJycgfSxcbiAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChwdXJwb3NlICYmIHVybCkge1xuICAgICAgICAgcmVtb3Rlc1tuYW1lXS5yZWZzW3B1cnBvc2UucmVwbGFjZSgvW15hLXpdL2csICcnKSBhcyBrZXlvZiBSZW1vdGVXaXRoUmVmc1sncmVmcyddXSA9IHVybDtcbiAgICAgIH1cbiAgIH0pO1xuXG4gICByZXR1cm4gT2JqZWN0LnZhbHVlcyhyZW1vdGVzKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCh0ZXh0OiBzdHJpbmcsIGhhbmRsZXI6IChsaW5lOiBzdHJpbmdbXSkgPT4gdm9pZCkge1xuICAgZm9yRWFjaExpbmVXaXRoQ29udGVudCh0ZXh0LCAobGluZSkgPT4gaGFuZGxlcihsaW5lLnNwbGl0KC9cXHMrLykpKTtcbn1cbiIsICJpbXBvcnQgeyBwYXJzZUdldFJlbW90ZXMsIHBhcnNlR2V0UmVtb3Rlc1ZlcmJvc2UgfSBmcm9tICcuLi9yZXNwb25zZXMvR2V0UmVtb3RlU3VtbWFyeSc7XG5pbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRSZW1vdGVUYXNrKFxuICAgcmVtb3RlTmFtZTogc3RyaW5nLFxuICAgcmVtb3RlUmVwbzogc3RyaW5nLFxuICAgY3VzdG9tQXJnczogc3RyaW5nW10gPSBbXVxuKTogU3RyaW5nVGFzazxzdHJpbmc+IHtcbiAgIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFsncmVtb3RlJywgJ2FkZCcsIC4uLmN1c3RvbUFyZ3MsIHJlbW90ZU5hbWUsIHJlbW90ZVJlcG9dKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlbW90ZXNUYXNrKHZlcmJvc2U6IGJvb2xlYW4pOiBTdHJpbmdUYXNrPGFueT4ge1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ3JlbW90ZSddO1xuICAgaWYgKHZlcmJvc2UpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goJy12Jyk7XG4gICB9XG5cbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kcyxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcjogdmVyYm9zZSA/IHBhcnNlR2V0UmVtb3Rlc1ZlcmJvc2UgOiBwYXJzZUdldFJlbW90ZXMsXG4gICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlzdFJlbW90ZXNUYXNrKGN1c3RvbUFyZ3M6IHN0cmluZ1tdID0gW10pOiBTdHJpbmdUYXNrPHN0cmluZz4ge1xuICAgY29uc3QgY29tbWFuZHMgPSBbLi4uY3VzdG9tQXJnc107XG4gICBpZiAoY29tbWFuZHNbMF0gIT09ICdscy1yZW1vdGUnKSB7XG4gICAgICBjb21tYW5kcy51bnNoaWZ0KCdscy1yZW1vdGUnKTtcbiAgIH1cblxuICAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3RlVGFzayhjdXN0b21BcmdzOiBzdHJpbmdbXSA9IFtdKTogU3RyaW5nVGFzazxzdHJpbmc+IHtcbiAgIGNvbnN0IGNvbW1hbmRzID0gWy4uLmN1c3RvbUFyZ3NdO1xuICAgaWYgKGNvbW1hbmRzWzBdICE9PSAncmVtb3RlJykge1xuICAgICAgY29tbWFuZHMudW5zaGlmdCgncmVtb3RlJyk7XG4gICB9XG5cbiAgIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVJlbW90ZVRhc2socmVtb3RlTmFtZTogc3RyaW5nKSB7XG4gICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbJ3JlbW90ZScsICdyZW1vdmUnLCByZW1vdGVOYW1lXSk7XG59XG4iLCAiaW1wb3J0IHsgTG9nT3B0aW9ucywgTG9nUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBsb2dGb3JtYXRGcm9tQ29tbWFuZCB9IGZyb20gJy4uL2FyZ3MvbG9nLWZvcm1hdCc7XG5pbXBvcnQgeyBjcmVhdGVMaXN0TG9nU3VtbWFyeVBhcnNlciB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtbGlzdC1sb2ctc3VtbWFyeSc7XG5pbXBvcnQgdHlwZSB7IFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyB2YWxpZGF0ZUxvZ0Zvcm1hdENvbmZpZyB9IGZyb20gJy4vZGlmZic7XG5pbXBvcnQgeyBwYXJzZUxvZ09wdGlvbnMgfSBmcm9tICcuL2xvZyc7XG5pbXBvcnQgdHlwZSB7IEVtcHR5VGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFzaExpc3RUYXNrKFxuICAgb3B0OiBMb2dPcHRpb25zID0ge30sXG4gICBjdXN0b21BcmdzOiBzdHJpbmdbXVxuKTogRW1wdHlUYXNrIHwgU3RyaW5nVGFzazxMb2dSZXN1bHQ+IHtcbiAgIGNvbnN0IG9wdGlvbnMgPSBwYXJzZUxvZ09wdGlvbnM8YW55PihvcHQpO1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ3N0YXNoJywgJ2xpc3QnLCAuLi5vcHRpb25zLmNvbW1hbmRzLCAuLi5jdXN0b21BcmdzXTtcbiAgIGNvbnN0IHBhcnNlciA9IGNyZWF0ZUxpc3RMb2dTdW1tYXJ5UGFyc2VyKFxuICAgICAgb3B0aW9ucy5zcGxpdHRlcixcbiAgICAgIG9wdGlvbnMuZmllbGRzLFxuICAgICAgbG9nRm9ybWF0RnJvbUNvbW1hbmQoY29tbWFuZHMpXG4gICApO1xuXG4gICByZXR1cm4gKFxuICAgICAgdmFsaWRhdGVMb2dGb3JtYXRDb25maWcoY29tbWFuZHMpIHx8IHtcbiAgICAgICAgIGNvbW1hbmRzLFxuICAgICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgICAgcGFyc2VyLFxuICAgICAgfVxuICAgKTtcbn1cbiIsICJpbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRTdWJNb2R1bGVUYXNrKHJlcG86IHN0cmluZywgcGF0aDogc3RyaW5nKTogU3RyaW5nVGFzazxzdHJpbmc+IHtcbiAgIHJldHVybiBzdWJNb2R1bGVUYXNrKFsnYWRkJywgcmVwbywgcGF0aF0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdFN1Yk1vZHVsZVRhc2soY3VzdG9tQXJnczogc3RyaW5nW10pOiBTdHJpbmdUYXNrPHN0cmluZz4ge1xuICAgcmV0dXJuIHN1Yk1vZHVsZVRhc2soWydpbml0JywgLi4uY3VzdG9tQXJnc10pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3ViTW9kdWxlVGFzayhjdXN0b21BcmdzOiBzdHJpbmdbXSk6IFN0cmluZ1Rhc2s8c3RyaW5nPiB7XG4gICBjb25zdCBjb21tYW5kcyA9IFsuLi5jdXN0b21BcmdzXTtcbiAgIGlmIChjb21tYW5kc1swXSAhPT0gJ3N1Ym1vZHVsZScpIHtcbiAgICAgIGNvbW1hbmRzLnVuc2hpZnQoJ3N1Ym1vZHVsZScpO1xuICAgfVxuXG4gICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVTdWJNb2R1bGVUYXNrKGN1c3RvbUFyZ3M6IHN0cmluZ1tdKTogU3RyaW5nVGFzazxzdHJpbmc+IHtcbiAgIHJldHVybiBzdWJNb2R1bGVUYXNrKFsndXBkYXRlJywgLi4uY3VzdG9tQXJnc10pO1xufVxuIiwgImltcG9ydCB7IFRhZ1Jlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuXG5leHBvcnQgY2xhc3MgVGFnTGlzdCBpbXBsZW1lbnRzIFRhZ1Jlc3VsdCB7XG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyByZWFkb25seSBhbGw6IHN0cmluZ1tdLFxuICAgICAgcHVibGljIHJlYWRvbmx5IGxhdGVzdDogc3RyaW5nIHwgdW5kZWZpbmVkXG4gICApIHt9XG59XG5cbmV4cG9ydCBjb25zdCBwYXJzZVRhZ0xpc3QgPSBmdW5jdGlvbiAoZGF0YTogc3RyaW5nLCBjdXN0b21Tb3J0ID0gZmFsc2UpIHtcbiAgIGNvbnN0IHRhZ3MgPSBkYXRhLnNwbGl0KCdcXG4nKS5tYXAodHJpbW1lZCkuZmlsdGVyKEJvb2xlYW4pO1xuXG4gICBpZiAoIWN1c3RvbVNvcnQpIHtcbiAgICAgIHRhZ3Muc29ydChmdW5jdGlvbiAodGFnQSwgdGFnQikge1xuICAgICAgICAgY29uc3QgcGFydHNBID0gdGFnQS5zcGxpdCgnLicpO1xuICAgICAgICAgY29uc3QgcGFydHNCID0gdGFnQi5zcGxpdCgnLicpO1xuXG4gICAgICAgICBpZiAocGFydHNBLmxlbmd0aCA9PT0gMSB8fCBwYXJ0c0IubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gc2luZ2xlU29ydGVkKHRvTnVtYmVyKHBhcnRzQVswXSksIHRvTnVtYmVyKHBhcnRzQlswXSkpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IE1hdGgubWF4KHBhcnRzQS5sZW5ndGgsIHBhcnRzQi5sZW5ndGgpOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gc29ydGVkKHRvTnVtYmVyKHBhcnRzQVtpXSksIHRvTnVtYmVyKHBhcnRzQltpXSkpO1xuXG4gICAgICAgICAgICBpZiAoZGlmZikge1xuICAgICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG5cbiAgICAgICAgIHJldHVybiAwO1xuICAgICAgfSk7XG4gICB9XG5cbiAgIGNvbnN0IGxhdGVzdCA9IGN1c3RvbVNvcnQgPyB0YWdzWzBdIDogWy4uLnRhZ3NdLnJldmVyc2UoKS5maW5kKCh0YWcpID0+IHRhZy5pbmRleE9mKCcuJykgPj0gMCk7XG5cbiAgIHJldHVybiBuZXcgVGFnTGlzdCh0YWdzLCBsYXRlc3QpO1xufTtcblxuZnVuY3Rpb24gc2luZ2xlU29ydGVkKGE6IG51bWJlciwgYjogbnVtYmVyKTogbnVtYmVyIHtcbiAgIGNvbnN0IGFJc051bSA9IGlzTmFOKGEpO1xuICAgY29uc3QgYklzTnVtID0gaXNOYU4oYik7XG5cbiAgIGlmIChhSXNOdW0gIT09IGJJc051bSkge1xuICAgICAgcmV0dXJuIGFJc051bSA/IDEgOiAtMTtcbiAgIH1cblxuICAgcmV0dXJuIGFJc051bSA/IHNvcnRlZChhLCBiKSA6IDA7XG59XG5cbmZ1bmN0aW9uIHNvcnRlZChhOiBudW1iZXIsIGI6IG51bWJlcikge1xuICAgcmV0dXJuIGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTE7XG59XG5cbmZ1bmN0aW9uIHRyaW1tZWQoaW5wdXQ6IHN0cmluZykge1xuICAgcmV0dXJuIGlucHV0LnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gdG9OdW1iZXIoaW5wdXQ6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChpbnB1dC5yZXBsYWNlKC9eXFxEKy9nLCAnJyksIDEwKSB8fCAwO1xuICAgfVxuXG4gICByZXR1cm4gMDtcbn1cbiIsICJpbXBvcnQgeyBUYWdSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IHBhcnNlVGFnTGlzdCB9IGZyb20gJy4uL3Jlc3BvbnNlcy9UYWdMaXN0JztcbmltcG9ydCB7IFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5cbi8qKlxuICogVGFzayB1c2VkIGJ5IGBnaXQudGFnc2BcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRhZ0xpc3RUYXNrKGN1c3RvbUFyZ3M6IHN0cmluZ1tdID0gW10pOiBTdHJpbmdUYXNrPFRhZ1Jlc3VsdD4ge1xuICAgY29uc3QgaGFzQ3VzdG9tU29ydCA9IGN1c3RvbUFyZ3Muc29tZSgob3B0aW9uKSA9PiAvXi0tc29ydD0vLnRlc3Qob3B0aW9uKSk7XG5cbiAgIHJldHVybiB7XG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBjb21tYW5kczogWyd0YWcnLCAnLWwnLCAuLi5jdXN0b21BcmdzXSxcbiAgICAgIHBhcnNlcih0ZXh0OiBzdHJpbmcpIHtcbiAgICAgICAgIHJldHVybiBwYXJzZVRhZ0xpc3QodGV4dCwgaGFzQ3VzdG9tU29ydCk7XG4gICAgICB9LFxuICAgfTtcbn1cblxuLyoqXG4gKiBUYXNrIHVzZWQgYnkgYGdpdC5hZGRUYWdgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRUYWdUYXNrKG5hbWU6IHN0cmluZyk6IFN0cmluZ1Rhc2s8eyBuYW1lOiBzdHJpbmcgfT4ge1xuICAgcmV0dXJuIHtcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIGNvbW1hbmRzOiBbJ3RhZycsIG5hbWVdLFxuICAgICAgcGFyc2VyKCkge1xuICAgICAgICAgcmV0dXJuIHsgbmFtZSB9O1xuICAgICAgfSxcbiAgIH07XG59XG5cbi8qKlxuICogVGFzayB1c2VkIGJ5IGBnaXQuYWRkVGFnYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQW5ub3RhdGVkVGFnVGFzayhcbiAgIG5hbWU6IHN0cmluZyxcbiAgIHRhZ01lc3NhZ2U6IHN0cmluZ1xuKTogU3RyaW5nVGFzazx7IG5hbWU6IHN0cmluZyB9PiB7XG4gICByZXR1cm4ge1xuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgY29tbWFuZHM6IFsndGFnJywgJy1hJywgJy1tJywgdGFnTWVzc2FnZSwgbmFtZV0sXG4gICAgICBwYXJzZXIoKSB7XG4gICAgICAgICByZXR1cm4geyBuYW1lIH07XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJjb25zdCB7IEdpdEV4ZWN1dG9yIH0gPSByZXF1aXJlKCcuL2xpYi9ydW5uZXJzL2dpdC1leGVjdXRvcicpO1xuY29uc3QgeyBTaW1wbGVHaXRBcGkgfSA9IHJlcXVpcmUoJy4vbGliL3NpbXBsZS1naXQtYXBpJyk7XG5cbmNvbnN0IHsgU2NoZWR1bGVyIH0gPSByZXF1aXJlKCcuL2xpYi9ydW5uZXJzL3NjaGVkdWxlcicpO1xuY29uc3QgeyBjb25maWd1cmF0aW9uRXJyb3JUYXNrIH0gPSByZXF1aXJlKCcuL2xpYi90YXNrcy90YXNrJyk7XG5jb25zdCB7XG4gICBhc0FycmF5LFxuICAgZmlsdGVyQXJyYXksXG4gICBmaWx0ZXJQcmltaXRpdmVzLFxuICAgZmlsdGVyU3RyaW5nLFxuICAgZmlsdGVyU3RyaW5nT3JTdHJpbmdBcnJheSxcbiAgIGZpbHRlclR5cGUsXG4gICBnZXRUcmFpbGluZ09wdGlvbnMsXG4gICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQsXG4gICB0cmFpbGluZ09wdGlvbnNBcmd1bWVudCxcbn0gPSByZXF1aXJlKCcuL2xpYi91dGlscycpO1xuY29uc3QgeyBhcHBseVBhdGNoVGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvYXBwbHktcGF0Y2gnKTtcbmNvbnN0IHtcbiAgIGJyYW5jaFRhc2ssXG4gICBicmFuY2hMb2NhbFRhc2ssXG4gICBkZWxldGVCcmFuY2hlc1Rhc2ssXG4gICBkZWxldGVCcmFuY2hUYXNrLFxufSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL2JyYW5jaCcpO1xuY29uc3QgeyBjaGVja0lnbm9yZVRhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL2NoZWNrLWlnbm9yZScpO1xuY29uc3QgeyBjaGVja0lzUmVwb1Rhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL2NoZWNrLWlzLXJlcG8nKTtcbmNvbnN0IHsgY2xvbmVUYXNrLCBjbG9uZU1pcnJvclRhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL2Nsb25lJyk7XG5jb25zdCB7IGNsZWFuV2l0aE9wdGlvbnNUYXNrLCBpc0NsZWFuT3B0aW9uc0FycmF5IH0gPSByZXF1aXJlKCcuL2xpYi90YXNrcy9jbGVhbicpO1xuY29uc3QgeyBkaWZmU3VtbWFyeVRhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL2RpZmYnKTtcbmNvbnN0IHsgZmV0Y2hUYXNrIH0gPSByZXF1aXJlKCcuL2xpYi90YXNrcy9mZXRjaCcpO1xuY29uc3QgeyBtb3ZlVGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvbW92ZScpO1xuY29uc3QgeyBwdWxsVGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvcHVsbCcpO1xuY29uc3QgeyBwdXNoVGFnc1Rhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL3B1c2gnKTtcbmNvbnN0IHtcbiAgIGFkZFJlbW90ZVRhc2ssXG4gICBnZXRSZW1vdGVzVGFzayxcbiAgIGxpc3RSZW1vdGVzVGFzayxcbiAgIHJlbW90ZVRhc2ssXG4gICByZW1vdmVSZW1vdGVUYXNrLFxufSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL3JlbW90ZScpO1xuY29uc3QgeyBnZXRSZXNldE1vZGUsIHJlc2V0VGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvcmVzZXQnKTtcbmNvbnN0IHsgc3Rhc2hMaXN0VGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3Mvc3Rhc2gtbGlzdCcpO1xuY29uc3Qge1xuICAgYWRkU3ViTW9kdWxlVGFzayxcbiAgIGluaXRTdWJNb2R1bGVUYXNrLFxuICAgc3ViTW9kdWxlVGFzayxcbiAgIHVwZGF0ZVN1Yk1vZHVsZVRhc2ssXG59ID0gcmVxdWlyZSgnLi9saWIvdGFza3Mvc3ViLW1vZHVsZScpO1xuY29uc3QgeyBhZGRBbm5vdGF0ZWRUYWdUYXNrLCBhZGRUYWdUYXNrLCB0YWdMaXN0VGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvdGFnJyk7XG5jb25zdCB7IHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2ssIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL3Rhc2snKTtcblxuZnVuY3Rpb24gR2l0KG9wdGlvbnMsIHBsdWdpbnMpIHtcbiAgIHRoaXMuX2V4ZWN1dG9yID0gbmV3IEdpdEV4ZWN1dG9yKFxuICAgICAgb3B0aW9ucy5iaW5hcnksXG4gICAgICBvcHRpb25zLmJhc2VEaXIsXG4gICAgICBuZXcgU2NoZWR1bGVyKG9wdGlvbnMubWF4Q29uY3VycmVudFByb2Nlc3NlcyksXG4gICAgICBwbHVnaW5zXG4gICApO1xuXG4gICB0aGlzLl90cmltbWVkID0gb3B0aW9ucy50cmltbWVkO1xufVxuXG4oR2l0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2ltcGxlR2l0QXBpLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gR2l0O1xuXG4vKipcbiAqIFNldHMgdGhlIHBhdGggdG8gYSBjdXN0b20gZ2l0IGJpbmFyeSwgc2hvdWxkIGVpdGhlciBiZSBgZ2l0YCB3aGVuIHRoZXJlIGlzIGFuIGluc3RhbGxhdGlvbiBvZiBnaXQgYXZhaWxhYmxlIG9uXG4gKiB0aGUgc3lzdGVtIHBhdGgsIG9yIGEgZnVsbHkgcXVhbGlmaWVkIHBhdGggdG8gdGhlIGV4ZWN1dGFibGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbW1hbmRcbiAqIEByZXR1cm5zIHtHaXR9XG4gKi9cbkdpdC5wcm90b3R5cGUuY3VzdG9tQmluYXJ5ID0gZnVuY3Rpb24gKGNvbW1hbmQpIHtcbiAgIHRoaXMuX2V4ZWN1dG9yLmJpbmFyeSA9IGNvbW1hbmQ7XG4gICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZSBmb3IgdGhlIHNwYXduZWQgY2hpbGQgcHJvY2VzcywgZWl0aGVyIHN1cHBseSBib3RoIGEgbmFtZSBhbmQgdmFsdWUgYXMgc3RyaW5ncyBvclxuICogYSBzaW5nbGUgb2JqZWN0IHRvIGVudGlyZWx5IHJlcGxhY2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IFt2YWx1ZV1cbiAqIEByZXR1cm5zIHtHaXR9XG4gKi9cbkdpdC5wcm90b3R5cGUuZW52ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMuX2V4ZWN1dG9yLmVudiA9IG5hbWU7XG4gICB9IGVsc2Uge1xuICAgICAgKHRoaXMuX2V4ZWN1dG9yLmVudiA9IHRoaXMuX2V4ZWN1dG9yLmVudiB8fCB7fSlbbmFtZV0gPSB2YWx1ZTtcbiAgIH1cblxuICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIExpc3QgdGhlIHN0YXNoKHMpIG9mIHRoZSBsb2NhbCByZXBvXG4gKi9cbkdpdC5wcm90b3R5cGUuc3Rhc2hMaXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgc3Rhc2hMaXN0VGFzayhcbiAgICAgICAgIHRyYWlsaW5nT3B0aW9uc0FyZ3VtZW50KGFyZ3VtZW50cykgfHwge30sXG4gICAgICAgICAoZmlsdGVyQXJyYXkob3B0aW9ucykgJiYgb3B0aW9ucykgfHwgW11cbiAgICAgICksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsb25lVGFzayhhcGksIHRhc2ssIHJlcG9QYXRoLCBsb2NhbFBhdGgpIHtcbiAgIGlmICh0eXBlb2YgcmVwb1BhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhgZ2l0LiR7YXBpfSgpIHJlcXVpcmVzIGEgc3RyaW5nICdyZXBvUGF0aCdgKTtcbiAgIH1cblxuICAgcmV0dXJuIHRhc2socmVwb1BhdGgsIGZpbHRlclR5cGUobG9jYWxQYXRoLCBmaWx0ZXJTdHJpbmcpLCBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSk7XG59XG5cbi8qKlxuICogQ2xvbmUgYSBnaXQgcmVwb1xuICovXG5HaXQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBjcmVhdGVDbG9uZVRhc2soJ2Nsb25lJywgY2xvbmVUYXNrLCAuLi5hcmd1bWVudHMpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIE1pcnJvciBhIGdpdCByZXBvXG4gKi9cbkdpdC5wcm90b3R5cGUubWlycm9yID0gZnVuY3Rpb24gKCkge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBjcmVhdGVDbG9uZVRhc2soJ21pcnJvcicsIGNsb25lTWlycm9yVGFzaywgLi4uYXJndW1lbnRzKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBNb3ZlcyBvbmUgb3IgbW9yZSBmaWxlcyB0byBhIG5ldyBkZXN0aW5hdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0LXNjbS5jb20vZG9jcy9naXQtbXZcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZnJvbVxuICogQHBhcmFtIHtzdHJpbmd9IHRvXG4gKi9cbkdpdC5wcm90b3R5cGUubXYgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKG1vdmVUYXNrKGZyb20sIHRvKSwgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cykpO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbGx5IHVzZXMgcHVsbCBhbmQgdGFncyB0byBnZXQgdGhlIGxpc3Qgb2YgdGFncyB0aGVuIGNoZWNrcyBvdXQgdGhlIGxhdGVzdCB0YWcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3RoZW5dXG4gKi9cbkdpdC5wcm90b3R5cGUuY2hlY2tvdXRMYXRlc3RUYWcgPSBmdW5jdGlvbiAodGhlbikge1xuICAgdmFyIGdpdCA9IHRoaXM7XG4gICByZXR1cm4gdGhpcy5wdWxsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGdpdC50YWdzKGZ1bmN0aW9uIChlcnIsIHRhZ3MpIHtcbiAgICAgICAgIGdpdC5jaGVja291dCh0YWdzLmxhdGVzdCwgdGhlbik7XG4gICAgICB9KTtcbiAgIH0pO1xufTtcblxuLyoqXG4gKiBQdWxsIHRoZSB1cGRhdGVkIGNvbnRlbnRzIG9mIHRoZSBjdXJyZW50IHJlcG9cbiAqL1xuR2l0LnByb3RvdHlwZS5wdWxsID0gZnVuY3Rpb24gKHJlbW90ZSwgYnJhbmNoLCBvcHRpb25zLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIHB1bGxUYXNrKFxuICAgICAgICAgZmlsdGVyVHlwZShyZW1vdGUsIGZpbHRlclN0cmluZyksXG4gICAgICAgICBmaWx0ZXJUeXBlKGJyYW5jaCwgZmlsdGVyU3RyaW5nKSxcbiAgICAgICAgIGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXG4gICAgICApLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIEZldGNoIHRoZSB1cGRhdGVkIGNvbnRlbnRzIG9mIHRoZSBjdXJyZW50IHJlcG8uXG4gKlxuICogQGV4YW1wbGVcbiAqICAgLmZldGNoKCd1cHN0cmVhbScsICdtYXN0ZXInKSAvLyBmZXRjaGVzIGZyb20gbWFzdGVyIG9uIHJlbW90ZSBuYW1lZCB1cHN0cmVhbVxuICogICAuZmV0Y2goZnVuY3Rpb24gKCkge30pIC8vIHJ1bnMgZmV0Y2ggYWdhaW5zdCBkZWZhdWx0IHJlbW90ZSBhbmQgYnJhbmNoIGFuZCBjYWxscyBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcmVtb3RlXVxuICogQHBhcmFtIHtzdHJpbmd9IFticmFuY2hdXG4gKi9cbkdpdC5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiAocmVtb3RlLCBicmFuY2gpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgZmV0Y2hUYXNrKFxuICAgICAgICAgZmlsdGVyVHlwZShyZW1vdGUsIGZpbHRlclN0cmluZyksXG4gICAgICAgICBmaWx0ZXJUeXBlKGJyYW5jaCwgZmlsdGVyU3RyaW5nKSxcbiAgICAgICAgIGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXG4gICAgICApLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIERpc2FibGVzL2VuYWJsZXMgdGhlIHVzZSBvZiB0aGUgY29uc29sZSBmb3IgcHJpbnRpbmcgd2FybmluZ3MgYW5kIGVycm9ycywgYnkgZGVmYXVsdCBtZXNzYWdlcyBhcmUgbm90IHNob3duIGluXG4gKiBhIHByb2R1Y3Rpb24gZW52aXJvbm1lbnQuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBzaWxlbmNlXG4gKiBAcmV0dXJucyB7R2l0fVxuICovXG5HaXQucHJvdG90eXBlLnNpbGVudCA9IGZ1bmN0aW9uIChzaWxlbmNlKSB7XG4gICBjb25zb2xlLndhcm4oXG4gICAgICAnc2ltcGxlLWdpdCBkZXByZWNhdGlvbiBub3RpY2U6IGdpdC5zaWxlbnQ6IGxvZ2dpbmcgc2hvdWxkIGJlIGNvbmZpZ3VyZWQgdXNpbmcgdGhlIGBkZWJ1Z2AgbGlicmFyeSAvIGBERUJVR2AgZW52aXJvbm1lbnQgdmFyaWFibGUsIHRoaXMgd2lsbCBiZSBhbiBlcnJvciBpbiB2ZXJzaW9uIDMnXG4gICApO1xuICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIExpc3QgYWxsIHRhZ3MuIFdoZW4gdXNpbmcgZ2l0IDIuNy4wIG9yIGFib3ZlLCBpbmNsdWRlIGFuIG9wdGlvbnMgb2JqZWN0IHdpdGggYFwiLS1zb3J0XCI6IFwicHJvcGVydHktbmFtZVwiYCB0b1xuICogc29ydCB0aGUgdGFncyBieSB0aGF0IHByb3BlcnR5IGluc3RlYWQgb2YgdXNpbmcgdGhlIGRlZmF1bHQgc2VtYW50aWMgdmVyc2lvbmluZyBzb3J0LlxuICpcbiAqIE5vdGUsIHN1cHBseWluZyB0aGlzIG9wdGlvbiB3aGVuIGl0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgeW91ciBHaXQgdmVyc2lvbiB3aWxsIGNhdXNlIHRoZSBvcGVyYXRpb24gdG8gZmFpbC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbdGhlbl1cbiAqL1xuR2l0LnByb3RvdHlwZS50YWdzID0gZnVuY3Rpb24gKG9wdGlvbnMsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgdGFnTGlzdFRhc2soZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cykpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIFJlYmFzZXMgdGhlIGN1cnJlbnQgd29ya2luZyBjb3B5LiBPcHRpb25zIGNhbiBiZSBzdXBwbGllZCBlaXRoZXIgYXMgYW4gYXJyYXkgb2Ygc3RyaW5nIHBhcmFtZXRlcnNcbiAqIHRvIGJlIHNlbnQgdG8gdGhlIGBnaXQgcmViYXNlYCBjb21tYW5kLCBvciBhIHN0YW5kYXJkIG9wdGlvbnMgb2JqZWN0LlxuICovXG5HaXQucHJvdG90eXBlLnJlYmFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbJ3JlYmFzZScsIC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogUmVzZXQgYSByZXBvXG4gKi9cbkdpdC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAobW9kZSkge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICByZXNldFRhc2soZ2V0UmVzZXRNb2RlKG1vZGUpLCBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogUmV2ZXJ0IG9uZSBvciBtb3JlIGNvbW1pdHMgaW4gdGhlIGxvY2FsIHdvcmtpbmcgY29weVxuICovXG5HaXQucHJvdG90eXBlLnJldmVydCA9IGZ1bmN0aW9uIChjb21taXQpIHtcbiAgIGNvbnN0IG5leHQgPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKTtcblxuICAgaWYgKHR5cGVvZiBjb21taXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhjb25maWd1cmF0aW9uRXJyb3JUYXNrKCdDb21taXQgbXVzdCBiZSBhIHN0cmluZycpLCBuZXh0KTtcbiAgIH1cblxuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFsncmV2ZXJ0JywgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgMCwgdHJ1ZSksIGNvbW1pdF0pLFxuICAgICAgbmV4dFxuICAgKTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlnaHR3ZWlnaHQgdGFnIHRvIHRoZSBoZWFkIG9mIHRoZSBjdXJyZW50IGJyYW5jaFxuICovXG5HaXQucHJvdG90eXBlLmFkZFRhZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICBjb25zdCB0YXNrID1cbiAgICAgIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJ1xuICAgICAgICAgPyBhZGRUYWdUYXNrKG5hbWUpXG4gICAgICAgICA6IGNvbmZpZ3VyYXRpb25FcnJvclRhc2soJ0dpdC5hZGRUYWcgcmVxdWlyZXMgYSB0YWcgbmFtZScpO1xuXG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKSk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBhbm5vdGF0ZWQgdGFnIHRvIHRoZSBoZWFkIG9mIHRoZSBjdXJyZW50IGJyYW5jaFxuICovXG5HaXQucHJvdG90eXBlLmFkZEFubm90YXRlZFRhZyA9IGZ1bmN0aW9uICh0YWdOYW1lLCB0YWdNZXNzYWdlKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIGFkZEFubm90YXRlZFRhZ1Rhc2sodGFnTmFtZSwgdGFnTWVzc2FnZSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogRGVsZXRlIGEgbG9jYWwgYnJhbmNoXG4gKi9cbkdpdC5wcm90b3R5cGUuZGVsZXRlTG9jYWxCcmFuY2ggPSBmdW5jdGlvbiAoYnJhbmNoTmFtZSwgZm9yY2VEZWxldGUsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgZGVsZXRlQnJhbmNoVGFzayhicmFuY2hOYW1lLCB0eXBlb2YgZm9yY2VEZWxldGUgPT09ICdib29sZWFuJyA/IGZvcmNlRGVsZXRlIDogZmFsc2UpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIERlbGV0ZSBvbmUgb3IgbW9yZSBsb2NhbCBicmFuY2hlc1xuICovXG5HaXQucHJvdG90eXBlLmRlbGV0ZUxvY2FsQnJhbmNoZXMgPSBmdW5jdGlvbiAoYnJhbmNoTmFtZXMsIGZvcmNlRGVsZXRlLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIGRlbGV0ZUJyYW5jaGVzVGFzayhicmFuY2hOYW1lcywgdHlwZW9mIGZvcmNlRGVsZXRlID09PSAnYm9vbGVhbicgPyBmb3JjZURlbGV0ZSA6IGZhbHNlKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBMaXN0IGFsbCBicmFuY2hlc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0IHwgc3RyaW5nW119IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3RoZW5dXG4gKi9cbkdpdC5wcm90b3R5cGUuYnJhbmNoID0gZnVuY3Rpb24gKG9wdGlvbnMsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgYnJhbmNoVGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGxpc3Qgb2YgbG9jYWwgYnJhbmNoZXNcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbdGhlbl1cbiAqL1xuR2l0LnByb3RvdHlwZS5icmFuY2hMb2NhbCA9IGZ1bmN0aW9uICh0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhicmFuY2hMb2NhbFRhc2soKSwgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cykpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhbnkgY29tbWFuZCBhZ2FpbnN0IHRoZSBnaXQgYmluYXJ5LlxuICovXG5HaXQucHJvdG90eXBlLnJhdyA9IGZ1bmN0aW9uIChjb21tYW5kcykge1xuICAgY29uc3QgY3JlYXRlUmVzdENvbW1hbmRzID0gIUFycmF5LmlzQXJyYXkoY29tbWFuZHMpO1xuICAgY29uc3QgY29tbWFuZCA9IFtdLnNsaWNlLmNhbGwoY3JlYXRlUmVzdENvbW1hbmRzID8gYXJndW1lbnRzIDogY29tbWFuZHMsIDApO1xuXG4gICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1hbmQubGVuZ3RoICYmIGNyZWF0ZVJlc3RDb21tYW5kczsgaSsrKSB7XG4gICAgICBpZiAoIWZpbHRlclByaW1pdGl2ZXMoY29tbWFuZFtpXSkpIHtcbiAgICAgICAgIGNvbW1hbmQuc3BsaWNlKGksIGNvbW1hbmQubGVuZ3RoIC0gaSk7XG4gICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgIH1cblxuICAgY29tbWFuZC5wdXNoKC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMsIDAsIHRydWUpKTtcblxuICAgdmFyIG5leHQgPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKTtcblxuICAgaWYgKCFjb21tYW5kLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICBjb25maWd1cmF0aW9uRXJyb3JUYXNrKCdSYXc6IG11c3Qgc3VwcGx5IG9uZSBvciBtb3JlIGNvbW1hbmQgdG8gZXhlY3V0ZScpLFxuICAgICAgICAgbmV4dFxuICAgICAgKTtcbiAgIH1cblxuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kLCB0aGlzLl90cmltbWVkKSwgbmV4dCk7XG59O1xuXG5HaXQucHJvdG90eXBlLnN1Ym1vZHVsZUFkZCA9IGZ1bmN0aW9uIChyZXBvLCBwYXRoLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhhZGRTdWJNb2R1bGVUYXNrKHJlcG8sIHBhdGgpLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKSk7XG59O1xuXG5HaXQucHJvdG90eXBlLnN1Ym1vZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uIChhcmdzLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIHVwZGF0ZVN1Yk1vZHVsZVRhc2soZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgdHJ1ZSkpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG5HaXQucHJvdG90eXBlLnN1Ym1vZHVsZUluaXQgPSBmdW5jdGlvbiAoYXJncywgdGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBpbml0U3ViTW9kdWxlVGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzLCB0cnVlKSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbkdpdC5wcm90b3R5cGUuc3ViTW9kdWxlID0gZnVuY3Rpb24gKG9wdGlvbnMsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgc3ViTW9kdWxlVGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbkdpdC5wcm90b3R5cGUubGlzdFJlbW90ZSA9IGZ1bmN0aW9uICgpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgbGlzdFJlbW90ZXNUYXNrKGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgcmVtb3RlIHRvIHRoZSBsaXN0IG9mIHJlbW90ZXMuXG4gKi9cbkdpdC5wcm90b3R5cGUuYWRkUmVtb3RlID0gZnVuY3Rpb24gKHJlbW90ZU5hbWUsIHJlbW90ZVJlcG8sIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgYWRkUmVtb3RlVGFzayhyZW1vdGVOYW1lLCByZW1vdGVSZXBvLCBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBlbnRyeSBieSBuYW1lIGZyb20gdGhlIGxpc3Qgb2YgcmVtb3Rlcy5cbiAqL1xuR2l0LnByb3RvdHlwZS5yZW1vdmVSZW1vdGUgPSBmdW5jdGlvbiAocmVtb3RlTmFtZSwgdGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2socmVtb3ZlUmVtb3RlVGFzayhyZW1vdGVOYW1lKSwgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cykpO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBjdXJyZW50bHkgYXZhaWxhYmxlIHJlbW90ZXMsIHNldHRpbmcgdGhlIG9wdGlvbmFsIHZlcmJvc2UgYXJndW1lbnQgdG8gdHJ1ZSBpbmNsdWRlcyBhZGRpdGlvbmFsXG4gKiBkZXRhaWwgb24gdGhlIHJlbW90ZXMgdGhlbXNlbHZlcy5cbiAqL1xuR2l0LnByb3RvdHlwZS5nZXRSZW1vdGVzID0gZnVuY3Rpb24gKHZlcmJvc2UsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKGdldFJlbW90ZXNUYXNrKHZlcmJvc2UgPT09IHRydWUpLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKSk7XG59O1xuXG4vKipcbiAqIENhbGwgYW55IGBnaXQgcmVtb3RlYCBmdW5jdGlvbiB3aXRoIGFyZ3VtZW50cyBwYXNzZWQgYXMgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbdGhlbl1cbiAqL1xuR2l0LnByb3RvdHlwZS5yZW1vdGUgPSBmdW5jdGlvbiAob3B0aW9ucywgdGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICByZW1vdGVUYXNrKGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBDYWxsIGFueSBgZ2l0IHRhZ2AgZnVuY3Rpb24gd2l0aCBhcmd1bWVudHMgcGFzc2VkIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW3RoZW5dXG4gKi9cbkdpdC5wcm90b3R5cGUudGFnID0gZnVuY3Rpb24gKG9wdGlvbnMsIHRoZW4pIHtcbiAgIGNvbnN0IGNvbW1hbmQgPSBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKTtcblxuICAgaWYgKGNvbW1hbmRbMF0gIT09ICd0YWcnKSB7XG4gICAgICBjb21tYW5kLnVuc2hpZnQoJ3RhZycpO1xuICAgfVxuXG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmQpLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKSk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgcmVwb3NpdG9yeSBzZXJ2ZXIgaW5mb1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFt0aGVuXVxuICovXG5HaXQucHJvdG90eXBlLnVwZGF0ZVNlcnZlckluZm8gPSBmdW5jdGlvbiAodGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFsndXBkYXRlLXNlcnZlci1pbmZvJ10pLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIFB1c2hlcyB0aGUgY3VycmVudCB0YWcgY2hhbmdlcyB0byBhIHJlbW90ZSB3aGljaCBjYW4gYmUgZWl0aGVyIGEgVVJMIG9yIG5hbWVkIHJlbW90ZS4gV2hlbiBub3Qgc3BlY2lmaWVkIHVzZXMgdGhlXG4gKiBkZWZhdWx0IGNvbmZpZ3VyZWQgcmVtb3RlIHNwZWMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtyZW1vdGVdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbdGhlbl1cbiAqL1xuR2l0LnByb3RvdHlwZS5wdXNoVGFncyA9IGZ1bmN0aW9uIChyZW1vdGUsIHRoZW4pIHtcbiAgIGNvbnN0IHRhc2sgPSBwdXNoVGFnc1Rhc2soXG4gICAgICB7IHJlbW90ZTogZmlsdGVyVHlwZShyZW1vdGUsIGZpbHRlclN0cmluZykgfSxcbiAgICAgIGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXG4gICApO1xuXG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIG5hbWVkIGZpbGVzIGZyb20gc291cmNlIGNvbnRyb2wuXG4gKi9cbkdpdC5wcm90b3R5cGUucm0gPSBmdW5jdGlvbiAoZmlsZXMpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbJ3JtJywgJy1mJywgLi4uYXNBcnJheShmaWxlcyldKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBuYW1lZCBmaWxlcyBmcm9tIHNvdXJjZSBjb250cm9sIGJ1dCBrZWVwcyB0aGVtIG9uIGRpc2sgcmF0aGVyIHRoYW4gZGVsZXRpbmcgdGhlbSBlbnRpcmVseS4gVG9cbiAqIGNvbXBsZXRlbHkgcmVtb3ZlIHRoZSBmaWxlcywgdXNlIGBybWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVzXG4gKi9cbkdpdC5wcm90b3R5cGUucm1LZWVwTG9jYWwgPSBmdW5jdGlvbiAoZmlsZXMpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbJ3JtJywgJy0tY2FjaGVkJywgLi4uYXNBcnJheShmaWxlcyldKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBvYmplY3RzIGluIGEgdHJlZSBiYXNlZCBvbiBjb21taXQgaGFzaC4gUGFzc2luZyBpbiBhbiBvYmplY3QgaGFzaCByZXR1cm5zIHRoZSBvYmplY3QncyBjb250ZW50LFxuICogc2l6ZSwgYW5kIHR5cGUuXG4gKlxuICogUGFzc2luZyBcIi1wXCIgd2lsbCBpbnN0cnVjdCBjYXQtZmlsZSB0byBkZXRlcm1pbmUgdGhlIG9iamVjdCB0eXBlLCBhbmQgZGlzcGxheSBpdHMgZm9ybWF0dGVkIGNvbnRlbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nW119IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3RoZW5dXG4gKi9cbkdpdC5wcm90b3R5cGUuY2F0RmlsZSA9IGZ1bmN0aW9uIChvcHRpb25zLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fY2F0RmlsZSgndXRmLTgnLCBhcmd1bWVudHMpO1xufTtcblxuR2l0LnByb3RvdHlwZS5iaW5hcnlDYXRGaWxlID0gZnVuY3Rpb24gKCkge1xuICAgcmV0dXJuIHRoaXMuX2NhdEZpbGUoJ2J1ZmZlcicsIGFyZ3VtZW50cyk7XG59O1xuXG5HaXQucHJvdG90eXBlLl9jYXRGaWxlID0gZnVuY3Rpb24gKGZvcm1hdCwgYXJncykge1xuICAgdmFyIGhhbmRsZXIgPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJncyk7XG4gICB2YXIgY29tbWFuZCA9IFsnY2F0LWZpbGUnXTtcbiAgIHZhciBvcHRpb25zID0gYXJnc1swXTtcblxuICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICBjb25maWd1cmF0aW9uRXJyb3JUYXNrKCdHaXQuY2F0RmlsZTogb3B0aW9ucyBtdXN0IGJlIHN1cHBsaWVkIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MnKSxcbiAgICAgICAgIGhhbmRsZXJcbiAgICAgICk7XG4gICB9XG5cbiAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICBjb21tYW5kLnB1c2guYXBwbHkoY29tbWFuZCwgb3B0aW9ucyk7XG4gICB9XG5cbiAgIGNvbnN0IHRhc2sgPVxuICAgICAgZm9ybWF0ID09PSAnYnVmZmVyJyA/IHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2soY29tbWFuZCkgOiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmQpO1xuXG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCBoYW5kbGVyKTtcbn07XG5cbkdpdC5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uIChvcHRpb25zLCB0aGVuKSB7XG4gICBjb25zdCB0YXNrID0gZmlsdGVyU3RyaW5nKG9wdGlvbnMpXG4gICAgICA/IGNvbmZpZ3VyYXRpb25FcnJvclRhc2soXG4gICAgICAgICAgICdnaXQuZGlmZjogc3VwcGx5aW5nIG9wdGlvbnMgYXMgYSBzaW5nbGUgc3RyaW5nIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQsIHN3aXRjaCB0byBhbiBhcnJheSBvZiBzdHJpbmdzJ1xuICAgICAgICApXG4gICAgICA6IHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soWydkaWZmJywgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cyldKTtcblxuICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cykpO1xufTtcblxuR2l0LnByb3RvdHlwZS5kaWZmU3VtbWFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgZGlmZlN1bW1hcnlUYXNrKGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMsIDEpKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuR2l0LnByb3RvdHlwZS5hcHBseVBhdGNoID0gZnVuY3Rpb24gKHBhdGNoZXMpIHtcbiAgIGNvbnN0IHRhc2sgPSAhZmlsdGVyU3RyaW5nT3JTdHJpbmdBcnJheShwYXRjaGVzKVxuICAgICAgPyBjb25maWd1cmF0aW9uRXJyb3JUYXNrKFxuICAgICAgICAgICBgZ2l0LmFwcGx5UGF0Y2ggcmVxdWlyZXMgb25lIG9yIG1vcmUgc3RyaW5nIHBhdGNoZXMgYXMgdGhlIGZpcnN0IGFyZ3VtZW50YFxuICAgICAgICApXG4gICAgICA6IGFwcGx5UGF0Y2hUYXNrKGFzQXJyYXkocGF0Y2hlcyksIGdldFRyYWlsaW5nT3B0aW9ucyhbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKTtcblxuICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cykpO1xufTtcblxuR2l0LnByb3RvdHlwZS5yZXZwYXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgIGNvbnN0IGNvbW1hbmRzID0gWydyZXYtcGFyc2UnLCAuLi5nZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzLCB0cnVlKV07XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMsIHRydWUpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqL1xuR2l0LnByb3RvdHlwZS5jbGVhbiA9IGZ1bmN0aW9uIChtb2RlLCBvcHRpb25zLCB0aGVuKSB7XG4gICBjb25zdCB1c2luZ0NsZWFuT3B0aW9uc0FycmF5ID0gaXNDbGVhbk9wdGlvbnNBcnJheShtb2RlKTtcbiAgIGNvbnN0IGNsZWFuTW9kZSA9XG4gICAgICAodXNpbmdDbGVhbk9wdGlvbnNBcnJheSAmJiBtb2RlLmpvaW4oJycpKSB8fCBmaWx0ZXJUeXBlKG1vZGUsIGZpbHRlclN0cmluZykgfHwgJyc7XG4gICBjb25zdCBjdXN0b21BcmdzID0gZ2V0VHJhaWxpbmdPcHRpb25zKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCB1c2luZ0NsZWFuT3B0aW9uc0FycmF5ID8gMSA6IDApKTtcblxuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBjbGVhbldpdGhPcHRpb25zVGFzayhjbGVhbk1vZGUsIGN1c3RvbUFyZ3MpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG5HaXQucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbiAodGhlbikge1xuICAgY29uc3QgdGFzayA9IHtcbiAgICAgIGNvbW1hbmRzOiBbXSxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcigpIHtcbiAgICAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhlbigpO1xuICAgICAgICAgfVxuICAgICAgfSxcbiAgIH07XG5cbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHRhc2spO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIHF1ZXVlIG9mIHBlbmRpbmcgY29tbWFuZHMgYW5kIHJldHVybnMgdGhlIHdyYXBwZXIgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICpcbiAqIEByZXR1cm5zIHtHaXR9XG4gKi9cbkdpdC5wcm90b3R5cGUuY2xlYXJRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgIC8vIFRPRE86XG4gICAvLyB0aGlzLl9leGVjdXRvci5jbGVhcigpO1xuICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgcGF0aG5hbWUgb3IgcGF0aG5hbWVzIGFyZSBleGNsdWRlZCBieSAuZ2l0aWdub3JlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGhuYW1lc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW3RoZW5dXG4gKi9cbkdpdC5wcm90b3R5cGUuY2hlY2tJZ25vcmUgPSBmdW5jdGlvbiAocGF0aG5hbWVzLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIGNoZWNrSWdub3JlVGFzayhhc0FycmF5KGZpbHRlclR5cGUocGF0aG5hbWVzLCBmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5LCBbXSkpKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuR2l0LnByb3RvdHlwZS5jaGVja0lzUmVwbyA9IGZ1bmN0aW9uIChjaGVja1R5cGUsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgY2hlY2tJc1JlcG9UYXNrKGZpbHRlclR5cGUoY2hlY2tUeXBlLCBmaWx0ZXJTdHJpbmcpKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHaXQ7XG4iLCAiaW1wb3J0IHsgcGF0aHNwZWMgfSBmcm9tICcuL2FyZ3MvcGF0aHNwZWMnO1xuaW1wb3J0IHsgR2l0Q29uc3RydWN0RXJyb3IgfSBmcm9tICcuL2Vycm9ycy9naXQtY29uc3RydWN0LWVycm9yJztcbmltcG9ydCB7IEdpdEVycm9yIH0gZnJvbSAnLi9lcnJvcnMvZ2l0LWVycm9yJztcbmltcG9ydCB7IEdpdFBsdWdpbkVycm9yIH0gZnJvbSAnLi9lcnJvcnMvZ2l0LXBsdWdpbi1lcnJvcic7XG5pbXBvcnQgeyBHaXRSZXNwb25zZUVycm9yIH0gZnJvbSAnLi9lcnJvcnMvZ2l0LXJlc3BvbnNlLWVycm9yJztcbmltcG9ydCB7IFRhc2tDb25maWd1cmF0aW9uRXJyb3IgfSBmcm9tICcuL2Vycm9ycy90YXNrLWNvbmZpZ3VyYXRpb24tZXJyb3InO1xuaW1wb3J0IHsgQ2hlY2tSZXBvQWN0aW9ucyB9IGZyb20gJy4vdGFza3MvY2hlY2staXMtcmVwbyc7XG5pbXBvcnQgeyBDbGVhbk9wdGlvbnMgfSBmcm9tICcuL3Rhc2tzL2NsZWFuJztcbmltcG9ydCB7IEdpdENvbmZpZ1Njb3BlIH0gZnJvbSAnLi90YXNrcy9jb25maWcnO1xuaW1wb3J0IHsgRGlmZk5hbWVTdGF0dXMgfSBmcm9tICcuL3Rhc2tzL2RpZmYtbmFtZS1zdGF0dXMnO1xuaW1wb3J0IHsgZ3JlcFF1ZXJ5QnVpbGRlciB9IGZyb20gJy4vdGFza3MvZ3JlcCc7XG5pbXBvcnQgeyBSZXNldE1vZGUgfSBmcm9tICcuL3Rhc2tzL3Jlc2V0JztcblxuZXhwb3J0IHtcbiAgIENoZWNrUmVwb0FjdGlvbnMsXG4gICBDbGVhbk9wdGlvbnMsXG4gICBEaWZmTmFtZVN0YXR1cyxcbiAgIEdpdENvbmZpZ1Njb3BlLFxuICAgR2l0Q29uc3RydWN0RXJyb3IsXG4gICBHaXRFcnJvcixcbiAgIEdpdFBsdWdpbkVycm9yLFxuICAgR2l0UmVzcG9uc2VFcnJvcixcbiAgIFJlc2V0TW9kZSxcbiAgIFRhc2tDb25maWd1cmF0aW9uRXJyb3IsXG4gICBncmVwUXVlcnlCdWlsZGVyLFxuICAgcGF0aHNwZWMsXG59O1xuIiwgImltcG9ydCB7IEdpdEVycm9yIH0gZnJvbSAnLi9naXQtZXJyb3InO1xuaW1wb3J0IHsgU2ltcGxlR2l0T3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcblxuLyoqXG4gKiBUaGUgYEdpdENvbnN0cnVjdEVycm9yYCBpcyB0aHJvd24gd2hlbiBhbiBlcnJvciBvY2N1cnMgaW4gdGhlIGNvbnN0cnVjdG9yXG4gKiBvZiB0aGUgYHNpbXBsZS1naXRgIGluc3RhbmNlIGl0c2VsZi4gTW9zdCBjb21tb25seSBhcyBhIHJlc3VsdCBvZiB1c2luZ1xuICogYSBgYmFzZURpcmAgb3B0aW9uIHRoYXQgcG9pbnRzIHRvIGEgZm9sZGVyIHRoYXQgZWl0aGVyIGRvZXMgbm90IGV4aXN0LFxuICogb3IgY2Fubm90IGJlIHJlYWQgYnkgdGhlIHVzZXIgdGhlIG5vZGUgc2NyaXB0IGlzIHJ1bm5pbmcgYXMuXG4gKlxuICogQ2hlY2sgdGhlIGAubWVzc2FnZWAgcHJvcGVydHkgZm9yIG1vcmUgZGV0YWlsIGluY2x1ZGluZyB0aGUgcHJvcGVydGllc1xuICogcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAqL1xuZXhwb3J0IGNsYXNzIEdpdENvbnN0cnVjdEVycm9yIGV4dGVuZHMgR2l0RXJyb3Ige1xuICAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgY29uZmlnOiBTaW1wbGVHaXRPcHRpb25zLFxuICAgICAgbWVzc2FnZTogc3RyaW5nXG4gICApIHtcbiAgICAgIHN1cGVyKHVuZGVmaW5lZCwgbWVzc2FnZSk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgU2ltcGxlR2l0T3B0aW9ucywgU2ltcGxlR2l0VGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEdpdEVycm9yIH0gZnJvbSAnLi9naXQtZXJyb3InO1xuXG5leHBvcnQgY2xhc3MgR2l0UGx1Z2luRXJyb3IgZXh0ZW5kcyBHaXRFcnJvciB7XG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyB0YXNrPzogU2ltcGxlR2l0VGFzazxhbnk+LFxuICAgICAgcHVibGljIHJlYWRvbmx5IHBsdWdpbj86IGtleW9mIFNpbXBsZUdpdE9wdGlvbnMsXG4gICAgICBtZXNzYWdlPzogc3RyaW5nXG4gICApIHtcbiAgICAgIHN1cGVyKHRhc2ssIG1lc3NhZ2UpO1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBTaW1wbGVHaXRPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgU2ltcGxlR2l0UGx1Z2luIH0gZnJvbSAnLi9zaW1wbGUtZ2l0LXBsdWdpbic7XG5pbXBvcnQgeyBHaXRQbHVnaW5FcnJvciB9IGZyb20gJy4uL2Vycm9ycy9naXQtcGx1Z2luLWVycm9yJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFib3J0UGx1Z2luKHNpZ25hbDogU2ltcGxlR2l0T3B0aW9uc1snYWJvcnQnXSkge1xuICAgaWYgKCFzaWduYWwpIHtcbiAgICAgIHJldHVybjtcbiAgIH1cblxuICAgY29uc3Qgb25TcGF3bkFmdGVyOiBTaW1wbGVHaXRQbHVnaW48J3NwYXduLmFmdGVyJz4gPSB7XG4gICAgICB0eXBlOiAnc3Bhd24uYWZ0ZXInLFxuICAgICAgYWN0aW9uKF9kYXRhLCBjb250ZXh0KSB7XG4gICAgICAgICBmdW5jdGlvbiBraWxsKCkge1xuICAgICAgICAgICAgY29udGV4dC5raWxsKG5ldyBHaXRQbHVnaW5FcnJvcih1bmRlZmluZWQsICdhYm9ydCcsICdBYm9ydCBzaWduYWwgcmVjZWl2ZWQnKSk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGtpbGwpO1xuXG4gICAgICAgICBjb250ZXh0LnNwYXduZWQub24oJ2Nsb3NlJywgKCkgPT4gc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywga2lsbCkpO1xuICAgICAgfSxcbiAgIH07XG5cbiAgIGNvbnN0IG9uU3Bhd25CZWZvcmU6IFNpbXBsZUdpdFBsdWdpbjwnc3Bhd24uYmVmb3JlJz4gPSB7XG4gICAgICB0eXBlOiAnc3Bhd24uYmVmb3JlJyxcbiAgICAgIGFjdGlvbihfZGF0YSwgY29udGV4dCkge1xuICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICBjb250ZXh0LmtpbGwobmV3IEdpdFBsdWdpbkVycm9yKHVuZGVmaW5lZCwgJ2Fib3J0JywgJ0Fib3J0IGFscmVhZHkgc2lnbmFsZWQnKSk7XG4gICAgICAgICB9XG4gICAgICB9LFxuICAgfTtcblxuICAgcmV0dXJuIFtvblNwYXduQmVmb3JlLCBvblNwYXduQWZ0ZXJdO1xufVxuIiwgImltcG9ydCB0eXBlIHsgU2ltcGxlR2l0UGx1Z2luIH0gZnJvbSAnLi9zaW1wbGUtZ2l0LXBsdWdpbic7XG5cbmltcG9ydCB7IEdpdFBsdWdpbkVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2dpdC1wbHVnaW4tZXJyb3InO1xuaW1wb3J0IHR5cGUgeyBTaW1wbGVHaXRQbHVnaW5Db25maWcgfSBmcm9tICcuLi90eXBlcyc7XG5cbmZ1bmN0aW9uIGlzQ29uZmlnU3dpdGNoKGFyZzogc3RyaW5nIHwgdW5rbm93bikge1xuICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnICYmIGFyZy50cmltKCkudG9Mb3dlckNhc2UoKSA9PT0gJy1jJztcbn1cblxuZnVuY3Rpb24gcHJldmVudFByb3RvY29sT3ZlcnJpZGUoYXJnOiBzdHJpbmcsIG5leHQ6IHN0cmluZykge1xuICAgaWYgKCFpc0NvbmZpZ1N3aXRjaChhcmcpKSB7XG4gICAgICByZXR1cm47XG4gICB9XG5cbiAgIGlmICghL15cXHMqcHJvdG9jb2woLlthLXpdKyk/LmFsbG93Ly50ZXN0KG5leHQpKSB7XG4gICAgICByZXR1cm47XG4gICB9XG5cbiAgIHRocm93IG5ldyBHaXRQbHVnaW5FcnJvcihcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgICd1bnNhZmUnLFxuICAgICAgJ0NvbmZpZ3VyaW5nIHByb3RvY29sLmFsbG93IGlzIG5vdCBwZXJtaXR0ZWQgd2l0aG91dCBlbmFibGluZyBhbGxvd1Vuc2FmZUV4dFByb3RvY29sJ1xuICAgKTtcbn1cblxuZnVuY3Rpb24gcHJldmVudFVwbG9hZFBhY2soYXJnOiBzdHJpbmcsIG1ldGhvZDogc3RyaW5nKSB7XG4gICBpZiAoL15cXHMqLS0odXBsb2FkfHJlY2VpdmUpLXBhY2svLnRlc3QoYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IEdpdFBsdWdpbkVycm9yKFxuICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgJ3Vuc2FmZScsXG4gICAgICAgICBgVXNlIG9mIC0tdXBsb2FkLXBhY2sgb3IgLS1yZWNlaXZlLXBhY2sgaXMgbm90IHBlcm1pdHRlZCB3aXRob3V0IGVuYWJsaW5nIGFsbG93VW5zYWZlUGFja2BcbiAgICAgICk7XG4gICB9XG5cbiAgIGlmIChtZXRob2QgPT09ICdjbG9uZScgJiYgL15cXHMqLXVcXGIvLnRlc3QoYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IEdpdFBsdWdpbkVycm9yKFxuICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgJ3Vuc2FmZScsXG4gICAgICAgICBgVXNlIG9mIGNsb25lIHdpdGggb3B0aW9uIC11IGlzIG5vdCBwZXJtaXR0ZWQgd2l0aG91dCBlbmFibGluZyBhbGxvd1Vuc2FmZVBhY2tgXG4gICAgICApO1xuICAgfVxuXG4gICBpZiAobWV0aG9kID09PSAncHVzaCcgJiYgL15cXHMqLS1leGVjXFxiLy50ZXN0KGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBHaXRQbHVnaW5FcnJvcihcbiAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICd1bnNhZmUnLFxuICAgICAgICAgYFVzZSBvZiBwdXNoIHdpdGggb3B0aW9uIC0tZXhlYyBpcyBub3QgcGVybWl0dGVkIHdpdGhvdXQgZW5hYmxpbmcgYWxsb3dVbnNhZmVQYWNrYFxuICAgICAgKTtcbiAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJsb2NrVW5zYWZlT3BlcmF0aW9uc1BsdWdpbih7XG4gICBhbGxvd1Vuc2FmZVByb3RvY29sT3ZlcnJpZGUgPSBmYWxzZSxcbiAgIGFsbG93VW5zYWZlUGFjayA9IGZhbHNlLFxufTogU2ltcGxlR2l0UGx1Z2luQ29uZmlnWyd1bnNhZmUnXSA9IHt9KTogU2ltcGxlR2l0UGx1Z2luPCdzcGF3bi5hcmdzJz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdzcGF3bi5hcmdzJyxcbiAgICAgIGFjdGlvbihhcmdzLCBjb250ZXh0KSB7XG4gICAgICAgICBhcmdzLmZvckVhY2goKGN1cnJlbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gaW5kZXggPCBhcmdzLmxlbmd0aCA/IGFyZ3NbaW5kZXggKyAxXSA6ICcnO1xuXG4gICAgICAgICAgICBhbGxvd1Vuc2FmZVByb3RvY29sT3ZlcnJpZGUgfHwgcHJldmVudFByb3RvY29sT3ZlcnJpZGUoY3VycmVudCwgbmV4dCk7XG4gICAgICAgICAgICBhbGxvd1Vuc2FmZVBhY2sgfHwgcHJldmVudFVwbG9hZFBhY2soY3VycmVudCwgY29udGV4dC5tZXRob2QpO1xuICAgICAgICAgfSk7XG5cbiAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgcHJlZml4ZWRBcnJheSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IFNpbXBsZUdpdFBsdWdpbiB9IGZyb20gJy4vc2ltcGxlLWdpdC1wbHVnaW4nO1xuXG5leHBvcnQgZnVuY3Rpb24gY29tbWFuZENvbmZpZ1ByZWZpeGluZ1BsdWdpbihcbiAgIGNvbmZpZ3VyYXRpb246IHN0cmluZ1tdXG4pOiBTaW1wbGVHaXRQbHVnaW48J3NwYXduLmFyZ3MnPiB7XG4gICBjb25zdCBwcmVmaXggPSBwcmVmaXhlZEFycmF5KGNvbmZpZ3VyYXRpb24sICctYycpO1xuXG4gICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3NwYXduLmFyZ3MnLFxuICAgICAgYWN0aW9uKGRhdGEpIHtcbiAgICAgICAgIHJldHVybiBbLi4ucHJlZml4LCAuLi5kYXRhXTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImltcG9ydCB7IGRlZmVycmVkLCBEZWZlcnJlZFByb21pc2UgfSBmcm9tICdAa3dzaXRlcy9wcm9taXNlLWRlZmVycmVkJztcbmltcG9ydCB7IFNpbXBsZUdpdFBsdWdpbkNvbmZpZyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGRlbGF5IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgU2ltcGxlR2l0UGx1Z2luIH0gZnJvbSAnLi9zaW1wbGUtZ2l0LXBsdWdpbic7XG5cbmNvbnN0IG5ldmVyID0gZGVmZXJyZWQoKS5wcm9taXNlO1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcGxldGlvbkRldGVjdGlvblBsdWdpbih7XG4gICBvbkNsb3NlID0gdHJ1ZSxcbiAgIG9uRXhpdCA9IDUwLFxufTogU2ltcGxlR2l0UGx1Z2luQ29uZmlnWydjb21wbGV0aW9uJ10gPSB7fSk6IFNpbXBsZUdpdFBsdWdpbjwnc3Bhd24uYWZ0ZXInPiB7XG4gICBmdW5jdGlvbiBjcmVhdGVFdmVudHMoKSB7XG4gICAgICBsZXQgZXhpdENvZGUgPSAtMTtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IHtcbiAgICAgICAgIGNsb3NlOiBkZWZlcnJlZCgpLFxuICAgICAgICAgY2xvc2VUaW1lb3V0OiBkZWZlcnJlZCgpLFxuICAgICAgICAgZXhpdDogZGVmZXJyZWQoKSxcbiAgICAgICAgIGV4aXRUaW1lb3V0OiBkZWZlcnJlZCgpLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgIG9uQ2xvc2UgPT09IGZhbHNlID8gbmV2ZXIgOiBldmVudHMuY2xvc2VUaW1lb3V0LnByb21pc2UsXG4gICAgICAgICBvbkV4aXQgPT09IGZhbHNlID8gbmV2ZXIgOiBldmVudHMuZXhpdFRpbWVvdXQucHJvbWlzZSxcbiAgICAgIF0pO1xuXG4gICAgICBjb25maWd1cmVUaW1lb3V0KG9uQ2xvc2UsIGV2ZW50cy5jbG9zZSwgZXZlbnRzLmNsb3NlVGltZW91dCk7XG4gICAgICBjb25maWd1cmVUaW1lb3V0KG9uRXhpdCwgZXZlbnRzLmV4aXQsIGV2ZW50cy5leGl0VGltZW91dCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICBjbG9zZShjb2RlOiBudW1iZXIpIHtcbiAgICAgICAgICAgIGV4aXRDb2RlID0gY29kZTtcbiAgICAgICAgICAgIGV2ZW50cy5jbG9zZS5kb25lKCk7XG4gICAgICAgICB9LFxuICAgICAgICAgZXhpdChjb2RlOiBudW1iZXIpIHtcbiAgICAgICAgICAgIGV4aXRDb2RlID0gY29kZTtcbiAgICAgICAgICAgIGV2ZW50cy5leGl0LmRvbmUoKTtcbiAgICAgICAgIH0sXG4gICAgICAgICBnZXQgZXhpdENvZGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpdENvZGU7XG4gICAgICAgICB9LFxuICAgICAgICAgcmVzdWx0LFxuICAgICAgfTtcbiAgIH1cblxuICAgZnVuY3Rpb24gY29uZmlndXJlVGltZW91dChcbiAgICAgIGZsYWc6IGJvb2xlYW4gfCBudW1iZXIsXG4gICAgICBldmVudDogRGVmZXJyZWRQcm9taXNlPHZvaWQ+LFxuICAgICAgdGltZW91dDogRGVmZXJyZWRQcm9taXNlPHZvaWQ+XG4gICApIHtcbiAgICAgIGlmIChmbGFnID09PSBmYWxzZSkge1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAoZmxhZyA9PT0gdHJ1ZSA/IGV2ZW50LnByb21pc2UgOiBldmVudC5wcm9taXNlLnRoZW4oKCkgPT4gZGVsYXkoZmxhZykpKS50aGVuKHRpbWVvdXQuZG9uZSk7XG4gICB9XG5cbiAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnc3Bhd24uYWZ0ZXInLFxuICAgICAgYXN5bmMgYWN0aW9uKF9kYXRhLCB7IHNwYXduZWQsIGNsb3NlIH0pIHtcbiAgICAgICAgIGNvbnN0IGV2ZW50cyA9IGNyZWF0ZUV2ZW50cygpO1xuXG4gICAgICAgICBsZXQgZGVmZXJDbG9zZSA9IHRydWU7XG4gICAgICAgICBsZXQgcXVpY2tDbG9zZSA9ICgpID0+IHZvaWQgKGRlZmVyQ2xvc2UgPSBmYWxzZSk7XG5cbiAgICAgICAgIHNwYXduZWQuc3Rkb3V0Py5vbignZGF0YScsIHF1aWNrQ2xvc2UpO1xuICAgICAgICAgc3Bhd25lZC5zdGRlcnI/Lm9uKCdkYXRhJywgcXVpY2tDbG9zZSk7XG4gICAgICAgICBzcGF3bmVkLm9uKCdlcnJvcicsIHF1aWNrQ2xvc2UpO1xuXG4gICAgICAgICBzcGF3bmVkLm9uKCdjbG9zZScsIChjb2RlOiBudW1iZXIpID0+IGV2ZW50cy5jbG9zZShjb2RlKSk7XG4gICAgICAgICBzcGF3bmVkLm9uKCdleGl0JywgKGNvZGU6IG51bWJlcikgPT4gZXZlbnRzLmV4aXQoY29kZSkpO1xuXG4gICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZXZlbnRzLnJlc3VsdDtcbiAgICAgICAgICAgIGlmIChkZWZlckNsb3NlKSB7XG4gICAgICAgICAgICAgICBhd2FpdCBkZWxheSg1MCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbG9zZShldmVudHMuZXhpdENvZGUpO1xuICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjbG9zZShldmVudHMuZXhpdENvZGUsIGVyciBhcyBFcnJvcik7XG4gICAgICAgICB9XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJpbXBvcnQgeyBHaXRFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9naXQtZXJyb3InO1xuaW1wb3J0IHsgR2l0RXhlY3V0b3JSZXN1bHQsIFNpbXBsZUdpdFBsdWdpbkNvbmZpZyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IFNpbXBsZUdpdFBsdWdpbiB9IGZyb20gJy4vc2ltcGxlLWdpdC1wbHVnaW4nO1xuXG50eXBlIFRhc2tSZXN1bHQgPSBPbWl0PEdpdEV4ZWN1dG9yUmVzdWx0LCAncmVqZWN0aW9uJz47XG5cbmZ1bmN0aW9uIGlzVGFza0Vycm9yKHJlc3VsdDogVGFza1Jlc3VsdCkge1xuICAgcmV0dXJuICEhKHJlc3VsdC5leGl0Q29kZSAmJiByZXN1bHQuc3RkRXJyLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShyZXN1bHQ6IFRhc2tSZXN1bHQpIHtcbiAgIHJldHVybiBCdWZmZXIuY29uY2F0KFsuLi5yZXN1bHQuc3RkT3V0LCAuLi5yZXN1bHQuc3RkRXJyXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcnJvckRldGVjdGlvbkhhbmRsZXIoXG4gICBvdmVyd3JpdGUgPSBmYWxzZSxcbiAgIGlzRXJyb3IgPSBpc1Rhc2tFcnJvcixcbiAgIGVycm9yTWVzc2FnZTogKHJlc3VsdDogVGFza1Jlc3VsdCkgPT4gQnVmZmVyIHwgRXJyb3IgPSBnZXRFcnJvck1lc3NhZ2Vcbikge1xuICAgcmV0dXJuIChlcnJvcjogQnVmZmVyIHwgRXJyb3IgfCB1bmRlZmluZWQsIHJlc3VsdDogVGFza1Jlc3VsdCkgPT4ge1xuICAgICAgaWYgKCghb3ZlcndyaXRlICYmIGVycm9yKSB8fCAhaXNFcnJvcihyZXN1bHQpKSB7XG4gICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlcnJvck1lc3NhZ2UocmVzdWx0KTtcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcnJvckRldGVjdGlvblBsdWdpbihcbiAgIGNvbmZpZzogU2ltcGxlR2l0UGx1Z2luQ29uZmlnWydlcnJvcnMnXVxuKTogU2ltcGxlR2l0UGx1Z2luPCd0YXNrLmVycm9yJz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICd0YXNrLmVycm9yJyxcbiAgICAgIGFjdGlvbihkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgICBjb25zdCBlcnJvciA9IGNvbmZpZyhkYXRhLmVycm9yLCB7XG4gICAgICAgICAgICBzdGRFcnI6IGNvbnRleHQuc3RkRXJyLFxuICAgICAgICAgICAgc3RkT3V0OiBjb250ZXh0LnN0ZE91dCxcbiAgICAgICAgICAgIGV4aXRDb2RlOiBjb250ZXh0LmV4aXRDb2RlLFxuICAgICAgICAgfSk7XG5cbiAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZXJyb3IpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogbmV3IEdpdEVycm9yKHVuZGVmaW5lZCwgZXJyb3IudG9TdHJpbmcoJ3V0Zi04JykpIH07XG4gICAgICAgICB9XG5cbiAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgIH07XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJpbXBvcnQgeyBTaW1wbGVHaXRQbHVnaW4sIFNpbXBsZUdpdFBsdWdpblR5cGUsIFNpbXBsZUdpdFBsdWdpblR5cGVzIH0gZnJvbSAnLi9zaW1wbGUtZ2l0LXBsdWdpbic7XG5pbXBvcnQgeyBhcHBlbmQsIGFzQXJyYXkgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBQbHVnaW5TdG9yZSB7XG4gICBwcml2YXRlIHBsdWdpbnM6IFNldDxTaW1wbGVHaXRQbHVnaW48U2ltcGxlR2l0UGx1Z2luVHlwZT4+ID0gbmV3IFNldCgpO1xuXG4gICBwdWJsaWMgYWRkPFQgZXh0ZW5kcyBTaW1wbGVHaXRQbHVnaW5UeXBlPihcbiAgICAgIHBsdWdpbjogdm9pZCB8IFNpbXBsZUdpdFBsdWdpbjxUPiB8IFNpbXBsZUdpdFBsdWdpbjxUPltdXG4gICApIHtcbiAgICAgIGNvbnN0IHBsdWdpbnM6IFNpbXBsZUdpdFBsdWdpbjxUPltdID0gW107XG5cbiAgICAgIGFzQXJyYXkocGx1Z2luKS5mb3JFYWNoKChwbHVnaW4pID0+IHBsdWdpbiAmJiB0aGlzLnBsdWdpbnMuYWRkKGFwcGVuZChwbHVnaW5zLCBwbHVnaW4pKSk7XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICBwbHVnaW5zLmZvckVhY2goKHBsdWdpbikgPT4gdGhpcy5wbHVnaW5zLmRlbGV0ZShwbHVnaW4pKTtcbiAgICAgIH07XG4gICB9XG5cbiAgIHB1YmxpYyBleGVjPFQgZXh0ZW5kcyBTaW1wbGVHaXRQbHVnaW5UeXBlPihcbiAgICAgIHR5cGU6IFQsXG4gICAgICBkYXRhOiBTaW1wbGVHaXRQbHVnaW5UeXBlc1tUXVsnZGF0YSddLFxuICAgICAgY29udGV4dDogU2ltcGxlR2l0UGx1Z2luVHlwZXNbVF1bJ2NvbnRleHQnXVxuICAgKTogdHlwZW9mIGRhdGEge1xuICAgICAgbGV0IG91dHB1dCA9IGRhdGE7XG4gICAgICBjb25zdCBjb250ZXh0dWFsID0gT2JqZWN0LmZyZWV6ZShPYmplY3QuY3JlYXRlKGNvbnRleHQpKTtcblxuICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKSB7XG4gICAgICAgICBpZiAocGx1Z2luLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IHBsdWdpbi5hY3Rpb24ob3V0cHV0LCBjb250ZXh0dWFsKTtcbiAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBTaW1wbGVHaXRPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgYXNOdW1iZXIsIGluY2x1ZGluZyB9IGZyb20gJy4uL3V0aWxzJztcblxuaW1wb3J0IHsgU2ltcGxlR2l0UGx1Z2luIH0gZnJvbSAnLi9zaW1wbGUtZ2l0LXBsdWdpbic7XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9ncmVzc01vbml0b3JQbHVnaW4ocHJvZ3Jlc3M6IEV4Y2x1ZGU8U2ltcGxlR2l0T3B0aW9uc1sncHJvZ3Jlc3MnXSwgdm9pZD4pIHtcbiAgIGNvbnN0IHByb2dyZXNzQ29tbWFuZCA9ICctLXByb2dyZXNzJztcbiAgIGNvbnN0IHByb2dyZXNzTWV0aG9kcyA9IFsnY2hlY2tvdXQnLCAnY2xvbmUnLCAnZmV0Y2gnLCAncHVsbCcsICdwdXNoJ107XG5cbiAgIGNvbnN0IG9uUHJvZ3Jlc3M6IFNpbXBsZUdpdFBsdWdpbjwnc3Bhd24uYWZ0ZXInPiA9IHtcbiAgICAgIHR5cGU6ICdzcGF3bi5hZnRlcicsXG4gICAgICBhY3Rpb24oX2RhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgIGlmICghY29udGV4dC5jb21tYW5kcy5pbmNsdWRlcyhwcm9ncmVzc0NvbW1hbmQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICB9XG5cbiAgICAgICAgIGNvbnRleHQuc3Bhd25lZC5zdGRlcnI/Lm9uKCdkYXRhJywgKGNodW5rOiBCdWZmZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAvXihbXFxzXFxTXSs/KTpcXHMqKFxcZCspJSBcXCgoXFxkKylcXC8oXFxkKylcXCkvLmV4ZWMoY2h1bmsudG9TdHJpbmcoJ3V0ZjgnKSk7XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICAgbWV0aG9kOiBjb250ZXh0Lm1ldGhvZCxcbiAgICAgICAgICAgICAgIHN0YWdlOiBwcm9ncmVzc0V2ZW50U3RhZ2UobWVzc2FnZVsxXSksXG4gICAgICAgICAgICAgICBwcm9ncmVzczogYXNOdW1iZXIobWVzc2FnZVsyXSksXG4gICAgICAgICAgICAgICBwcm9jZXNzZWQ6IGFzTnVtYmVyKG1lc3NhZ2VbM10pLFxuICAgICAgICAgICAgICAgdG90YWw6IGFzTnVtYmVyKG1lc3NhZ2VbNF0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICB9KTtcbiAgICAgIH0sXG4gICB9O1xuXG4gICBjb25zdCBvbkFyZ3M6IFNpbXBsZUdpdFBsdWdpbjwnc3Bhd24uYXJncyc+ID0ge1xuICAgICAgdHlwZTogJ3NwYXduLmFyZ3MnLFxuICAgICAgYWN0aW9uKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgIGlmICghcHJvZ3Jlc3NNZXRob2RzLmluY2x1ZGVzKGNvbnRleHQubWV0aG9kKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHJldHVybiBpbmNsdWRpbmcoYXJncywgcHJvZ3Jlc3NDb21tYW5kKTtcbiAgICAgIH0sXG4gICB9O1xuXG4gICByZXR1cm4gW29uQXJncywgb25Qcm9ncmVzc107XG59XG5cbmZ1bmN0aW9uIHByb2dyZXNzRXZlbnRTdGFnZShpbnB1dDogc3RyaW5nKSB7XG4gICByZXR1cm4gU3RyaW5nKGlucHV0LnRvTG93ZXJDYXNlKCkuc3BsaXQoJyAnLCAxKSkgfHwgJ3Vua25vd24nO1xufVxuIiwgImltcG9ydCB7IFNwYXduT3B0aW9ucyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHsgcGljayB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IFNpbXBsZUdpdFBsdWdpbiB9IGZyb20gJy4vc2ltcGxlLWdpdC1wbHVnaW4nO1xuXG5leHBvcnQgZnVuY3Rpb24gc3Bhd25PcHRpb25zUGx1Z2luKFxuICAgc3Bhd25PcHRpb25zOiBQYXJ0aWFsPFNwYXduT3B0aW9ucz5cbik6IFNpbXBsZUdpdFBsdWdpbjwnc3Bhd24ub3B0aW9ucyc+IHtcbiAgIGNvbnN0IG9wdGlvbnMgPSBwaWNrKHNwYXduT3B0aW9ucywgWyd1aWQnLCAnZ2lkJ10pO1xuXG4gICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3NwYXduLm9wdGlvbnMnLFxuICAgICAgYWN0aW9uKGRhdGEpIHtcbiAgICAgICAgIHJldHVybiB7IC4uLm9wdGlvbnMsIC4uLmRhdGEgfTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImltcG9ydCB0eXBlIHsgU2ltcGxlR2l0UGx1Z2luIH0gZnJvbSAnLi9zaW1wbGUtZ2l0LXBsdWdpbic7XG5cbmltcG9ydCB0eXBlIHsgU2ltcGxlR2l0T3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEdpdFBsdWdpbkVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2dpdC1wbHVnaW4tZXJyb3InO1xuXG5leHBvcnQgZnVuY3Rpb24gdGltZW91dFBsdWdpbih7XG4gICBibG9jayxcbiAgIHN0ZEVyciA9IHRydWUsXG4gICBzdGRPdXQgPSB0cnVlLFxufTogRXhjbHVkZTxTaW1wbGVHaXRPcHRpb25zWyd0aW1lb3V0J10sIHVuZGVmaW5lZD4pOiBTaW1wbGVHaXRQbHVnaW48J3NwYXduLmFmdGVyJz4gfCB2b2lkIHtcbiAgIGlmIChibG9jayA+IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICB0eXBlOiAnc3Bhd24uYWZ0ZXInLFxuICAgICAgICAgYWN0aW9uKF9kYXRhLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBsZXQgdGltZW91dDogTm9kZUpTLlRpbWVvdXQ7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHdhaXQoKSB7XG4gICAgICAgICAgICAgICB0aW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGtpbGwsIGJsb2NrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgICAgICAgIGNvbnRleHQuc3Bhd25lZC5zdGRvdXQ/Lm9mZignZGF0YScsIHdhaXQpO1xuICAgICAgICAgICAgICAgY29udGV4dC5zcGF3bmVkLnN0ZGVycj8ub2ZmKCdkYXRhJywgd2FpdCk7XG4gICAgICAgICAgICAgICBjb250ZXh0LnNwYXduZWQub2ZmKCdleGl0Jywgc3RvcCk7XG4gICAgICAgICAgICAgICBjb250ZXh0LnNwYXduZWQub2ZmKCdjbG9zZScsIHN0b3ApO1xuICAgICAgICAgICAgICAgdGltZW91dCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICAgICBjb250ZXh0LmtpbGwobmV3IEdpdFBsdWdpbkVycm9yKHVuZGVmaW5lZCwgJ3RpbWVvdXQnLCBgYmxvY2sgdGltZW91dCByZWFjaGVkYCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGRPdXQgJiYgY29udGV4dC5zcGF3bmVkLnN0ZG91dD8ub24oJ2RhdGEnLCB3YWl0KTtcbiAgICAgICAgICAgIHN0ZEVyciAmJiBjb250ZXh0LnNwYXduZWQuc3RkZXJyPy5vbignZGF0YScsIHdhaXQpO1xuICAgICAgICAgICAgY29udGV4dC5zcGF3bmVkLm9uKCdleGl0Jywgc3RvcCk7XG4gICAgICAgICAgICBjb250ZXh0LnNwYXduZWQub24oJ2Nsb3NlJywgc3RvcCk7XG5cbiAgICAgICAgICAgIHdhaXQoKTtcbiAgICAgICAgIH0sXG4gICAgICB9O1xuICAgfVxufVxuIiwgImltcG9ydCB7IFNpbXBsZUdpdFBsdWdpbiB9IGZyb20gJy4vc2ltcGxlLWdpdC1wbHVnaW4nO1xuaW1wb3J0IHsgaXNQYXRoU3BlYywgdG9QYXRocyB9IGZyb20gJy4uL2FyZ3MvcGF0aHNwZWMnO1xuXG5leHBvcnQgZnVuY3Rpb24gc3VmZml4UGF0aHNQbHVnaW4oKTogU2ltcGxlR2l0UGx1Z2luPCdzcGF3bi5hcmdzJz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdzcGF3bi5hcmdzJyxcbiAgICAgIGFjdGlvbihkYXRhKSB7XG4gICAgICAgICBjb25zdCBwcmVmaXg6IHN0cmluZ1tdID0gW107XG4gICAgICAgICBsZXQgc3VmZml4OiB1bmRlZmluZWQgfCBzdHJpbmdbXTtcbiAgICAgICAgIGZ1bmN0aW9uIGFwcGVuZChhcmdzOiBzdHJpbmdbXSkge1xuICAgICAgICAgICAgKHN1ZmZpeCA9IHN1ZmZpeCB8fCBbXSkucHVzaCguLi5hcmdzKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IGRhdGFbaV07XG5cbiAgICAgICAgICAgIGlmIChpc1BhdGhTcGVjKHBhcmFtKSkge1xuICAgICAgICAgICAgICAgYXBwZW5kKHRvUGF0aHMocGFyYW0pKTtcbiAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyYW0gPT09ICctLScpIHtcbiAgICAgICAgICAgICAgIGFwcGVuZChcbiAgICAgICAgICAgICAgICAgIGRhdGEuc2xpY2UoaSArIDEpLmZsYXRNYXAoKGl0ZW0pID0+IChpc1BhdGhTcGVjKGl0ZW0pICYmIHRvUGF0aHMoaXRlbSkpIHx8IGl0ZW0pXG4gICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZWZpeC5wdXNoKHBhcmFtKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuICFzdWZmaXggPyBwcmVmaXggOiBbLi4ucHJlZml4LCAnLS0nLCAuLi5zdWZmaXgubWFwKFN0cmluZyldO1xuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgU2ltcGxlR2l0RmFjdG9yeSB9IGZyb20gJy4uLy4uL3R5cGluZ3MnO1xuXG5pbXBvcnQgKiBhcyBhcGkgZnJvbSAnLi9hcGknO1xuaW1wb3J0IHtcbiAgIGFib3J0UGx1Z2luLFxuICAgYmxvY2tVbnNhZmVPcGVyYXRpb25zUGx1Z2luLFxuICAgY29tbWFuZENvbmZpZ1ByZWZpeGluZ1BsdWdpbixcbiAgIGNvbXBsZXRpb25EZXRlY3Rpb25QbHVnaW4sXG4gICBlcnJvckRldGVjdGlvbkhhbmRsZXIsXG4gICBlcnJvckRldGVjdGlvblBsdWdpbixcbiAgIFBsdWdpblN0b3JlLFxuICAgcHJvZ3Jlc3NNb25pdG9yUGx1Z2luLFxuICAgc3Bhd25PcHRpb25zUGx1Z2luLFxuICAgdGltZW91dFBsdWdpbixcbn0gZnJvbSAnLi9wbHVnaW5zJztcbmltcG9ydCB7IHN1ZmZpeFBhdGhzUGx1Z2luIH0gZnJvbSAnLi9wbHVnaW5zL3N1ZmZpeC1wYXRocy5wbHVnaW4nO1xuaW1wb3J0IHsgY3JlYXRlSW5zdGFuY2VDb25maWcsIGZvbGRlckV4aXN0cyB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgU2ltcGxlR2l0T3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBHaXQgPSByZXF1aXJlKCcuLi9naXQnKTtcblxuLyoqXG4gKiBBZGRzIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllcyB0byB0aGUgc3VwcGxpZWQgb2JqZWN0IHRvIGVuYWJsZSBpdCBmb3IgdXNlIGFzXG4gKiB0aGUgZGVmYXVsdCBleHBvcnQgb2YgYSBtb2R1bGUuXG4gKlxuICogRWc6IGBtb2R1bGUuZXhwb3J0cyA9IGVzTW9kdWxlRmFjdG9yeSh7IHNvbWV0aGluZyAoKSB7fSB9KWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVzTW9kdWxlRmFjdG9yeTxUPihkZWZhdWx0RXhwb3J0OiBUKSB7XG4gICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZGVmYXVsdEV4cG9ydCwge1xuICAgICAgX19lc01vZHVsZTogeyB2YWx1ZTogdHJ1ZSB9LFxuICAgICAgZGVmYXVsdDogeyB2YWx1ZTogZGVmYXVsdEV4cG9ydCB9LFxuICAgfSkgYXMgVCAmIHsgX19lc01vZHVsZTogdHJ1ZTsgZGVmYXVsdDogVCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2l0RXhwb3J0RmFjdG9yeShmYWN0b3J5OiBTaW1wbGVHaXRGYWN0b3J5KSB7XG4gICByZXR1cm4gT2JqZWN0LmFzc2lnbihmYWN0b3J5LmJpbmQobnVsbCksIGFwaSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnaXRJbnN0YW5jZUZhY3RvcnkoXG4gICBiYXNlRGlyPzogc3RyaW5nIHwgUGFydGlhbDxTaW1wbGVHaXRPcHRpb25zPixcbiAgIG9wdGlvbnM/OiBQYXJ0aWFsPFNpbXBsZUdpdE9wdGlvbnM+XG4pIHtcbiAgIGNvbnN0IHBsdWdpbnMgPSBuZXcgUGx1Z2luU3RvcmUoKTtcbiAgIGNvbnN0IGNvbmZpZyA9IGNyZWF0ZUluc3RhbmNlQ29uZmlnKFxuICAgICAgKGJhc2VEaXIgJiYgKHR5cGVvZiBiYXNlRGlyID09PSAnc3RyaW5nJyA/IHsgYmFzZURpciB9IDogYmFzZURpcikpIHx8IHt9LFxuICAgICAgb3B0aW9uc1xuICAgKTtcblxuICAgaWYgKCFmb2xkZXJFeGlzdHMoY29uZmlnLmJhc2VEaXIpKSB7XG4gICAgICB0aHJvdyBuZXcgYXBpLkdpdENvbnN0cnVjdEVycm9yKFxuICAgICAgICAgY29uZmlnLFxuICAgICAgICAgYENhbm5vdCB1c2Ugc2ltcGxlLWdpdCBvbiBhIGRpcmVjdG9yeSB0aGF0IGRvZXMgbm90IGV4aXN0YFxuICAgICAgKTtcbiAgIH1cblxuICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLmNvbmZpZykpIHtcbiAgICAgIHBsdWdpbnMuYWRkKGNvbW1hbmRDb25maWdQcmVmaXhpbmdQbHVnaW4oY29uZmlnLmNvbmZpZykpO1xuICAgfVxuXG4gICBwbHVnaW5zLmFkZChibG9ja1Vuc2FmZU9wZXJhdGlvbnNQbHVnaW4oY29uZmlnLnVuc2FmZSkpO1xuICAgcGx1Z2lucy5hZGQoc3VmZml4UGF0aHNQbHVnaW4oKSk7XG4gICBwbHVnaW5zLmFkZChjb21wbGV0aW9uRGV0ZWN0aW9uUGx1Z2luKGNvbmZpZy5jb21wbGV0aW9uKSk7XG4gICBjb25maWcuYWJvcnQgJiYgcGx1Z2lucy5hZGQoYWJvcnRQbHVnaW4oY29uZmlnLmFib3J0KSk7XG4gICBjb25maWcucHJvZ3Jlc3MgJiYgcGx1Z2lucy5hZGQocHJvZ3Jlc3NNb25pdG9yUGx1Z2luKGNvbmZpZy5wcm9ncmVzcykpO1xuICAgY29uZmlnLnRpbWVvdXQgJiYgcGx1Z2lucy5hZGQodGltZW91dFBsdWdpbihjb25maWcudGltZW91dCkpO1xuICAgY29uZmlnLnNwYXduT3B0aW9ucyAmJiBwbHVnaW5zLmFkZChzcGF3bk9wdGlvbnNQbHVnaW4oY29uZmlnLnNwYXduT3B0aW9ucykpO1xuXG4gICBwbHVnaW5zLmFkZChlcnJvckRldGVjdGlvblBsdWdpbihlcnJvckRldGVjdGlvbkhhbmRsZXIodHJ1ZSkpKTtcbiAgIGNvbmZpZy5lcnJvcnMgJiYgcGx1Z2lucy5hZGQoZXJyb3JEZXRlY3Rpb25QbHVnaW4oY29uZmlnLmVycm9ycykpO1xuXG4gICByZXR1cm4gbmV3IEdpdChjb25maWcsIHBsdWdpbnMpO1xufVxuIiwgImltcG9ydCB7IFNpbXBsZUdpdCwgU2ltcGxlR2l0T3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuXG5pbXBvcnQgeyBHaXRSZXNwb25zZUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2dpdC1yZXNwb25zZS1lcnJvcic7XG5pbXBvcnQgeyBnaXRJbnN0YW5jZUZhY3RvcnkgfSBmcm9tICcuLi9naXQtZmFjdG9yeSc7XG5pbXBvcnQgeyBTaW1wbGVHaXRUYXNrQ2FsbGJhY2sgfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IGZ1bmN0aW9uTmFtZXNCdWlsZGVyQXBpID0gWydjdXN0b21CaW5hcnknLCAnZW52JywgJ291dHB1dEhhbmRsZXInLCAnc2lsZW50J107XG5cbmNvbnN0IGZ1bmN0aW9uTmFtZXNQcm9taXNlQXBpID0gW1xuICAgJ2FkZCcsXG4gICAnYWRkQW5ub3RhdGVkVGFnJyxcbiAgICdhZGRDb25maWcnLFxuICAgJ2FkZFJlbW90ZScsXG4gICAnYWRkVGFnJyxcbiAgICdhcHBseVBhdGNoJyxcbiAgICdiaW5hcnlDYXRGaWxlJyxcbiAgICdicmFuY2gnLFxuICAgJ2JyYW5jaExvY2FsJyxcbiAgICdjYXRGaWxlJyxcbiAgICdjaGVja0lnbm9yZScsXG4gICAnY2hlY2tJc1JlcG8nLFxuICAgJ2NoZWNrb3V0JyxcbiAgICdjaGVja291dEJyYW5jaCcsXG4gICAnY2hlY2tvdXRMYXRlc3RUYWcnLFxuICAgJ2NoZWNrb3V0TG9jYWxCcmFuY2gnLFxuICAgJ2NsZWFuJyxcbiAgICdjbG9uZScsXG4gICAnY29tbWl0JyxcbiAgICdjd2QnLFxuICAgJ2RlbGV0ZUxvY2FsQnJhbmNoJyxcbiAgICdkZWxldGVMb2NhbEJyYW5jaGVzJyxcbiAgICdkaWZmJyxcbiAgICdkaWZmU3VtbWFyeScsXG4gICAnZXhlYycsXG4gICAnZmV0Y2gnLFxuICAgJ2dldFJlbW90ZXMnLFxuICAgJ2luaXQnLFxuICAgJ2xpc3RDb25maWcnLFxuICAgJ2xpc3RSZW1vdGUnLFxuICAgJ2xvZycsXG4gICAnbWVyZ2UnLFxuICAgJ21lcmdlRnJvbVRvJyxcbiAgICdtaXJyb3InLFxuICAgJ212JyxcbiAgICdwdWxsJyxcbiAgICdwdXNoJyxcbiAgICdwdXNoVGFncycsXG4gICAncmF3JyxcbiAgICdyZWJhc2UnLFxuICAgJ3JlbW90ZScsXG4gICAncmVtb3ZlUmVtb3RlJyxcbiAgICdyZXNldCcsXG4gICAncmV2ZXJ0JyxcbiAgICdyZXZwYXJzZScsXG4gICAncm0nLFxuICAgJ3JtS2VlcExvY2FsJyxcbiAgICdzaG93JyxcbiAgICdzdGFzaCcsXG4gICAnc3Rhc2hMaXN0JyxcbiAgICdzdGF0dXMnLFxuICAgJ3N1Yk1vZHVsZScsXG4gICAnc3VibW9kdWxlQWRkJyxcbiAgICdzdWJtb2R1bGVJbml0JyxcbiAgICdzdWJtb2R1bGVVcGRhdGUnLFxuICAgJ3RhZycsXG4gICAndGFncycsXG4gICAndXBkYXRlU2VydmVySW5mbycsXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2l0UChcbiAgIC4uLmFyZ3M6IFtdIHwgW3N0cmluZ10gfCBbUGFydGlhbDxTaW1wbGVHaXRPcHRpb25zPl0gfCBbc3RyaW5nLCBQYXJ0aWFsPFNpbXBsZUdpdE9wdGlvbnM+XVxuKTogU2ltcGxlR2l0IHtcbiAgIGxldCBnaXQ6IGFueTtcblxuICAgbGV0IGNoYWluID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgIHRyeSB7XG4gICAgICBnaXQgPSBnaXRJbnN0YW5jZUZhY3RvcnkoLi4uYXJncyk7XG4gICB9IGNhdGNoIChlKSB7XG4gICAgICBjaGFpbiA9IFByb21pc2UucmVqZWN0KGUpO1xuICAgfVxuXG4gICBmdW5jdGlvbiBidWlsZGVyUmV0dXJuKCkge1xuICAgICAgcmV0dXJuIHByb21pc2VBcGk7XG4gICB9XG5cbiAgIGZ1bmN0aW9uIGNoYWluUmV0dXJuKCkge1xuICAgICAgcmV0dXJuIGNoYWluO1xuICAgfVxuXG4gICBjb25zdCBwcm9taXNlQXBpID0gWy4uLmZ1bmN0aW9uTmFtZXNCdWlsZGVyQXBpLCAuLi5mdW5jdGlvbk5hbWVzUHJvbWlzZUFwaV0ucmVkdWNlKFxuICAgICAgKGFwaTogYW55LCBuYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgIGNvbnN0IGlzQXN5bmMgPSBmdW5jdGlvbk5hbWVzUHJvbWlzZUFwaS5pbmNsdWRlcyhuYW1lKTtcblxuICAgICAgICAgY29uc3QgdmFsaWQgPSBpc0FzeW5jID8gYXN5bmNXcmFwcGVyKG5hbWUsIGdpdCkgOiBzeW5jV3JhcHBlcihuYW1lLCBnaXQsIGFwaSk7XG4gICAgICAgICBjb25zdCBhbHRlcm5hdGl2ZSA9IGlzQXN5bmMgPyBjaGFpblJldHVybiA6IGJ1aWxkZXJSZXR1cm47XG5cbiAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcGksIG5hbWUsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBnaXQgPyB2YWxpZCA6IGFsdGVybmF0aXZlLFxuICAgICAgICAgfSk7XG5cbiAgICAgICAgIHJldHVybiBhcGk7XG4gICAgICB9LFxuICAgICAge31cbiAgICk7XG5cbiAgIHJldHVybiBwcm9taXNlQXBpIGFzIFNpbXBsZUdpdDtcblxuICAgZnVuY3Rpb24gYXN5bmNXcmFwcGVyKGZuOiBzdHJpbmcsIGdpdDogYW55KTogKC4uLmFyZ3M6IGFueVtdKSA9PiBQcm9taXNlPGFueT4ge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzOiBhbnlbXSkge1xuICAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICdQcm9taXNlIGludGVyZmFjZSByZXF1aXJlcyB0aGF0IGhhbmRsZXJzIGFyZSBub3Qgc3VwcGxpZWQgaW5saW5lLCAnICtcbiAgICAgICAgICAgICAgICAgICd0cmFpbGluZyBmdW5jdGlvbiBub3QgYWxsb3dlZCBpbiBjYWxsIHRvICcgK1xuICAgICAgICAgICAgICAgICAgZm5cbiAgICAgICAgICAgICk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHJldHVybiBjaGFpbi50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICBjb25zdCBjYWxsYmFjazogU2ltcGxlR2l0VGFza0NhbGxiYWNrID0gKGVycjogRXJyb3IgfCBudWxsLCByZXN1bHQ/OiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QodG9FcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgIGFyZ3MucHVzaChjYWxsYmFjayk7XG5cbiAgICAgICAgICAgICAgIGdpdFtmbl0uYXBwbHkoZ2l0LCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgfVxuXG4gICBmdW5jdGlvbiBzeW5jV3JhcHBlcihmbjogc3RyaW5nLCBnaXQ6IGFueSwgYXBpOiBTaW1wbGVHaXQpIHtcbiAgICAgIHJldHVybiAoLi4uYXJnczogYW55W10pID0+IHtcbiAgICAgICAgIGdpdFtmbl0oLi4uYXJncyk7XG5cbiAgICAgICAgIHJldHVybiBhcGk7XG4gICAgICB9O1xuICAgfVxufVxuXG5mdW5jdGlvbiB0b0Vycm9yKGVycm9yOiBFcnJvciB8IHN0cmluZyB8IGFueSk6IEVycm9yIHtcbiAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICB9XG5cbiAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKGVycm9yKTtcbiAgIH1cblxuICAgcmV0dXJuIG5ldyBHaXRSZXNwb25zZUVycm9yKGVycm9yKTtcbn1cbiIsICJpbXBvcnQgeyBnaXRJbnN0YW5jZUZhY3RvcnkgfSBmcm9tICcuL2xpYi9naXQtZmFjdG9yeSc7XG5cbmV4cG9ydCB7IGdpdFAgfSBmcm9tICcuL2xpYi9ydW5uZXJzL3Byb21pc2Utd3JhcHBlZCc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9hcGknO1xuXG5leHBvcnQgY29uc3Qgc2ltcGxlR2l0ID0gZ2l0SW5zdGFuY2VGYWN0b3J5O1xuXG5leHBvcnQgZGVmYXVsdCBnaXRJbnN0YW5jZUZhY3Rvcnk7XG4iXSwKICAibWFwcGlu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aUIsU0FBUyxhQUFhO0FBRW5ELFlBQU0sZUFBZTtBQUFBLFFBQ25CLFFBQVE7QUFBQSxRQUNSLE1BQU07QUFBQSxRQUNOO0FBQUEsTUFDRjtBQUdBLFlBQU0sV0FBVyxNQUFNLE1BQU0sS0FBSyxTQUFTLFlBQVksWUFBWTtBQUNuRSxZQUFNLE9BQU8sTUFBTSxTQUFTLEtBQUs7QUFHakMsVUFBSSx1QkFBTyxJQUFJO0FBQUEsSUFDakIsU0FBUyxPQUFQO0FBQ0EsY0FBUSxNQUFNLDJCQUEyQixLQUFLO0FBQzlDLFVBQUksdUJBQU8sdUJBQXVCLE1BQU0sT0FBTztBQUFBLElBQ2pEO0FBQUEsRUFDRjtBQUNGO0FBR0EsSUFBTSxrQkFBTixjQUE4QixpQ0FBaUI7QUFBQSxFQUc3QyxZQUFZLEtBQVUsUUFBcUI7QUFDekMsVUFBTSxLQUFLLE1BQU07QUFDakIsU0FBSyxTQUFTO0FBQUEsRUFDaEI7QUFBQSxFQUVBLFVBQWdCO0FBQ2QsVUFBTSxFQUFDLFlBQVcsSUFBSTtBQUV0QixnQkFBWSxNQUFNO0FBRWxCLFFBQUksd0JBQVEsV0FBVyxFQUNwQixRQUFRLGFBQWEsRUFDckIsUUFBUSxrRUFBa0UsRUFDMUUsUUFBUSxVQUFRLEtBQ2QsZUFBZSwwQ0FBMEMsRUFDekQsU0FBUyxLQUFLLE9BQU8sU0FBUyxVQUFVLEVBQ3hDLFNBQVMsT0FBTyxVQUFVO0FBQ3pCLFdBQUssT0FBTyxTQUFTLGFBQWE7QUFDbEMsWUFBTSxLQUFLLE9BQU8sYUFBYTtBQUFBLElBQ2pDLENBQUMsQ0FBQztBQUVOLFFBQUksd0JBQVEsV0FBVyxFQUNwQixRQUFRLGtCQUFrQixFQUMxQixRQUFRLHVEQUF1RCxFQUMvRCxRQUFRLFVBQVEsS0FDZCxlQUFlLFFBQVEsRUFDdkIsU0FBUyxLQUFLLE9BQU8sU0FBUyxlQUFlLEVBQzdDLFNBQVMsT0FBTyxVQUFVO0FBQ3pCLFdBQUssT0FBTyxTQUFTLGtCQUFrQjtBQUN2QyxZQUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsSUFDakMsQ0FBQyxDQUFDO0FBRU4sUUFBSSx3QkFBUSxXQUFXLEVBQ3BCLFFBQVEsa0JBQWtCLEVBQzFCLFFBQVEsdURBQXVELEVBQy9ELFFBQVEsVUFBUSxLQUNkLGVBQWUsT0FBTyxFQUN0QixTQUFTLEtBQUssT0FBTyxTQUFTLGVBQWUsRUFDN0MsU0FBUyxPQUFPLFVBQVU7QUFDekIsV0FBSyxPQUFPLFNBQVMsa0JBQWtCO0FBQ3ZDLFlBQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxJQUNqQyxDQUFDLENBQUM7QUFBQSxFQUNSO0FBQ0Y7IiwKICAibmFtZXMiOiBbIm1vZHVsZSIsICJtb2R1bGUiLCAiZGVidWciLCAibW9kdWxlIiwgImV4aXN0cyIsICJfX2V4cG9ydCIsICJkZWZlcnJlZCIsICJpbXBvcnRfcHJvbWlzZV9kZWZlcnJlZCIsICJfX2V4cG9ydCIsICJDbGVhbk9wdGlvbnMyIiwgImRlYnVnIiwgIl9fY29tbW9uSlMiLCAibW9kdWxlIiwgIl9fdG9Db21tb25KUyJdCn0K
